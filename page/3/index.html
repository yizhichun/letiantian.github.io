<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="乐天笔记, 樂天笔记, 编程" />





  <link rel="alternate" href="/atom.xml" title="樂天笔记" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/content/images/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="樂天笔记">
<meta property="og:url" content="http://www.letiantian.me/page/3/index.html">
<meta property="og:site_name" content="樂天笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="樂天笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.letiantian.me/page/3/"/>





  <title>樂天笔记</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <img class='bg-image' src="/content/images/bg.jpg" />

  







  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=62535551";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>









  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">樂天笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-topics">
          <a href="/topics" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-flask"></i> <br />
            
            专题
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.letiantian.me/2015-04-03-knn-text-classification/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Letian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/content/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="樂天笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015-04-03-knn-text-classification/" itemprop="url">基于KNN的文本分类实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-03T10:39:53+08:00">
                April 3rd 2015
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2015-04-03</p>
<p>本文讲述如何使用scikit-learn的KNN工具对文本进行分类。</p>
<h2 id="关于KNN"><a href="#关于KNN" class="headerlink" title="关于KNN"></a>关于KNN</h2><hr>
<p>K-近邻算法，简称KNN（k-Nearest Neighbor），是一个相当简单的分类/预测算法。其主要思想就是，选取与待分类/预测数据的最相似的K个训练数据，通过对这K个数据的结果或者分类标号取平均、取众数等方法得到待分类/预测数据的结果或者分类标号。</p>
<p>关于KNN，笔者在<a href="/2014-06-10-knn/">浅入浅出：K近邻算法</a>有较为详细的介绍。</p>
<h2 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h2><hr>
<p>数据集是有8个分类的文本数据集，使用了结巴分词对每个文本分词，每个单词当作特征，再利用二元词串构造更多特征，然后去掉停用词，去掉出现次数太多和太少的特征，得到了19630个特征。取1998个样本用于训练，509个用于测试。基于词袋模型的思路将每个文本转换为向量，训练集和测试集分别转换为矩阵，并用python numpy模块将其保存为npy格式。</p>
<p>在 <a href="https://github.com/letiantian/dataset" target="_blank" rel="external">https://github.com/letiantian/dataset</a> 下载text-classification.7z，解压后导入数据：</p>
<pre><code>$ ls
test_data.npy  test_labels.npy  training_data.npy  training_labels.npy  
$ ipython
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; training_data = np.load(&quot;training_data.npy&quot;)
&gt;&gt;&gt; training_data.shape
(1998, 19630)
&gt;&gt;&gt; training_labels = np.load(&quot;training_labels.npy&quot;)
&gt;&gt;&gt; training_labels
array([6, 6, 6, ..., 2, 2, 2])  
&gt;&gt;&gt; training_labels.shape
(1998,)
&gt;&gt;&gt; test_data = np.load(&quot;test_data.npy&quot;)
&gt;&gt;&gt; test_data.shape
(509, 19630)
&gt;&gt;&gt; test_labels = np.load(&quot;test_labels.npy&quot;)
&gt;&gt;&gt; test_labels.shape
(509,)
</code></pre><h2 id="如何找一样本的最近k个邻居"><a href="#如何找一样本的最近k个邻居" class="headerlink" title="如何找一样本的最近k个邻居"></a>如何找一样本的最近k个邻居</h2><hr>
<p><strong>方法1：</strong></p>
<pre><code>&gt;&gt;&gt; from sklearn.neighbors import NearestNeighbors
&gt;&gt;&gt; nbrs = NearestNeighbors(n_neighbors=6, algorithm=&#39;ball_tree&#39;)
&gt;&gt;&gt; nbrs.fit(training_data)  # 构造BallTree，可以快速找出6个最近邻居，原理待学习
NearestNeighbors(algorithm=&#39;ball_tree&#39;, leaf_size=30, metric=&#39;minkowski&#39;,
         metric_params=None, n_neighbors=6, p=2, radius=1.0)
&gt;&gt;&gt; distances, indices = nbrs.kneighbors(test_data[0])  # 找training_data中离样本test_data[0]的最近的6个样本
&gt;&gt;&gt; indices  # 6个最近样本，每个值是指在training_data中的第几个样本
array([[500, 294,  62, 802, 732, 703]])
&gt;&gt;&gt; distances  # 对应的距离
array([[ 13.37908816,  13.60147051,  13.60147051,  13.60147051,
         13.60147051,  13.6381817 ]])
</code></pre><p>也可以依次找出多个测试样本的最近的6个训练样本：</p>
<pre><code>&gt;&gt;&gt; distances, indices = nbrs.kneighbors(test_data[0:2])
&gt;&gt;&gt; indices
array([[ 500,  294,   62,  802,  732,  703],
       [  62,  294,  636, 1945,  802, 1091]])
&gt;&gt;&gt; distances
array([[ 13.37908816,  13.60147051,  13.60147051,  13.60147051,
         13.60147051,  13.6381817 ],
       [  7.93725393,   7.93725393,   8.1240384 ,   8.36660027,
          8.54400375,   8.54400375]])
</code></pre><p><strong>方法2：</strong></p>
<pre><code>&gt;&gt;&gt; from sklearn.neighbors import BallTree
&gt;&gt;&gt; bt = BallTree(training_data, metric=&#39;euclidean&#39;)
&gt;&gt;&gt; distances, indices = bt.query(test_data[0], k=6)                  
&gt;&gt;&gt; indices
array([[500,  62, 802, 294, 732, 703]])
&gt;&gt;&gt; distances
array([[ 13.37908816,  13.60147051,  13.60147051,  13.60147051,
         13.60147051,  13.6381817 ]])
</code></pre><h2 id="基于KNN的文本分类"><a href="#基于KNN的文本分类" class="headerlink" title="基于KNN的文本分类"></a>基于KNN的文本分类</h2><hr>
<p>令k=6：</p>
<pre><code>&gt;&gt;&gt; from sklearn.neighbors import KNeighborsClassifier
&gt;&gt;&gt; knn = KNeighborsClassifier(n_neighbors=6, metric=&#39;euclidean&#39;)
&gt;&gt;&gt; knn.fit(training_data, training_labels) # 训练
KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;euclidean&#39;,
           metric_params=None, n_neighbors=6, p=2, weights=&#39;uniform&#39;)
&gt;&gt;&gt; predict_labels = knn.predict(test_data) # 预测
&gt;&gt;&gt; sum(predict_labels == test_labels)
230
&gt;&gt;&gt; 230./509  # 正确率
0.4518664047151277
</code></pre><p>令k=20：</p>
<pre><code>&gt;&gt;&gt; from sklearn.neighbors import KNeighborsClassifier
&gt;&gt;&gt; knn = KNeighborsClassifier(n_neighbors=20, metric=&#39;euclidean&#39;)
&gt;&gt;&gt; knn.fit(training_data, training_labels) # 训练
KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;euclidean&#39;,
           metric_params=None, n_neighbors=20, p=2, weights=&#39;uniform&#39;)
&gt;&gt;&gt; predict_labels = knn.predict(test_data) # 预测
&gt;&gt;&gt; sum(predict_labels == test_labels)
276  # 效果比k=6时提升了一些
&gt;&gt;&gt; 276./509   # 正确率
0.5422396856581533
</code></pre><p>这个正确率并不高。在<a href="/2015-03-31-bayes-classifier-for-text/">基于贝叶斯的文本分类实战</a>中笔者使用了多项式贝叶斯对同样的数据集进行分类，正确率达到近90%。</p>
<h2 id="做个优化"><a href="#做个优化" class="headerlink" title="做个优化"></a>做个优化</h2><hr>
<p>我们将每个样本归一化，看看效果。</p>
<p>先写一个归一化工具（mytools.py）：</p>
<pre><code># !/usr/bin/env python
# -*- encoding:utf-8 -*-

import numpy as np

def uniformization(X):
    if X.ndim != 2:
        return None
    X2 = X.copy()
    X2 = X2.astype(float)
    rows = X2.shape[0]
    for i in xrange(0, rows):
        sum_of_squares = sum(X2[i, :]**2)
        if sum_of_squares == 0: continue
        sqrt_sum_of_squares = sum_of_squares**0.5
        X2[i, :] = X2[i, :] / sqrt_sum_of_squares
    return X2 

if __name__ == &#39;__main__&#39;:
    arr = np.array([[1,2,3],[4,5,6],[0,0,0]])
    print uniformization(arr)
</code></pre><p>运行结果如下：</p>
<pre><code>[[ 0.26726124  0.53452248  0.80178373]
 [ 0.45584231  0.56980288  0.68376346]
 [ 0.          0.          0.
</code></pre><p>处理原始数据集，生成新的数据：</p>
<pre><code>&gt;&gt;&gt; from mytools import uniformization
&gt;&gt;&gt; new_training_data = uniformization(training_data)
&gt;&gt;&gt; new_test_data = uniformization(test_data)
</code></pre><p>令k=6：</p>
<pre><code>&gt;&gt;&gt; knn = KNeighborsClassifier(n_neighbors=6, metric=&#39;euclidean&#39;)
&gt;&gt;&gt; knn.fit(new_training_data, training_labels) # 使用新数据训练
KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;euclidean&#39;,
           metric_params=None, n_neighbors=6, p=2, weights=&#39;uniform&#39;)
&gt;&gt;&gt; predict_labels = knn.predict(new_test_data) # 预测
&gt;&gt;&gt; sum(predict_labels == test_labels)
294  # 由230提升到294
&gt;&gt;&gt; 294./509  # 正确率有提升
0.5776031434184676
</code></pre><p>令k=20：</p>
<pre><code>&gt;&gt;&gt; from sklearn.neighbors import KNeighborsClassifier
&gt;&gt;&gt; knn = KNeighborsClassifier(n_neighbors=20, metric=&#39;euclidean&#39;)
&gt;&gt;&gt; knn.fit(new_training_data, training_labels)  # 使用新数据训练
KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;euclidean&#39;,
           metric_params=None, n_neighbors=20, p=2, weights=&#39;uniform&#39;)
&gt;&gt;&gt; predict_labels = knn.predict(new_test_data)  # 预测
&gt;&gt;&gt; sum(predict_labels == test_labels)
314  # 由276提升到314
&gt;&gt;&gt; 314./509  # 正确率有提升
0.6168958742632613
</code></pre><p>可以看到，归一化后，预测分类的正确率提升很多。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="http://scikit-learn.org/stable/modules/neighbors.html" target="_blank" rel="external">1.6. Nearest Neighbors</a><br><a href="http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier" target="_blank" rel="external">sklearn.neighbors.KNeighborsClassifier</a></p>
<p>（完）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.letiantian.me/2015-04-01-recursive-feature-elimination/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Letian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/content/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="樂天笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015-04-01-recursive-feature-elimination/" itemprop="url">使用特征递归消除筛选特征</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-01T10:52:52+08:00">
                April 1st 2015
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2015-04-01</p>
<p>特征递归消除（recursive feature elimination，RFE）是特征选择的一种方法。</p>
<p><a href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html" target="_blank" rel="external">http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html</a>给出了RFE的基本思想：</p>
<blockquote>
<p> the goal of recursive feature elimination (RFE) is to select features by recursively considering smaller and smaller sets of features. First, the estimator is trained on the initial set of features and weights are assigned to each one of them. Then, features whose absolute weights are the smallest are pruned from the current set features. That procedure is recursively repeated on the pruned set until the desired number of features to select is eventually reached.</p>
</blockquote>
<p>而在<a href="http://book.douban.com/subject/25899625/" target="_blank" rel="external">《机器学习系统设计》</a>的第11章也提到了RFE，并给了一个流程图：</p>
<p><img src="/content/images/2015/04/2015-04-01-rfe.jpg" alt=""></p>
<p>可以看出RFE是一个迭代的过程（不是递归）。</p>
<p>下面讲一下如何使用scikit-learn中的RFE工具，本文最后部分介绍RFE的实现。</p>
<h2 id="导入数据集"><a href="#导入数据集" class="headerlink" title="导入数据集"></a>导入数据集</h2><hr>
<p>数据集是有8个分类的文本数据集，使用了结巴分词对每个文本分词，每个单词当作特征，再利用二元词串构造更多特征，然后去掉停用词，去掉出现次数太多和太少的特征，得到了19630个特征。取1998个样本用于训练，509个用于测试。基于词袋模型的思路将每个文本转换为向量，训练集和测试集分别转换为矩阵，并用python numpy模块将其保存为npy格式。</p>
<p>在<a href="https://github.com/letiantian/dataset-for-classifying" target="_blank" rel="external">https://github.com/letiantian/dataset-for-classifying</a>下载documents.7z，解压后导入数据：</p>
<pre><code>$ ls
test_data.npy  test_labels.npy  training_data.npy  training_labels.npy  
$ ipython
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; training_data = np.load(&quot;training_data.npy&quot;)
&gt;&gt;&gt; training_data.shape
(1998, 19630)
&gt;&gt;&gt; training_labels = np.load(&quot;training_labels.npy&quot;)
&gt;&gt;&gt; training_labels
array([6, 6, 6, ..., 2, 2, 2])  
&gt;&gt;&gt; training_labels.shape
(1998,)
&gt;&gt;&gt; test_data = np.load(&quot;test_data.npy&quot;)
&gt;&gt;&gt; test_data.shape
(509, 19630)
&gt;&gt;&gt; test_labels = np.load(&quot;test_labels.npy&quot;)
&gt;&gt;&gt; test_labels.shape
(509,)
</code></pre><h2 id="使用RFE"><a href="#使用RFE" class="headerlink" title="使用RFE"></a>使用RFE</h2><hr>
<p>RFE是一个框架，我们需要使用能得到特征重要性的方法嵌入其中。本文使用逻辑斯谛回归（在李航的《统计学习方法》中有介绍）。</p>
<pre><code>&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression
&gt;&gt;&gt; from sklearn.feature_selection import RFE
&gt;&gt;&gt; estimator = LogisticRegression()  # 逻辑斯谛回归
&gt;&gt;&gt; selector = RFE(estimator, 3000, step=200)
&gt;&gt;&gt; selector = selector.fit(training_data, training_labels)
&gt;&gt;&gt; selector.support_   # True的特征就是最终得到的特征
array([False, False,  True, ..., False, False, False], dtype=bool)
&gt;&gt;&gt; selector.ranking_  # 值越小，越重要
array([26, 64,  1, ..., 26, 56, 26])
&gt;&gt;&gt; new_train_data = training_data[:, selector.support_]
&gt;&gt;&gt; new_test_data = test_data[:, selector.support_]
&gt;&gt;&gt; new_train_data.shape
(1998, 3000)
&gt;&gt;&gt; new_test_data.shape
(509, 3000)
</code></pre><p>其中，<code>selector = RFE(estimator, 3000, step=200)</code>意思是每次迭代删除200个特征，最终保留3000个特征。</p>
<p><code>selector</code>也可以使用内部训练好的逻辑斯谛回归模型预测样本类别：</p>
<pre><code>&gt;&gt;&gt; lr_predict_labels = selector.predict(test_data)
&gt;&gt;&gt; sum(lr_predict_labels == test_labels)   # 预测对了448个样本
448
</code></pre><p>而对原始特征集合使用逻辑斯谛回归：</p>
<pre><code>&gt;&gt;&gt; lr = LogisticRegression()
&gt;&gt;&gt; lr.fit(training_data, training_labels)
LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,  
          intercept_scaling=1, max_iter=100, multi_class=&#39;ovr&#39;,
          penalty=&#39;l2&#39;, random_state=None, solver=&#39;liblinear&#39;, tol=0.0001,
          verbose=0)
&gt;&gt;&gt; lr_predict_labels = lr.predict(test_data)
&gt;&gt;&gt; sum(lr_predict_labels == test_labels)   # 预测对了446个样本
446
</code></pre><h2 id="使用多项式贝叶斯处理新数据"><a href="#使用多项式贝叶斯处理新数据" class="headerlink" title="使用多项式贝叶斯处理新数据"></a>使用多项式贝叶斯处理新数据</h2><hr>
<p>对原始特征集合：</p>
<pre><code>&gt;&gt;&gt; from sklearn.naive_bayes import MultinomialNB
&gt;&gt;&gt; bayes = MultinomialNB() 
&gt;&gt;&gt; bayes.fit(training_data, training_labels)
MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes.predict(test_data)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels)  # 预测对了454个样本
454
</code></pre><p>对新的特征集合：</p>
<pre><code>&gt;&gt;&gt; bayes = MultinomialNB() 
&gt;&gt;&gt; bayes.fit(new_train_data, training_labels)
MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes.predict(new_test_data)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels)   # 预测对了456个样本
456
</code></pre><h2 id="使用伯努利贝叶斯处理新数据"><a href="#使用伯努利贝叶斯处理新数据" class="headerlink" title="使用伯努利贝叶斯处理新数据"></a>使用伯努利贝叶斯处理新数据</h2><hr>
<p>对原始特征集合：</p>
<pre><code>&gt;&gt;&gt; from sklearn.naive_bayes import BernoulliNB
&gt;&gt;&gt; bayes = BernoulliNB() 
&gt;&gt;&gt; bayes.fit(training_data, training_labels)
BernoulliNB(alpha=1.0, binarize=0.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes.predict(test_data)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels) 
387
</code></pre><p>对新的特征集合：</p>
<pre><code>&gt;&gt;&gt; bayes = BernoulliNB()
&gt;&gt;&gt; bayes.fit(new_train_data, training_labels)
BernoulliNB(alpha=1.0, binarize=0.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes.predict(new_test_data)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels)  # 效果提升了很多
433
</code></pre><h2 id="使用随机森林处理新数据"><a href="#使用随机森林处理新数据" class="headerlink" title="使用随机森林处理新数据"></a>使用随机森林处理新数据</h2><hr>
<p>对原始特征集合：</p>
<pre><code>&gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier
&gt;&gt;&gt; rf = RandomForestClassifier(n_estimators=100)
&gt;&gt;&gt; rf.fit(training_data, training_labels)
RandomForestClassifier(bootstrap=True, criterion=&#39;gini&#39;, max_depth=None,
            max_features=&#39;auto&#39;, max_leaf_nodes=None, min_samples_leaf=1,
            min_samples_split=2, min_weight_fraction_leaf=0.0,
            n_estimators=100, n_jobs=1, oob_score=False, random_state=None,
            verbose=0, warm_start=False)
&gt;&gt;&gt; rf_predict_labels = rf.predict(test_data)
&gt;&gt;&gt; sum(rf_predict_labels == test_labels)
422
</code></pre><p>对新的特征集合：</p>
<pre><code>&gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier
&gt;&gt;&gt; rf = RandomForestClassifier(n_estimators=100)
&gt;&gt;&gt; rf.fit(new_train_data, training_labels)
RandomForestClassifier(bootstrap=True, criterion=&#39;gini&#39;, max_depth=None,
            max_features=&#39;auto&#39;, max_leaf_nodes=None, min_samples_leaf=1,
            min_samples_split=2, min_weight_fraction_leaf=0.0,
            n_estimators=100, n_jobs=1, oob_score=False, random_state=None,
            verbose=0, warm_start=False)
&gt;&gt;&gt; rf_predict_labels = rf.predict(new_test_data)
&gt;&gt;&gt; sum(rf_predict_labels == test_labels)   # 变化不大
421
</code></pre><h2 id="如何实现RFE"><a href="#如何实现RFE" class="headerlink" title="如何实现RFE"></a>如何实现RFE</h2><hr>
<p>从上面可以看到，RFE消除特征后，很多分类器的效果并没有下降，甚至有所提升。那么RFE是如何实现的？</p>
<p>在scikit-learn源码中，打开文件sklearn/feature_selection/rfe.py，可以看到RFE的实现，下面摘取部分并给出注释：</p>
<pre><code>class RFE(BaseEstimator, MetaEstimatorMixin, SelectorMixin):

    def __init__(self, estimator, n_features_to_select=None, step=1,
                 estimator_params={}, verbose=0):
        self.estimator = estimator
        self.n_features_to_select = n_features_to_select
        self.step = step
        self.estimator_params = estimator_params
        self.verbose = verbose

    def fit(self, X, y):
        &quot;&quot;&quot;Fit the RFE model and then the underlying estimator on the selected
           features.

        Parameters
        ----------
        X : {array-like, sparse matrix}, shape = [n_samples, n_features]
            The training input samples.

        y : array-like, shape = [n_samples]
            The target values.
        &quot;&quot;&quot;
        X, y = check_X_y(X, y, &quot;csc&quot;)
        # Initialization
        n_features = X.shape[1]
        if self.n_features_to_select is None:
            n_features_to_select = n_features / 2
        else:
            n_features_to_select = self.n_features_to_select

        if 0.0 &lt; self.step &lt; 1.0:
            step = int(self.step * n_features)
        else:
            step = int(self.step)
        if step &lt;= 0:
            raise ValueError(&quot;Step must be &gt;0&quot;)

        support_ = np.ones(n_features, dtype=np.bool)   # true代表就用这个特征吧
        ranking_ = np.ones(n_features, dtype=np.int)    # 值越小越好
        # Elimination
        while np.sum(support_) &gt; n_features_to_select:
            # Remaining features
            &#39;&#39;&#39; the function of np.arange
            np.arange(3) -&gt; array([0, 1, 2]), 
            np.arange(3)[np.array([True,False,True])]-&gt; array([0, 2])
            &#39;&#39;&#39;
            features = np.arange(n_features)[support_]  # 每个值代表是第几个特征；若features中第3个值为9,代表新的第3个特征是原始的第9个特征

            # Rank the remaining features
            estimator = clone(self.estimator)
            estimator.set_params(**self.estimator_params)
            if self.verbose &gt; 0:
                print(&quot;Fitting estimator with %d features.&quot; % np.sum(support_))

            estimator.fit(X[:, features], y)  # 使用现在的特征集合来训练

            &#39;&#39;&#39; the function of np.argsort
            &gt;&gt;&gt; x = np.array([3, 1, 2])
            &gt;&gt;&gt; np.argsort(x)
            array([1, 2, 0])
            &#39;&#39;&#39;
            if estimator.coef_.ndim &gt; 1:
                ranks = np.argsort(safe_sqr(estimator.coef_).sum(axis=0))  # 将特征按找重要性从小到大来排序
            else:
                ranks = np.argsort(safe_sqr(estimator.coef_))

            # for sparse case ranks is matrix
            &#39;&#39;&#39;the function of np.ravel
            &gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])
            &gt;&gt;&gt; print np.ravel(x)
            [1 2 3 4 5 6]

            &#39;&#39;&#39;
            ranks = np.ravel(ranks)

            # Eliminate the worse features
            &#39;&#39;&#39;
            &gt;&gt;&gt; np.array([89,20,100])[np.array([2,0,1])]
            &gt;&gt;&gt; array([100,  89,  20])
            &gt;&gt;&gt; np.logical_not(3)
            False
            &gt;&gt;&gt; np.logical_not([True, False, 0, 1])
            array([False,  True,  True, False], dtype=bool)
            &#39;&#39;&#39;
            threshold = min(step, np.sum(support_) - n_features_to_select) # 该删除多少特征
            support_[features[ranks][:threshold]] = False 
            ranking_[np.logical_not(support_)] += 1

        # Set final attributes
        self.estimator_ = clone(self.estimator)
        self.estimator_.set_params(**self.estimator_params)
        self.estimator_.fit(X[:, support_], y)
        self.n_features_ = support_.sum()
        self.support_ = support_
        self.ranking_ = ranking_

        return self
</code></pre><p>实例变量estimator是一个评估器，比如逻辑斯谛回归分类器，评估器需要具有<code>coef_</code>属性。在训练一个评估器后，<code>coef_</code>相当于每个特征的权重。RFE在每一次迭代中得到新的<code>coef_</code>，并删掉权重低的特征，直到剩下的特征达到指定的数量。</p>
<p><del>这里有一个小问题：根据上面的实现的代码看，评估器需要具有<code>coef_</code>属性来指明每个特征的重要性。决策树也应该可以拿来用，但是决策树只有<code>feature_importances_</code>属性（参考<a href="http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier" target="_blank" rel="external">sklearn.tree.DecisionTreeClassifier</a>），而没有<code>coef_</code>属性。也就是，实际上决策树不能放在上面实现的RFE中。笔者认为原因是：决策树中越重要的特征离树的根越近，越不重要的特征离根越远。在删除决策树认为的不重要的部分特征后，新建的决策树中的特征按照重要性排序，依然和之前的决策树相同。也就是说，使用决策树，直接通过<code>feature_importances_</code>一次性地选取重要特征就行了，多次选取和一次选取的结果是一样的。</del></p>
<p>这里有一个小问题：根据上面的实现的代码看，评估器需要具有<code>coef_</code>属性来指明每个特征的重要性。决策树也应该可以拿来用，但是决策树只有<code>feature_importances_</code>属性（参考<a href="http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier" target="_blank" rel="external">sklearn.tree.DecisionTreeClassifier</a>），而没有<code>coef_</code>属性。也就是，实际上决策树不能放在上面实现的RFE中。既然这样，就自己实现个吧（<code>mytools.py</code>）：</p>
<pre><code># !/usr/bin/env python
# -*- encoding:utf-8 -*-

import numpy as np
from sklearn.feature_selection import RFE
from sklearn.utils import check_X_y, safe_sqr
from sklearn.base import clone

class RFE4Tree(RFE):

    def __init__(self, estimator, n_features_to_select=None, step=1,
                 estimator_params={}, verbose=0):
        self.estimator = estimator
        self.n_features_to_select = n_features_to_select
        self.step = step
        self.estimator_params = estimator_params
        self.verbose = verbose

    def fit(self, X, y):

        X, y = check_X_y(X, y, &quot;csc&quot;)
        # Initialization
        n_features = X.shape[1]
        if self.n_features_to_select is None:
            n_features_to_select = n_features / 2
        else:
            n_features_to_select = self.n_features_to_select

        if 0.0 &lt; self.step &lt; 1.0:
            step = int(self.step * n_features)
        else:
            step = int(self.step)
        if step &lt;= 0:
            raise ValueError(&quot;Step must be &gt;0&quot;)

        support_ = np.ones(n_features, dtype=np.bool)   # true代表就用这个特征吧
        ranking_ = np.ones(n_features, dtype=np.int)    # 值越小越好
        # Elimination
        while np.sum(support_) &gt; n_features_to_select:
            print &#39;&gt;once&#39;
            # Remaining features
            features = np.arange(n_features)[support_]  # 每个值代表是第几个特征；若features中第3个值为9,代表新的第3个特征是原始的第9个特征

            # Rank the remaining features
            estimator = clone(self.estimator)
            estimator.set_params(**self.estimator_params)
            if self.verbose &gt; 0:
                print(&quot;Fitting estimator with %d features.&quot; % np.sum(support_))

            estimator.fit(X[:, features], y)  # 使用现在的特征集合来训练

            ranks = np.argsort(estimator.feature_importances_)  # 利用决策树的feature_importances_属性

            # for sparse case ranks is matrix
            ranks = np.ravel(ranks)

            # Eliminate the worse features
            threshold = min(step, np.sum(support_) - n_features_to_select) # 该删除多少特征
            support_[features[ranks][:threshold]] = False 
            ranking_[np.logical_not(support_)] += 1

        # Set final attributes
        self.estimator_ = clone(self.estimator)
        self.estimator_.set_params(**self.estimator_params)
        self.estimator_.fit(X[:, support_], y)
        self.n_features_ = support_.sum()
        self.support_ = support_
        self.ranking_ = ranking_

        return self
</code></pre><h2 id="迭代1次与迭代多次选取同样数量特征的效果对比"><a href="#迭代1次与迭代多次选取同样数量特征的效果对比" class="headerlink" title="迭代1次与迭代多次选取同样数量特征的效果对比"></a>迭代1次与迭代多次选取同样数量特征的效果对比</h2><hr>
<p>使用scikit-learn的RFE：</p>
<pre><code>&gt;&gt;&gt; from sklearn.feature_selection import RFE
&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression
&gt;&gt;&gt; estimator = LogisticRegression()  # 逻辑斯谛回归
&gt;&gt;&gt; selector1 = RFE(estimator, 3000, step=200)  # 需要迭代多次
&gt;&gt;&gt; selector1 = selector1.fit(training_data, training_labels)
&gt;&gt;&gt; training_data.shape
(1998, 19630)
&gt;&gt;&gt; selector2 = RFE(estimator, 3000, step=19630-3000)  # 迭代一次就行了
&gt;&gt;&gt; selector2 = selector2.fit(training_data, training_labels)
&gt;&gt;&gt; sum(selector1.support_)
3000
&gt;&gt;&gt; sum(selector2.support_)
3000
&gt;&gt;&gt; sum(selector2.support_ == selector2.support_)
19630
&gt;&gt;&gt; sum(selector1.support_ == selector2.support_)  # 两种方法选取的特征是不一样的
19208

# 构建新数据
&gt;&gt;&gt; new_train_data2 = training_data[:, selector2.support_]
&gt;&gt;&gt; new_test_data2 = test_data[:, selector2.support_]

# 使用BernoulliNB
&gt;&gt;&gt; from sklearn.naive_bayes import BernoulliNB
&gt;&gt;&gt; bayes = BernoulliNB() 
&gt;&gt;&gt; bayes.fit(new_train_data2, training_labels)
BernoulliNB(alpha=1.0, binarize=0.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes.predict(new_test_data2)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels)  # 效果差不多
431

# 使用selector2内置的LogisticRegression
&gt;&gt;&gt; lr_predict_labels = selector2.predict(test_data)
&gt;&gt;&gt; sum(lr_predict_labels == test_labels)     # 效果差不多
449
</code></pre><p>那决策树呢？</p>
<pre><code>&gt;&gt;&gt; from sklearn.tree import DecisionTreeClassifier
&gt;&gt;&gt; import mytools
&gt;&gt;&gt; estimator = DecisionTreeClassifier(criterion=&#39;entropy&#39;)
&gt;&gt;&gt; selector1 = mytools.RFE4Tree(estimator, 3000, step=200)  # 迭代多次
&gt;&gt;&gt; selector2 = mytools.RFE4Tree(estimator, 3000, step=19630-3000)  # 迭代1次
&gt;&gt;&gt; selector1.fit(training_data, training_labels)
&gt;&gt;&gt; selector2.fit(training_data, training_labels)
&gt;&gt;&gt; sum(selector1.support_)
3000
&gt;&gt;&gt; sum(selector2.support_)
3000
&gt;&gt;&gt; sum(selector1.support_ == selector2.support_)  # 两种方法最终选择的特征并不相同
13954
&gt;&gt;&gt; tree_predict_labels = selector1.predict(test_data)  # 利用selector1选择的特征来分类
&gt;&gt;&gt; sum(tree_predict_labels == test_labels)  # selector1分类正确的数量
347
&gt;&gt;&gt; tree_predict_labels = selector2.predict(test_data) # 利用selector2选择的特征来分类
&gt;&gt;&gt; sum(tree_predict_labels == test_labels)  # selector2分类正确的数量
340
&gt;&gt;&gt; estimator.fit(training_data, training_labels)  # 用所有的特征来训练
&gt;&gt;&gt; tree_predict_labels = estimator.predict(test_data) # 预测
&gt;&gt;&gt; sum(tree_predict_labels == test_labels)        
341
</code></pre><p>（完）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.letiantian.me/2015-03-31-use-gbdt-to-select-features/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Letian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/content/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="樂天笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015-03-31-use-gbdt-to-select-features/" itemprop="url">使用GBDT选取特征</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-31T21:28:20+08:00">
                March 31st 2015
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2015-03-31</p>
<p>本文介绍如何使用scikit-learn的GBDT工具进行特征选取。</p>
<h2 id="为什麽选取特征"><a href="#为什麽选取特征" class="headerlink" title="为什麽选取特征"></a>为什麽选取特征</h2><hr>
<p>有些特征意义不大，删除后不影响效果，甚至可能提升效果。</p>
<h2 id="关于GBDT-Gradient-Boosting-Decision-Tree"><a href="#关于GBDT-Gradient-Boosting-Decision-Tree" class="headerlink" title="关于GBDT(Gradient Boosting Decision Tree)"></a>关于GBDT(Gradient Boosting Decision Tree)</h2><hr>
<p>可以参考：</p>
<p><a href="http://hi.baidu.com/hehehehello/item/81e69638f0e752352e20c48b" target="_blank" rel="external">GBDT（MART）概念简介</a>  </p>
<p><a href="http://hi.baidu.com/hehehehello/item/96cc42e45c16e7265a2d64ee" target="_blank" rel="external">GBDT（MART） 迭代决策树入门教程 | 简介</a>  </p>
<p><a href="http://www.cnblogs.com/leftnoteasy/archive/2011/03/07/random-forest-and-gbdt.html" target="_blank" rel="external">机器学习中的算法(1)-决策树模型组合之随机森林与GBDT</a></p>
<h2 id="如何在numpy数组中选取若干列或者行？"><a href="#如何在numpy数组中选取若干列或者行？" class="headerlink" title="如何在numpy数组中选取若干列或者行？"></a>如何在numpy数组中选取若干列或者行？</h2><hr>
<pre><code>&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; tmp_a = np.array([[1,1], [0.4, 4], [1., 0.9]])
&gt;&gt;&gt; tmp_a
array([[ 1. ,  1. ],
       [ 0.4,  4. ],
       [ 1. ,  0.9]])
&gt;&gt;&gt; tmp_a[[0,1],:]  # 选第0、1行
array([[ 1. ,  1. ],
       [ 0.4,  4. ]])
&gt;&gt;&gt; tmp_a[np.array([True, False, True]), :]  # 选第0、2行
array([[ 1. ,  1. ],
       [ 1. ,  0.9]])
&gt;&gt;&gt; tmp_a[:,[0]]    # 选第0列
array([[ 1. ],
       [ 0.4],
       [ 1. ]])
&gt;&gt;&gt; tmp_a[:, np.array([True, False])]  # 选第0列
array([[ 1. ],
       [ 0.4],
       [ 1. ]])
</code></pre><h2 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h2><hr>
<p>参考<a href="/2015-03-31-bayes-classifier-for-text/">基于贝叶斯的文本分类实战</a>。<strong>部分方法在原始数据集的预测效果也在<a href="/2015-03-31-bayes-classifier-for-text/">基于贝叶斯的文本分类实战</a>这篇文章里。</strong></p>
<h2 id="训练GBDT"><a href="#训练GBDT" class="headerlink" title="训练GBDT"></a>训练GBDT</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.ensemble import GradientBoostingClassifier
&gt;&gt;&gt; gbdt = GradientBoostingClassifier()
&gt;&gt;&gt; gbdt.fit(training_data, training_labels)  # 训练。喝杯咖啡吧
GradientBoostingClassifier(init=None, learning_rate=0.1, loss=&#39;deviance&#39;,
              max_depth=3, max_features=None, max_leaf_nodes=None,
              min_samples_leaf=1, min_samples_split=2,
              min_weight_fraction_leaf=0.0, n_estimators=100,
              random_state=None, subsample=1.0, verbose=0,
              warm_start=False)
&gt;&gt;&gt; gbdt.feature_importances_   # 据此选取重要的特征
array([  2.08644807e-06,   0.00000000e+00,   8.93452010e-04, ...,
         5.12199658e-04,   0.00000000e+00,   0.00000000e+00])
&gt;&gt;&gt; gbdt.feature_importances_.shape
(19630,)
</code></pre><p>看一下GBDT的分类效果：</p>
<pre><code>&gt;&gt;&gt; gbdt_predict_labels = gbdt.predict(test_data)
&gt;&gt;&gt; sum(gbdt_predict_labels==test_labels)  # 比 多项式贝叶斯 差许多
414
</code></pre><p>新的训练集和测试集（只保留了1636个特征，原先是19630个特征）：</p>
<pre><code>&gt;&gt;&gt; new_train_data = training_data[:, feature_importances&gt;0]
&gt;&gt;&gt; new_train_data.shape  # 只保留了1636个特征
(1998, 1636)
&gt;&gt;&gt; new_test_data = test_data[:, feature_importances&gt;0]
&gt;&gt;&gt; new_test_data.shape
(509, 1636)
</code></pre><h2 id="使用多项式贝叶斯处理新数据"><a href="#使用多项式贝叶斯处理新数据" class="headerlink" title="使用多项式贝叶斯处理新数据"></a>使用多项式贝叶斯处理新数据</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.naive_bayes import MultinomialNB
&gt;&gt;&gt; bayes = MultinomialNB() 
&gt;&gt;&gt; bayes.fit(new_train_data, training_labels)
MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes.predict(new_test_data)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels)   # 之前预测正确的样本数量是454
445
</code></pre><h2 id="使用伯努利贝叶斯处理新数据"><a href="#使用伯努利贝叶斯处理新数据" class="headerlink" title="使用伯努利贝叶斯处理新数据"></a>使用伯努利贝叶斯处理新数据</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.naive_bayes import BernoulliNB
&gt;&gt;&gt; bayes2 = BernoulliNB()
&gt;&gt;&gt; bayes2.fit(new_train_data, training_labels)
BernoulliNB(alpha=1.0, binarize=0.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes2.predict(new_test_data)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels)   # 之前预测正确的样本数量是387
422
</code></pre><h2 id="使用Logistic回归处理新数据"><a href="#使用Logistic回归处理新数据" class="headerlink" title="使用Logistic回归处理新数据"></a>使用Logistic回归处理新数据</h2><hr>
<p>对原始特征组成的数据集：</p>
<pre><code>&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression
&gt;&gt;&gt; lr1 = LogisticRegression()
&gt;&gt;&gt; lr1.fit(training_data, training_labels)
LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
          intercept_scaling=1, max_iter=100, multi_class=&#39;ovr&#39;,
          penalty=&#39;l2&#39;, random_state=None, solver=&#39;liblinear&#39;, tol=0.0001,
          verbose=0)
&gt;&gt;&gt; lr1_predict_labels = lr1.predict(test_data)
&gt;&gt;&gt; sum(lr1_predict_labels == test_labels)
446
</code></pre><p>对削减后的特征组成的数据集：</p>
<pre><code>&gt;&gt;&gt; lr2 = LogisticRegression()
&gt;&gt;&gt; lr2.fit(new_train_data, training_labels)
LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
          intercept_scaling=1, max_iter=100, multi_class=&#39;ovr&#39;,
          penalty=&#39;l2&#39;, random_state=None, solver=&#39;liblinear&#39;, tol=0.0001,
          verbose=0)
&gt;&gt;&gt; lr2_predict_labels = lr2.predict(new_test_data)
&gt;&gt;&gt; sum(lr2_predict_labels == test_labels)  # 正确率略微提升
449
</code></pre><p>（完）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.letiantian.me/2015-03-31-decision-tree-iris/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Letian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/content/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="樂天笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015-03-31-decision-tree-iris/" itemprop="url">使用决策树处理iris数据集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-31T18:33:31+08:00">
                March 31st 2015
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2015-03-31</p>
<p>关于决策树，可以参考李航《统计学习方法》第5章，以及其他资料。</p>
<p>本文介绍如何使用scikit-learn的决策树工具进行分类。</p>
<h2 id="构造数据集"><a href="#构造数据集" class="headerlink" title="构造数据集"></a>构造数据集</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.datasets import load_iris
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; iris = load_iris()
&gt;&gt;&gt; iris.data
array([[ 5.1,  3.5,  1.4,  0.2],
       [ 4.9,  3. ,  1.4,  0.2],
       ....
       [ 5.9,  3. ,  5.1,  1.8]])
&gt;&gt;&gt; iris.target
array([0, 0, 0, 0, 0, 0, ... , 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])
&gt;&gt;&gt; iris.data.shape  
(150, 4)                   # 150个样本，每个样本4个特征
&gt;&gt;&gt; iris.target.shape      # 每个样本的类别
(150,)
&gt;&gt;&gt; # 下面开始构造训练集/测试集，120/30
&gt;&gt;&gt; # 训练集
&gt;&gt;&gt; train_data = np.concatenate((iris.data[0:40, :], iris.data[50:90, :], iris.data[100:140, :]), axis = 0)
&gt;&gt;&gt; # 训练集样本类别
&gt;&gt;&gt; train_target = np.concatenate((iris.target[0:40], iris.target[50:90], iris.target[100:140]), axis = 0)
&gt;&gt;&gt; # 测试集
&gt;&gt;&gt; test_data = np.concatenate((iris.data[40:50, :], iris.data[90:100, :], iris.data[140:150, :]), axis = 0)
&gt;&gt;&gt; #测试集样本类别
&gt;&gt;&gt; test_target = np.concatenate((iris.target[40:50], iris.target[90:100], iris.target[140:150]), axis = 0)
</code></pre><h2 id="基于gini不纯度的决策树"><a href="#基于gini不纯度的决策树" class="headerlink" title="基于gini不纯度的决策树"></a>基于gini不纯度的决策树</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.tree import DecisionTreeClassifier
&gt;&gt;&gt; clf = DecisionTreeClassifier(criterion=&#39;gini&#39;)
&gt;&gt;&gt; clf.fit(train_data, train_target)  # 训练决策树
DecisionTreeClassifier(criterion=&#39;gini&#39;, max_depth=None, max_features=None,
            max_leaf_nodes=None, min_samples_leaf=1, min_samples_split=2,
            min_weight_fraction_leaf=0.0, random_state=None,
            splitter=&#39;best&#39;)
&gt;&gt;&gt; predict_target = clf.predict(test_data)  # 预测
&gt;&gt;&gt; predict_target
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
       2, 2, 2, 2, 2, 2, 2])
&gt;&gt;&gt; sum(predict_target == test_target)  # 预测成功的数量
30
</code></pre><p>下面可视化训练好的这颗决策树：</p>
<pre><code>&gt;&gt;&gt; from sklearn.externals.six import StringIO
&gt;&gt;&gt; from sklearn.tree import export_graphviz
&gt;&gt;&gt; with open(&quot;iris.dot&quot;, &#39;w&#39;) as f:
...     f = export_graphviz(clf, out_file=f)
</code></pre><p>iris.dot内容如下：</p>
<pre><code>digraph Tree {
0 [label=&quot;X[2] &lt;= 2.6000\ngini = 0.666666666667\nsamples = 120&quot;, shape=&quot;box&quot;] ;
1 [label=&quot;gini = 0.0000\nsamples = 40\nvalue = [ 40.   0.   0.]&quot;, shape=&quot;box&quot;] ;
0 -&gt; 1 ;
2 [label=&quot;X[3] &lt;= 1.7500\ngini = 0.5\nsamples = 80&quot;, shape=&quot;box&quot;] ;
0 -&gt; 2 ;
3 [label=&quot;X[2] &lt;= 4.9500\ngini = 0.201446280992\nsamples = 44&quot;, shape=&quot;box&quot;] ;
2 -&gt; 3 ;
4 [label=&quot;X[3] &lt;= 1.6500\ngini = 0.0512465373961\nsamples = 38&quot;, shape=&quot;box&quot;] ;
3 -&gt; 4 ;
5 [label=&quot;gini = 0.0000\nsamples = 37\nvalue = [  0.  37.   0.]&quot;, shape=&quot;box&quot;] ;
4 -&gt; 5 ;
6 [label=&quot;gini = 0.0000\nsamples = 1\nvalue = [ 0.  0.  1.]&quot;, shape=&quot;box&quot;] ;
4 -&gt; 6 ;
7 [label=&quot;X[3] &lt;= 1.5500\ngini = 0.444444444444\nsamples = 6&quot;, shape=&quot;box&quot;] ;
3 -&gt; 7 ;
8 [label=&quot;gini = 0.0000\nsamples = 3\nvalue = [ 0.  0.  3.]&quot;, shape=&quot;box&quot;] ;
7 -&gt; 8 ;
9 [label=&quot;X[0] &lt;= 6.9500\ngini = 0.444444444444\nsamples = 3&quot;, shape=&quot;box&quot;] ;
7 -&gt; 9 ;
10 [label=&quot;gini = 0.0000\nsamples = 2\nvalue = [ 0.  2.  0.]&quot;, shape=&quot;box&quot;] ;
9 -&gt; 10 ;
11 [label=&quot;gini = 0.0000\nsamples = 1\nvalue = [ 0.  0.  1.]&quot;, shape=&quot;box&quot;] ;
9 -&gt; 11 ;
12 [label=&quot;X[2] &lt;= 4.8500\ngini = 0.054012345679\nsamples = 36&quot;, shape=&quot;box&quot;] ;
2 -&gt; 12 ;
13 [label=&quot;X[0] &lt;= 5.9500\ngini = 0.444444444444\nsamples = 3&quot;, shape=&quot;box&quot;] ;
12 -&gt; 13 ;
14 [label=&quot;gini = 0.0000\nsamples = 1\nvalue = [ 0.  1.  0.]&quot;, shape=&quot;box&quot;] ;
13 -&gt; 14 ;
15 [label=&quot;gini = 0.0000\nsamples = 2\nvalue = [ 0.  0.  2.]&quot;, shape=&quot;box&quot;] ;
13 -&gt; 15 ;
16 [label=&quot;gini = 0.0000\nsamples = 33\nvalue = [  0.   0.  33.]&quot;, shape=&quot;box&quot;] ;
12 -&gt; 16 ;
}
</code></pre><p>然后，进入shell：</p>
<pre><code>$ sudo apt-get install graphviz 
$ dot -Tpng iris.dot -o tree.png  # 生成png图片
$ dot -Tpdf iris.dot -o tree.pdf  # 生成pdf
</code></pre><p>上图：</p>
<p><img src="/content/images/2015/03/2015-03-31-tree1.png" alt=""></p>
<p>很明显，叶子节点具有value属性。iris有3个分类，故value有三个值，若第1个值比较大，认为是第1个分类；若第2个值比较大，认为是第2个分类；…。</p>
<h2 id="基于信息增益的决策树"><a href="#基于信息增益的决策树" class="headerlink" title="基于信息增益的决策树"></a>基于信息增益的决策树</h2><hr>
<p>Information Gain，信息增益。</p>
<pre><code>&gt;&gt;&gt; clf = DecisionTreeClassifier(criterion=&#39;entropy&#39;)
&gt;&gt;&gt; clf2 = DecisionTreeClassifier(criterion=&#39;entropy&#39;)
&gt;&gt;&gt; clf2.fit(train_data, train_target)
DecisionTreeClassifier(criterion=&#39;entropy&#39;, max_depth=None, max_features=None,
            max_leaf_nodes=None, min_samples_leaf=1, min_samples_split=2,
            min_weight_fraction_leaf=0.0, random_state=None,
            splitter=&#39;best&#39;)
&gt;&gt;&gt; predict_target = clf2.predict(test_data)
&gt;&gt;&gt; sum(predict_target == test_target)
30
&gt;&gt;&gt; with open(&quot;iris2.dot&quot;, &#39;w&#39;) as out:
...     out = export_graphviz(clf2, out_file=out)
</code></pre><p>上图：</p>
<p><img src="/content/images/2015/03/2015-03-31-tree2.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="http://scikit-learn.org/stable/modules/tree.html#tree" target="_blank" rel="external">http://scikit-learn.org/stable/modules/tree.html#tree</a>  </p>
<p><a href="http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn-tree-decisiontreeclassifier" target="_blank" rel="external">http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html</a></p>
<p><a href="http://scikit-learn.org/stable/modules/generated/sklearn.tree.export_graphviz.html" target="_blank" rel="external">http://scikit-learn.org/stable/modules/generated/sklearn.tree.export_graphviz.html</a>  </p>
<p><a href="http://stackoverflow.com/questions/10570042/visualizing-a-decision-tree-example-from-scikit-learn" target="_blank" rel="external">Visualizing a decision tree ( example from scikit-learn)</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.letiantian.me/2015-03-31-bayes-classifier-for-text/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Letian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/content/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="樂天笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015-03-31-bayes-classifier-for-text/" itemprop="url">基于贝叶斯的文本分类实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-31T15:37:58+08:00">
                March 31st 2015
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2015-03-31</p>
<p>本文介绍如何使用scikit-learn工具包下的贝叶斯工具进行文本分类。</p>
<h2 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h2><hr>
<p>数据集是有8个分类的文本数据集，使用了结巴分词对每个文本分词，每个单词当作特征，再利用二元词串构造更多特征，然后去掉停用词，去掉出现次数太多和太少的特征，得到了19630个特征。取1998个样本用于训练，509个用于测试。基于<a href="/2014-12-12-bag-of-words-model-and-document-term-matrix/">词袋模型</a>的思路将每个文本转换为向量，训练集和测试集分别转换为矩阵，并用python numpy模块将其保存为npy格式。这个预处理后的数据集保存在了<a href="https://github.com/letiantian/dataset" target="_blank" rel="external">https://github.com/letiantian/dataset-for-classifying</a>。</p>
<h2 id="关于贝叶斯"><a href="#关于贝叶斯" class="headerlink" title="关于贝叶斯"></a>关于贝叶斯</h2><hr>
<p><a href="/2014-05-20-naive-bayes/">使用朴素贝叶斯分类器划分邮件</a></p>
<p><a href="/2014-10-12-three-models-of-naive-nayes/">朴素贝叶斯的三个常用模型：高斯、多项式、伯努利</a></p>
<h2 id="导入数据集"><a href="#导入数据集" class="headerlink" title="导入数据集"></a>导入数据集</h2><hr>
<p>在<a href="https://github.com/letiantian/dataset" target="_blank" rel="external">https://github.com/letiantian/dataset</a>下载text-classification.7z，解压后导入数据：</p>
<pre><code>$ ls
test_data.npy  test_labels.npy  training_data.npy  training_labels.npy
$ ipython
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; training_data = np.load(&quot;training_data.npy&quot;)
&gt;&gt;&gt; training_data.shape
(1998, 19630)
&gt;&gt;&gt; training_labels = np.load(&quot;training_labels.npy&quot;)
&gt;&gt;&gt; training_labels
array([6, 6, 6, ..., 2, 2, 2])
&gt;&gt;&gt; training_labels.shape
(1998,)
&gt;&gt;&gt; test_data = np.load(&quot;test_data.npy&quot;)
&gt;&gt;&gt; test_data.shape
(509, 19630)
&gt;&gt;&gt; test_labels = np.load(&quot;test_labels.npy&quot;)
&gt;&gt;&gt; test_labels.shape
(509,)
</code></pre><h2 id="使用多项式贝叶斯"><a href="#使用多项式贝叶斯" class="headerlink" title="使用多项式贝叶斯"></a>使用多项式贝叶斯</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.naive_bayes import MultinomialNB
&gt;&gt;&gt; clf =MultinomialNB()
&gt;&gt;&gt; clf.fit(training_data, training_labels)  # 训练模型
MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; predict_labels = clf.predict(test_data)  # 预测训练集
&gt;&gt;&gt; sum(predict_labels == test_labels)       # 预测对了几个？
454
&gt;&gt;&gt; len(predict_labels)                      # 训练样本个数
509
&gt;&gt;&gt; 454./509                                 # 正确率
0.8919449901768173                           # 效果不错
&gt;&gt;&gt; from sklearn.metrics import confusion_matrix 
&gt;&gt;&gt; confusion_matrix(test_labels, predict_labels)  # 混淆矩阵
array([[ 39,   0,   0,   1,   0,   1,   0,   0], 
       [  0,  32,   1,   0,   0,   4,   0,   1],
       [  0,   0,  50,   0,   0,   8,   0,   4],
       [  0,   0,   1,  44,   0,  10,   0,   0],
       [  1,   0,   0,   0,  66,   0,   0,   1],
       [  2,   2,   1,   6,   1, 144,   1,   1],
       [  0,   0,   0,   0,   0,   2,  25,   0],
       [  0,   0,   1,   2,   2,   1,   0,  54]])
</code></pre><h2 id="使用伯努利贝叶斯"><a href="#使用伯努利贝叶斯" class="headerlink" title="使用伯努利贝叶斯"></a>使用伯努利贝叶斯</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.naive_bayes import BernoulliNB
&gt;&gt;&gt; clf2 = BernoulliNB()
&gt;&gt;&gt; clf2.fit(training_data, training_labels)  # 训练模型
BernoulliNB(alpha=1.0, binarize=0.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; predict_labels = clf2.predict(test_data)  # 预测训练集
&gt;&gt;&gt; sum(predict_labels == test_labels)        # 预测对了几个？
387
&gt;&gt;&gt; 387./509                                  # 正确率
0.7603143418467584
</code></pre><p>这个和下面的效果是一样的：</p>
<pre><code>&gt;&gt;&gt; clf2 = BernoulliNB()
&gt;&gt;&gt; clf2.fit(training_data&gt;0, training_labels)
BernoulliNB(alpha=1.0, binarize=0.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; predict_labels = clf2.predict(test_data&gt;0)
&gt;&gt;&gt; sum(predict_labels == test_labels)
387
</code></pre><h2 id="使用高斯贝叶斯"><a href="#使用高斯贝叶斯" class="headerlink" title="使用高斯贝叶斯"></a>使用高斯贝叶斯</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.naive_bayes import GaussianNB
&gt;&gt;&gt; clf3 = GaussianNB()
&gt;&gt;&gt; clf3.fit(training_data, training_labels)   # 训练模型
GaussianNB()
&gt;&gt;&gt; predict_labels = clf3.predict(test_data)   # 预测训练集
&gt;&gt;&gt; sum(predict_labels == test_labels)         # 预测对了几个？
375
&gt;&gt;&gt; 375./509                                   # 正确率
0.7367387033398821
</code></pre><p>（完）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.letiantian.me/2015-03-09-apache-dbutils/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Letian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/content/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="樂天笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015-03-09-apache-dbutils/" itemprop="url">DBUtils简明教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-09T22:11:23+08:00">
                March 9th 2015
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2015-03-09</p>
<p>本文以Insert和Select操作为例子，介绍apache DBUtils的使用方法和实现机制。</p>
<blockquote>
<p>The Commons DbUtils library is a small set of classes designed to make working with JDBC easier</p>
</blockquote>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><hr>
<p>建立表格：</p>
<pre><code>CREATE  TABLE `test`.`user` (
  `id` INT NOT NULL AUTO_INCREMENT ,
  `name` VARCHAR(45) NOT NULL ,
  `age` INT NOT NULL ,
  PRIMARY KEY (`id`) ,
  UNIQUE INDEX `name_UNIQUE` (`name` ASC) )
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8
COLLATE = utf8_general_ci;
</code></pre><p>在<code>http://dev.mysql.com/downloads/connector/j</code>下载<code>mysql-connector-java-5.1.34.tar.gz</code>。</p>
<p>在<code>http://commons.apache.org/proper/commons-dbutils/download_dbutils.cgi</code>下载<code>commons-dbutils-1.6-bin.tar.gz</code>。</p>
<p>首先创建DBConf.java，内容如下：</p>
<pre><code>package hellodbutils;

public class DBConf {
   static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;  
   static final String DB_URL = &quot;jdbc:mysql://localhost/test&quot;;

    static final String USER = &quot;username&quot;;
    static final String PASS = &quot;password&quot;;
}
</code></pre><h2 id="先看一个JDBC的示例"><a href="#先看一个JDBC的示例" class="headerlink" title="先看一个JDBC的示例"></a>先看一个JDBC的示例</h2><hr>
<pre><code>// 类hellodbutils.JDBCInsert
package hellodbutils;
import java.sql.*;

public class JDBCInsert {
    public static void main(String args[]) {
        Connection conn = null;
        PreparedStatement pstmt = null;
        try {
            Class.forName(DBConf.JDBC_DRIVER);
            conn = DriverManager.getConnection(DBConf.DB_URL, DBConf.USER, DBConf.PASS);

            String sql = &quot;INSERT INTO user(name, age) VALUES(?,?)&quot;;
            pstmt = conn.prepareStatement(sql);
            // insert a user
            pstmt.setString(1, &quot;letian&quot;);
            pstmt.setInt(2, 18);
            pstmt.execute();
            // insert another user
            pstmt.setString(1, &quot;letiantian&quot;);
            pstmt.setInt(2, 19);
            pstmt.execute();

            //select
            sql = &quot;SELECT * FROM user&quot;;
            pstmt = conn.prepareStatement(sql);
            ResultSet rs = pstmt.executeQuery();
            while(rs.next()) {
                System.out.println(rs.getInt(&quot;id&quot;));
                System.out.println(rs.getString(&quot;name&quot;));
                System.out.println(rs.getInt(&quot;age&quot;));
                System.out.println(&quot;------&quot;);
            }

        } catch (Exception ex) {
            ex.printStackTrace();
        }


    }
}
</code></pre><p>运行结果如下：</p>
<pre><code>1
letian
18
------
2
letiantian
19
------
</code></pre><p>MySQL命令行客户端查询结果：</p>
<pre><code>mysql&gt; select * from user;
+----+------------+-----+
| id | name       | age |
+----+------------+-----+
|  1 | letian     |  18 |
|  2 | letiantian |  19 |
+----+------------+-----+
</code></pre><h2 id="使用DBUtils插入数据"><a href="#使用DBUtils插入数据" class="headerlink" title="使用DBUtils插入数据"></a>使用DBUtils插入数据</h2><hr>
<p>首先清空user表中的数据：</p>
<pre><code>mysql&gt; delete from user;
mysql&gt; ALTER TABLE user AUTO_INCREMENT = 1;
</code></pre><p>编写代码：</p>
<pre><code>// 类hellodbutils.DBUtilsInsert
package hellodbutils;

import java.sql.*;
import org.apache.commons.dbutils.*;
import org.apache.commons.dbutils.handlers.ArrayHandler;

public class DBUtilsInsert {
    public static void main(String args[]) {
        Connection conn;
        QueryRunner queryRunner = new QueryRunner();
        ArrayHandler arrayHandler = new ArrayHandler();
        try {
            Class.forName(DBConf.JDBC_DRIVER);
            conn = DriverManager.getConnection(DBConf.DB_URL, DBConf.USER, DBConf.PASS);

            String sql = &quot;INSERT INTO user(name, age) VALUES(?,?)&quot;;
            Object[] objectArr= queryRunner.insert(conn, sql, arrayHandler, &quot;樂天&quot;, 18);
            System.out.println(&quot;数组长度：&quot; + objectArr.length + &quot;；第0个元素的值：&quot; +objectArr[0]);
            objectArr = queryRunner.insert(conn, sql, arrayHandler, &quot;樂天天&quot;, 19);
            System.out.println(&quot;数组长度：&quot; + objectArr.length + &quot;；第0个元素的值：&quot; +objectArr[0]);

        } catch (Exception ex) {
            ex.printStackTrace();
        }

    }
}
</code></pre><p>运行结果：</p>
<pre><code>数组长度：1；第0个元素的值：1
数组长度：1；第0个元素的值：2
</code></pre><p>MySQL命令行客户端查询结果：</p>
<pre><code>mysql&gt; select * from user;
+----+-----------+-----+
| id | name      | age |
+----+-----------+-----+
|  1 | 樂天      |  18 |
|  2 | 樂天天    |  19 |
+----+-----------+-----+
2 rows in set (0.33 sec)
</code></pre><p><strong>源码分析：</strong></p>
<p>上面的句子调用了类<code>org.apache.commons.dbutils.QueryRunner</code>的这个方法：</p>
<pre><code>// 类`org.apache.commons.dbutils.QueryRunner`下方法insert(...)
public &lt;T&gt; T insert(Connection conn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params) throws SQLException {
    return insert(conn, false, sql, rsh, params);
}
</code></pre><p>最终调用的是下面的重载方法：</p>
<pre><code>// 类`org.apache.commons.dbutils.QueryRunner`下方法insert(...)
private &lt;T&gt; T insert(Connection conn, boolean closeConn, String sql, ResultSetHandler&lt;T&gt; rsh, Object... params)
        throws SQLException {

    // .... 删去了若干代码

    PreparedStatement stmt = null;
    T generatedKeys = null;

    try {
        stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
        this.fillStatement(stmt, params);
        stmt.executeUpdate();
        ResultSet resultSet = stmt.getGeneratedKeys(); 
        generatedKeys = rsh.handle(resultSet);
    } catch (SQLException e) {
        this.rethrow(e, sql, params);
    } finally {
        close(stmt);
        if (closeConn) {
            close(conn);
        }
    }

    return generatedKeys;
}
</code></pre><p><code>this.fillStatement</code>方法来自类<code>org.apache.commons.dbutils.QueryRunner</code>的父类<code>org.apache.commons.dbutils.AbstractQueryRunner</code>，<code>fillStatement</code>的主要内容是：</p>
<pre><code>// 类`org.apache.commons.dbutils.AbstractQueryRunner`下方法fillStatement(...)
public void fillStatement(PreparedStatement stmt, Object... params)
        throws SQLException {

    // .... 删去了若干代码

    for (int i = 0; i &lt; params.length; i++) {
        if (params[i] != null) {
            stmt.setObject(i + 1, params[i]);
        } else {
            // .... 删去了若干代码
        }
    }
}
</code></pre><p>javadoc中如下介绍<code>stmt.getGeneratedKeys()</code>：</p>
<pre><code>ResultSet getGeneratedKeys()
                           throws SQLException
Retrieves any auto-generated keys created as a result of executing this Statement object. If this Statement object did not generate any keys, an empty ResultSet object is returned.
Note:If the columns which represent the auto-generated keys were not specified, the JDBC driver implementation will determine the columns which best represent the auto-generated keys.
</code></pre><p>类<code>org.apache.commons.dbutils.QueryRunner</code>的<code>insert(...)</code>函数有一参数是<code>ResultSetHandler&lt;T&gt; rsh</code>，ResultSetHandler用来处理sql查询后得到的结果。在类<code>hellodbutils.DBUtilsInsert</code>中，我们使用的ResultSetHandler是类<code>org.apache.commons.dbutils.handlers.ArrayHandler</code>：</p>
<pre><code>// 类`org.apache.commons.dbutils.handlers.ArrayHandler`
public class ArrayHandler implements ResultSetHandler&lt;Object[]&gt; {
    // .... 删去了若干代码
    @Override
    public Object[] handle(ResultSet rs) throws SQLException {
        return rs.next() ? this.convert.toArray(rs) : EMPTY_ARRAY;
    }
}
</code></pre><p><code>this.convert</code>默认值是<code>new BasicRowProcessor()</code>。类<code>BasicRowProcessor</code>在包<code>org.apache.commons.dbutils</code>中，其中<code>toArray(...)</code>函数详细如下：</p>
<pre><code>// 类org.apache.commons.dbutils.BasicRowProcessor下的toArray(...)函数
@Override
public Object[] toArray(ResultSet rs) throws SQLException {
    ResultSetMetaData meta = rs.getMetaData();
    int cols = meta.getColumnCount();
    Object[] result = new Object[cols];

    for (int i = 0; i &lt; cols; i++) {
        result[i] = rs.getObject(i + 1);
    }

    return result;
}
</code></pre><p>好了，到了这里，类<code>hellodbutils.DBUtilsInsert</code>使用DBUtils插入数据的思路也就知道了。</p>
<h2 id="使用DBUtils获取一条数据"><a href="#使用DBUtils获取一条数据" class="headerlink" title="使用DBUtils获取一条数据"></a>使用DBUtils获取一条数据</h2><hr>
<p>编写代码：</p>
<pre><code>// 类hellodbutils.DBUtilsSelect
package hellodbutils;

import java.util.Map;
import java.sql.*;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.*;

public class DBUtilsSelect {
    public static void main(String args[]) {
        Connection conn;
        QueryRunner queryRunner = new QueryRunner();
        try {
            Class.forName(DBConf.JDBC_DRIVER);
            conn = DriverManager.getConnection(DBConf.DB_URL, DBConf.USER, DBConf.PASS);

            String sql = &quot;SELECT id, name, age FROM user WHERE id=?&quot;;
            Map&lt;String, Object&gt; resultMap = queryRunner.query(conn, sql, new MapHandler(), 1);
            System.out.println(resultMap);

        } catch (Exception ex) {
            ex.printStackTrace();
        }

    }
}
</code></pre><p>运行结果：</p>
<pre><code>{id=1, name=樂天, age=18}
</code></pre><p><strong>源码分析：</strong></p>
<p>我们看一下<code>org.apache.commons.dbutils.handlers.MapHandler</code>做了什么：</p>
<pre><code>// 类org.apache.commons.dbutils.handlers.MapHandler
public class MapHandler implements ResultSetHandler&lt;Map&lt;String, Object&gt;&gt; {

    // .... 删去了若干代码

    @Override
    public Map&lt;String, Object&gt; handle(ResultSet rs) throws SQLException {
        return rs.next() ? this.convert.toMap(rs) : null;
    }

}
</code></pre><p>这里，<code>this.convert</code>默认值也是<code>new BasicRowProcessor()</code>。看一下<code>toMap(...)</code>函数：</p>
<pre><code>// 类org.apache.commons.dbutils.BasicRowProcessor下的toMap(...)函数
@Override
public Map&lt;String, Object&gt; toMap(ResultSet rs) throws SQLException {
    Map&lt;String, Object&gt; result = new CaseInsensitiveHashMap();
    ResultSetMetaData rsmd = rs.getMetaData();
    int cols = rsmd.getColumnCount();

    for (int i = 1; i &lt;= cols; i++) {
        String columnName = rsmd.getColumnLabel(i);
        if (null == columnName || 0 == columnName.length()) {
          columnName = rsmd.getColumnName(i);
        }
        result.put(columnName, rs.getObject(i));
    }

    return result;
}
</code></pre><p><code>CaseInsensitiveHashMap</code>定义在类<code>BasicRowProcessor</code>内部：</p>
<pre><code>private static class CaseInsensitiveHashMap extends LinkedHashMap&lt;String, Object&gt; {

    private final Map&lt;String, String&gt; lowerCaseMap = new HashMap&lt;String, String&gt;();

    private static final long serialVersionUID = -2848100435296897392L;

    @Override
    public boolean containsKey(Object key) {
        Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ENGLISH));
        return super.containsKey(realKey);
    }

    @Override
    public Object get(Object key) {
        Object realKey = lowerCaseMap.get(key.toString().toLowerCase(Locale.ENGLISH));
        return super.get(realKey);
    }

    @Override
    public Object put(String key, Object value) {
        Object oldKey = lowerCaseMap.put(key.toLowerCase(Locale.ENGLISH), key);
        Object oldValue = super.remove(oldKey);
        super.put(key, value);
        return oldValue;
    }

    @Override
    public void putAll(Map&lt;? extends String, ?&gt; m) {
        for (Map.Entry&lt;? extends String, ?&gt; entry : m.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            this.put(key, value);
        }
    }


    @Override
    public Object remove(Object key) {
        Object realKey = lowerCaseMap.remove(key.toString().toLowerCase(Locale.ENGLISH));
        return super.remove(realKey);
    }
}
</code></pre><h2 id="使用DBUtils获取多条数据"><a href="#使用DBUtils获取多条数据" class="headerlink" title="使用DBUtils获取多条数据"></a>使用DBUtils获取多条数据</h2><hr>
<p>编写代码：</p>
<pre><code>// 类hellodbutils.DBUtilsSelect2
package hellodbutils;

import java.util.Map;
import java.util.List;
import java.sql.*;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.*;

public class DBUtilsSelect2 {
    public static void main(String args[]) {
        Connection conn;
        QueryRunner queryRunner = new QueryRunner();
        try {
            Class.forName(DBConf.JDBC_DRIVER);
            conn = DriverManager.getConnection(DBConf.DB_URL, DBConf.USER, DBConf.PASS);

            String sql = &quot;SELECT id, name, age FROM user&quot;;
            List&lt;Map&lt;String, Object&gt;&gt; result = queryRunner.query(conn, sql, new MapListHandler());
            System.out.println(result);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }   
}
</code></pre><p>运行结果：</p>
<pre><code>[{id=1, name=樂天, age=18}, {id=2, name=樂天天, age=19}]
</code></pre><p><strong>源码分析：</strong></p>
<p>先看一下类<code>org.apache.commons.dbutils.handlers.MapListHandler</code>：</p>
<pre><code>// 类 org.apache.commons.dbutils.handlers.MapListHandler
public class MapListHandler extends AbstractListHandler&lt;Map&lt;String, Object&gt;&gt; {

    // .... 删去了若干代码

    public MapListHandler() {
        this(ArrayHandler.ROW_PROCESSOR);
    }

    // .... 删去了若干代码
    @Override
    protected Map&lt;String, Object&gt; handleRow(ResultSet rs) throws SQLException {
        return this.convert.toMap(rs);
    }

}
</code></pre><p><code>handle(...)</code>方法在MapListHandler的父类<code>org.apache.commons.dbutils.handlers.AbstractListHandler</code>中：</p>
<pre><code>public abstract class AbstractListHandler&lt;T&gt; implements ResultSetHandler&lt;List&lt;T&gt;&gt; {
    @Override
    public List&lt;T&gt; handle(ResultSet rs) throws SQLException {
        List&lt;T&gt; rows = new ArrayList&lt;T&gt;();
        while (rs.next()) {
            rows.add(this.handleRow(rs));
        }
        return rows;
    }

    protected abstract T handleRow(ResultSet rs) throws SQLException;
}
</code></pre><p>使用<code>handleRow(...)</code>处理ResultSet rs中当前指向的数据，并转换为Map；而<code>handle()</code>方法将获得ResultSet rs所能找到的所有数据对应的Map构成的ArrayList。</p>
<p>（完）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.letiantian.me/2015-03-02-character-encoding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Letian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/content/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="樂天笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015-03-02-character-encoding/" itemprop="url">字符编码简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-02T19:34:38+08:00">
                March 2nd 2015
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2015-03-02</p>
<h2 id="字符集、代码点、代码单元"><a href="#字符集、代码点、代码单元" class="headerlink" title="字符集、代码点、代码单元"></a>字符集、代码点、代码单元</h2><hr>
<p>将所有的字符放在一起就是<code>字符集</code>。例如将所有的英文字母放在一起可以组成一个字符集，将所有的英文字母和一些标点符号放在一起可以组成一个字符集，将所有的汉字放在一起可以组成一个字符集，将所有的英文字母以及汉字放在一起也可以组成一个字符集。</p>
<p>对一个字符集中的所有字符进行编号（整数的序号），每个字符的编号在这个字符集里都是独一无二的。例如，由所有英文字母组成的字符集中有52个字符（小写字母26个，大写字母26个），可以将这些字符依次编号为0、1、2、…、51。一个字符的编号称为该字符的<code>代码点（Code Point）</code>。这种编码后的字符集叫做<code>编码字符集</code>。常见的编码字符集有ASCII、Unicode、GBK等。值得注意的是，有些编码字符集中的代码点不一定被使用了，例如Unicode。</p>
<p><code>代码单元（Code Unit）</code>是编码时使用的最小单元。这个和如何存储一个字符的编码有关。以为下文将提到的UTF-8为例，其代码单元是8bit，由于UTF-8是变长编码，这意味着在UTF-8有些字符用8bit来存储和表示，有些是8×2bit存储和表示，还有8×3bit等等。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><hr>
<p>Unicode的目标是包含世界上所有语言的文字。Unicode 6.0中已经包含了超过109 000个字符。要了解Unicode，先给出下面的等式：</p>
<pre><code>2^16 = 65_536
17 × 65536 = 1_114_112
0x10FFFF = 1_114_111
</code></pre><p>Unicode个定义了1 114 112个代码点，值的范围是0～0x10FFFF。这些代码点当前只被使用了一小部分。</p>
<p>Unicode被分为17个区域，一个区域叫一个平面（plane），每个平面有65 536个字符。<code>0x10FFFF</code>的最高两位为<code>0x10</code>，由0到<code>0x10</code>，刚好17个平面，每个平面是16进制表示的最低4位是从<code>0x0000</code>到<code>0xFFFF</code>。</p>
<p>第一个平面的范围是<code>0x000000</code>到<code>0x00FFFF</code>，叫做基本多语言平面（BMP），包含了最常用的字符和符号。第2、3、4平面作补充了一些字符。第5到14个平面尚未分配。第15个平面主要包含非非图形化字符。第16、17个平面叫做私有使用区域平面（PUA），供第三方自定义。</p>
<h2 id="如何表示和存储Unicode"><a href="#如何表示和存储Unicode" class="headerlink" title="如何表示和存储Unicode"></a>如何表示和存储Unicode</h2><hr>
<p>一个比较简单的思路是，既然Unicode代码点的值的范围是0～0x10FFF，那么可以直接用3个字节来表示，即使用定长的3个字节来表示所有Unicode代码点对应的字符。但是这存在一个空间使用的问题，例如对于使用英语的人而言，ASCII基本可以满足他的使用。如果使用ASCII，只需要1个字节来存储和表示字符，如果使用Unicode的3个字节来存储，显然是浪费空间的。那么让我们来看看现实中的编码方案。</p>
<h3 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h3><p>UTF-8使用8bit作为一个代码单元，是变长编码。先看一下<a href="http://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="external">http://en.wikipedia.org/wiki/UTF-8</a>给出的表格。</p>
<p><img src="/content/images/2015/03/2015-03-02-utf-8.png" alt=""></p>
<p>可以看出，Unicode中代码点可以用7bit表示的字符在UTF-8中均用1字节表示，代码点可以分别用8到11（8、9、10、11）bit表示的字符在UTF-8中均用2字节表示，依次类推。总的来说UTF-8与Unicode兼容，但是可以表示比目前的Unicode更多的字符。</p>
<p>下面举例说明UTF-8与Unicode的映射方式。</p>
<p>汉字“你”的Unicode代码点是<code>Ox4F60</code>，其二进制形式（下划线用于优化阅读体验，无特殊意义）：</p>
<pre><code>0100_1111 0110_0000
</code></pre><p>至少需要15bit才能表示“你”，所以其对应的UTF-8编码需要3字节：</p>
<pre><code>1110_0100 10_111101 10_100000
</code></pre><p>即<code>E4BDA0</code>。把每个字节<code>_</code>后的bit位提取出来放在一起，就是Unicode中对应的代码点了。</p>
<h3 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h3><p>UTF-16使用16bit作为一个代码单元，是变长编码。首先记住这一点：<strong>在Unicode中，代码点0xD800～0xDFFF是没有定义字符的。</strong></p>
<p>对于Unicode中代码点位于<code>0x0000</code>～<code>0xFFFF</code>中字符，UTF-16使用一个代码单元即可，那么额对于Unicode中代码点不在<code>0x0000</code>～<code>0xFFFF</code>之间的字符呢？即对于Unicode中代码点位于<code>0x10000</code>～<code>0x10FFFF</code>中字符，UTF-16该怎么表示？</p>
<p><strong>思路是这样的：</strong>使用两个代码单元来表示这些字符，其中第一个代码单元的值在0xD800~0xDBFF之间，第二个代码单元的值在0xDC00~0xDFFF之间，前者称为<code>高位代理</code>，后者称为<code>低位代理</code>，两者一起称为<code>代理项对</code>（surrogate pair）。</p>
<p><strong>下面计算UTF-16能否表示所有的Unicode字符。</strong>使用一个UTF-16代码单元可以表示的字符数量是<code>2^16</code>，<code>0xD800～0xDFFF</code>对于Unicode或者UTF-16的一个代理单元都是不可用的。使用两个UTF-16代码单元可以表示的字符数量为：</p>
<pre><code>(0xdbff-0xd800+1) * (0xdfff-0xdc00+1)
= 1024 * 1024
= 1048576
</code></pre><p>所以UTF-16可以表示的字符数量为：</p>
<pre><code>1048576 + 2^16 = 1114112
</code></pre><p>这和Unicode表示的字符数量是相同的。</p>
<p><strong>对于Unicode中代码点位于<code>0x10000</code>～<code>0x10FFFF</code>中字符，如何转化为<code>代理项对</code>？</strong><br>首先，将代码点减去<code>0x10000</code>，这样新的代码点的范围变成了<code>0</code>～<code>0xFFFFF</code>，这些代码点可以用20bit来表示。将这20bit的前10bit（<code>0～0x3FF</code>）加上<code>0xD800</code>可得到高位代理，将这20bit的后10bit（<code>0～0x3FF</code>）加上<code>0xDC00</code>可得到低位代理。</p>
<p>对于utf-16还有字节序的问题（即大端序、小端序、混合序），可以参考<a href="http://zh.wikipedia.org/zh-cn/%E5%AD%97%E8%8A%82%E5%BA%8F" target="_blank" rel="external">维基百科-字节序</a>。</p>
<h3 id="UTF-32"><a href="#UTF-32" class="headerlink" title="UTF-32"></a>UTF-32</h3><p>一个代理单元是32bit，所以一个代码单元就可以表示所有的Unicode字符，是定长编码，与Unicode代码点一一对应。</p>
<h3 id="UCS-2"><a href="#UCS-2" class="headerlink" title="UCS-2"></a>UCS-2</h3><p>定长编码，使用2个字节表示字符，是UTF-16的子集，只能表示Unicode中代码点位于<code>0x0000</code>～<code>0xFFFF</code>中字符。</p>
<h2 id="Java的编码"><a href="#Java的编码" class="headerlink" title="Java的编码"></a>Java的编码</h2><hr>
<p>java平台内部统一使用UTF-16编码。</p>
<pre><code>// 文件是utf-8编码
public static void main(String[] args) throws UnsupportedEncodingException {
    // “你” -&gt; utf-8编码：E4BDA0 ， unicode代码点：4F60
    byte[] bs = new byte[]{(byte)0xE4, (byte)0xBD, (byte)0xA0};
    String str = new String(bs, &quot;UTF-8&quot;);
    System.out.println(str);
    char c0 = str.charAt(0);
    System.out.println( (int)c0 );
    System.out.println(Integer.toHexString( (int)c0 ));
    System.out.println(new String(&quot;你&quot;).equals(str));
}
</code></pre><p>运行结果：</p>
<pre><code>你
20320
4f60
true
</code></pre><p><code>0xE4</code>等16进制表示的整数默认是int类型，由于只有8bit，所以是正数。将<code>0xE4</code>强制转换为byte，就是保留int的低8位。byte是有符号的，所以<code>(byte)0xE4</code>是负数。</p>
<p>String内部使用char数组存放数据，char是16bit，无符号，一个char相当于UTF-16的一个代码单元。new <code>new String(bs, &quot;UTF-8&quot;);</code>将UTF-8编码的<code>E4BDA0</code>，转换成UTF-16表示。<code>“你”</code>的UTF-16表示是<code>4F60</code>，这也是<code>Integer.toHexString( (int)c0 )</code>的结果。</p>
<p>由于<code>new String(&quot;你&quot;).equals(str)</code>输出<code>true</code>，可以看出java自动将字符串<code>&quot;你&quot;</code>转换成为UTF-16编码。</p>
<h2 id="参考-amp-amp-更多相关"><a href="#参考-amp-amp-更多相关" class="headerlink" title="参考&amp;&amp;更多相关"></a>参考&amp;&amp;更多相关</h2><hr>
<p>成富 《深入理解Java7 核心技术与最佳实践》 第四章 国际化与本地化</p>
<p><a href="http://zh.wikipedia.org/zh-cn/%E5%AD%97%E8%8A%82%E5%BA%8F" target="_blank" rel="external">字节序</a>  </p>
<p><a href="http://en.wikipedia.org/wiki/Unicode" target="_blank" rel="external">wikiedia- Unicode</a></p>
<p><a href="http://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="external">wikipedia - UTF-8</a></p>
<p><a href="http://unicode.org/" target="_blank" rel="external">http://unicode.org/</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">字符编码笔记：ASCII，Unicode和UTF-8</a>  </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.letiantian.me/2015-01-29-java-bitwise-operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Letian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/content/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="樂天笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015-01-29-java-bitwise-operation/" itemprop="url">java拾遗：通过示例理解位运算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-29T11:14:48+08:00">
                January 29th 2015
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2015-01-29</p>
<p>环境：jdk 1.7。</p>
<p><strong>Java的位运算（Bitwise operation）直接对整数类型的位进行操作，这些整数类型包括long、int、short、char和 byte。</strong></p>
<p>在java中：<br>byte -&gt; 8 bits<br>short -&gt; 16 bits<br>int -&gt; 32 bits<br>long -&gt; 64 bits<br>char -&gt; 16 bit  </p>
<h2 id="int的位运算"><a href="#int的位运算" class="headerlink" title="int的位运算"></a>int的位运算</h2><hr>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>在java中，int数据底层以补码形式存储。关于原码、反码、补码，《<a href="http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html" target="_blank" rel="external">原码, 反码, 补码 详解</a>》给出了很精彩的解释。</p>
<p>int型变量使用32bit存储数据，其中最高位是符号位，0表示正数，1表示负数。例如：</p>
<pre><code>// 若最高的几位为0则不输出这几位，从为1的那一位开始输出
System.out.println(Integer.toBinaryString(10)); 
System.out.println(Integer.toBinaryString(-10));
</code></pre><p>会输出（手工排版过，以下的输出均会被手工排版）：</p>
<pre><code>                            1010
11111111111111111111111111110110
</code></pre><p>加法运算1：</p>
<pre><code>System.out.println(Integer.toBinaryString(11));
System.out.println(Integer.toBinaryString(10));
System.out.println(Integer.toBinaryString(21));
</code></pre><p>输出：</p>
<pre><code> 1011
 1010
10101
</code></pre><p>加法运算2：</p>
<pre><code>System.out.println(Integer.toBinaryString(-11));
System.out.println(Integer.toBinaryString(-10));
System.out.println(Integer.toBinaryString(-21));
</code></pre><p>输出：</p>
<pre><code>11111111111111111111111111110101
11111111111111111111111111110110
11111111111111111111111111101011
</code></pre><p>加法运算3：</p>
<pre><code>System.out.println(Integer.toBinaryString(11));
System.out.println(Integer.toBinaryString(-10));
System.out.println(Integer.toBinaryString(1));
</code></pre><p>输出：</p>
<pre><code>                            1011
11111111111111111111111111110110
                               1
</code></pre><p>加法运算4：</p>
<pre><code>System.out.println(Integer.toBinaryString(-11));
System.out.println(Integer.toBinaryString(10));
System.out.println(Integer.toBinaryString(-1));
</code></pre><p>输出：</p>
<pre><code>11111111111111111111111111110101
                            1010
11111111111111111111111111111111
</code></pre><p><strong>对于2进制补码的加法运算，和平常的计算一样，而且符号位也参与运算，不过最后只保留32位。</strong></p>
<h3 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移&lt;&lt;"></a>左移&lt;&lt;</h3><pre><code>System.out.println(Integer.toBinaryString(11));
System.out.println(Integer.toBinaryString(11&lt;&lt;2));  // 左移2位，44
System.out.println(Integer.toBinaryString(11&lt;&lt;28)); // -1342177280，负数
System.out.println(Integer.toBinaryString(-11));
System.out.println(Integer.toBinaryString(-11&lt;&lt;2)); // -44
</code></pre><p>输出：</p>
<pre><code>                            1011
                          101100
10110000000000000000000000000000
11111111111111111111111111110101
11111111111111111111111111010100
</code></pre><p>可以看出符号位也参与移位，移位时右侧空出的位补0。</p>
<h3 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移&gt;&gt;"></a>右移&gt;&gt;</h3><pre><code>System.out.println(Integer.toBinaryString(11));
System.out.println(Integer.toBinaryString(11&gt;&gt;2));   // 2
System.out.println(Integer.toBinaryString(-11));
System.out.println(Integer.toBinaryString(-11&gt;&gt;2));  // -3
</code></pre><p>输出：</p>
<pre><code>                            1011
                              10
11111111111111111111111111110101
11111111111111111111111111111101
</code></pre><p>对于右移，符号位参与移位。对于正数而言空出的位置补0,负数则补1。</p>
<h3 id="无符号右移-gt-gt-gt"><a href="#无符号右移-gt-gt-gt" class="headerlink" title="无符号右移 &gt;&gt;&gt;"></a>无符号右移 &gt;&gt;&gt;</h3><pre><code>System.out.println(Integer.toBinaryString(11));
System.out.println(Integer.toBinaryString(11&gt;&gt;&gt;2));  // 2
System.out.println(Integer.toBinaryString(-11));
System.out.println(Integer.toBinaryString(-11&gt;&gt;&gt;2)); // 1073741821
</code></pre><p>输出：</p>
<pre><code>                            1011
                              10
11111111111111111111111111110101
  111111111111111111111111111101
</code></pre><p>对于无符号右移，符号位参与移位。对于正数和负数，空出的位置均补0。</p>
<h3 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a>与运算</h3><pre><code>System.out.println(Integer.toBinaryString(11));
System.out.println(Integer.toBinaryString(10)); 
System.out.println(Integer.toBinaryString(11 &amp; 10)); 
System.out.println(Integer.toBinaryString(-11));
System.out.println(Integer.toBinaryString(10)); 
System.out.println(Integer.toBinaryString(-11 &amp; 10));
</code></pre><p>输出：</p>
<pre><code>                            1011
                            1010
                            1010
11111111111111111111111111110101
                            1010
                               0
</code></pre><h3 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a>或运算</h3><pre><code>System.out.println(Integer.toBinaryString(11));
System.out.println(Integer.toBinaryString(10)); 
System.out.println(Integer.toBinaryString(11 | 10)); 
System.out.println(Integer.toBinaryString(-11));
System.out.println(Integer.toBinaryString(10)); 
System.out.println(Integer.toBinaryString(-11 | 10));
</code></pre><p>输出：</p>
<pre><code>                            1011
                            1010
                            1011
11111111111111111111111111110101
                            1010
11111111111111111111111111111111
</code></pre><h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h3><pre><code>System.out.println(Integer.toBinaryString(11));
System.out.println(Integer.toBinaryString(10)); 
System.out.println(Integer.toBinaryString(11 ^ 10)); 
System.out.println(Integer.toBinaryString(-11));
System.out.println(Integer.toBinaryString(10)); 
System.out.println(Integer.toBinaryString(-11 ^ 10));
</code></pre><p>输出：</p>
<pre><code>                            1011
                            1010
                               1
11111111111111111111111111110101
                            1010
11111111111111111111111111111111
</code></pre><h3 id="非运算"><a href="#非运算" class="headerlink" title="非运算"></a>非运算</h3><pre><code>System.out.println(Integer.toBinaryString(11));
System.out.println(Integer.toBinaryString(~11)); 
System.out.println(Integer.toBinaryString(-11)); 
System.out.println(Integer.toBinaryString(~-11));
</code></pre><p>输出：</p>
<pre><code>                            1011
11111111111111111111111111110100
11111111111111111111111111110101
                            1010
</code></pre><h2 id="long的位运算"><a href="#long的位运算" class="headerlink" title="long的位运算"></a>long的位运算</h2><hr>
<p>和int类似，就是位数变成了64bit。举个例子：</p>
<pre><code>System.out.println(Long.toBinaryString(-10L));
System.out.println(Long.toBinaryString(-10L&lt;&lt;2));
</code></pre><p>输出：</p>
<pre><code>1111111111111111111111111111111111111111111111111111111111110110
1111111111111111111111111111111111111111111111111111111111011000
</code></pre><h2 id="byte、short、char的位运算"><a href="#byte、short、char的位运算" class="headerlink" title="byte、short、char的位运算"></a>byte、short、char的位运算</h2><hr>
<p>先被拓宽为int类型，然后进行位运算。类<code>Short</code>、<code>Character</code>、<code>Byte</code>中也没有<code>toBinaryString</code>方法。例如：</p>
<pre><code>short i;
byte b;
i = 5;
System.out.println(Integer.toBinaryString(i));
System.out.println(Integer.toBinaryString(i&lt;&lt;2));
i = -5;
System.out.println(Integer.toBinaryString(i));
System.out.println(Integer.toBinaryString(i&lt;&lt;2));
b = -128;
System.out.println(Integer.toBinaryString(b));
System.out.println(Integer.toBinaryString(b&lt;&lt;2));
</code></pre><p>输出：</p>
<pre><code>                             101
                           10100
11111111111111111111111111111011
11111111111111111111111111101100
11111111111111111111111110000000
11111111111111111111111000000000
</code></pre><h2 id="不止这些"><a href="#不止这些" class="headerlink" title="不止这些"></a>不止这些</h2><hr>
<p>对于移位运算，例如将x左移/右移n位，如果x是byte、short、char、int，n会先模32（即n=n%32），然后再进行移位操作。可以这样解释：int类型为32位,移动32位（或以上）没有意义。</p>
<p>同理若x是long，n=n%64。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.letiantian.me/2015-01-28-get-the-content-of-properties-file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Letian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/content/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="樂天笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015-01-28-get-the-content-of-properties-file/" itemprop="url">java拾遗：如何读取properties文件内容</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-28T22:00:48+08:00">
                January 28th 2015
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2015-01-28</p>
<h3 id="使用netbeans创建项目"><a href="#使用netbeans创建项目" class="headerlink" title="使用netbeans创建项目"></a>使用netbeans创建项目</h3><hr>
<p>首先使用netbeans 8创建java项目HelloJava，布局如下：</p>
<p><img src="/content/images/2015/01/2015-01-28-java-01.png" alt=""></p>
<p><code>src</code>目录保存着编写的代码，<code>build</code>保存编译好的class文件、资源文件等。</p>
<p><code>user.properties</code>内容如下：</p>
<pre><code>name=root
password=hi
</code></pre><h3 id="使用绝对路径读取"><a href="#使用绝对路径读取" class="headerlink" title="使用绝对路径读取"></a>使用绝对路径读取</h3><hr>
<p>类me.letian.HelloJava内容如下：</p>
<pre><code>package me.letian;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Properties;

public class HelloJava {

    public static void main(String[] args) throws IOException {
        Properties props = new Properties();
        String propsPath = &quot;/home/letian/NetBeansProjects/HelloJava/build/classes/me/letian/user.properties&quot;;

        try (InputStream in = Files.newInputStream(Paths.get(propsPath))) {
            props.load(in);
            System.out.println(props.getProperty(&quot;name&quot;));
        }
    }
}
</code></pre><p>使用netbeans执行该类中的main方法，结果如下：</p>
<pre><code>root
</code></pre><p>打包成jar文件：在菜单“Run”中选择“Clean and Build Project”，将会把项目打包成jar并放在项目下的dist目录下。</p>
<pre><code>$ cd /home/letian/NetBeansProjects/HelloJava/dist/
$ jar tvf HelloJava.jar  # 查看jar内容
     0 Wed Jan 28 21:01:16 CST 2015 META-INF/
   210 Wed Jan 28 21:01:14 CST 2015 META-INF/MANIFEST.MF
     0 Wed Jan 28 21:01:16 CST 2015 me/
     0 Wed Jan 28 21:01:16 CST 2015 me/letian/
  2030 Wed Jan 28 21:01:16 CST 2015 me/letian/HelloJava.class
    21 Wed Jan 28 21:01:16 CST 2015 me/letian/user.properties
$ java -jar HelloJava.jar me.letian.HelloJava   # 执行
root
</code></pre><h3 id="使用相对路径"><a href="#使用相对路径" class="headerlink" title="使用相对路径"></a>使用相对路径</h3><hr>
<p>使用相对路径，不能简单的将propsPath设值为<code>user.properties</code>：</p>
<pre><code>package me.letian;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Properties;

public class HelloJava {

    public static void main(String[] args) throws IOException {
        Properties props = new Properties();
        String propsPath = &quot;user.properties&quot;;

        System.out.println(&quot;&quot; + Paths.get(propsPath).toAbsolutePath()); // 输出绝对路径

        try (InputStream in = Files.newInputStream(Paths.get(propsPath))) {
            props.load(in);
            System.out.println(props.getProperty(&quot;name&quot;));
        }
    }
}
</code></pre><p>使用netbeans执行该类中的main方法，结果如下：</p>
<pre><code>/home/letian/NetBeansProjects/HelloJava/user.properties
Exception in thread &quot;main&quot; java.nio.file.NoSuchFileException: user.properties
......
</code></pre><p>打包成jar并执行：</p>
<pre><code>$ java -jar HelloJava.jar me.letian.HelloJava
/home/letian/NetBeansProjects/HelloJava/dist/user.properties
Exception in thread &quot;main&quot; java.nio.file.NoSuchFileException: user.properties
......
</code></pre><p>可以看到，上面的两种运行方式所输出的properties文件的绝对路径都是不存在的。</p>
<p>解决方法很简单：<br>将</p>
<pre><code>String propsPath = &quot;user.properties&quot;;
</code></pre><p>替换为</p>
<pre><code>String propsPath = &quot;src/me/letian/user.properties&quot;;
</code></pre><p>无论是使用绝对路径还是相对路径，对于jar都是不合适的，最好的方法是以资源文件的形式获取<code>user.properties</code>。</p>
<h3 id="以资源的形式（方法1）"><a href="#以资源的形式（方法1）" class="headerlink" title="以资源的形式（方法1）"></a>以资源的形式（方法1）</h3><hr>
<pre><code>package me.letian;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Paths;
import java.util.Properties;

public class HelloJava {

    public static void main(String[] args) throws IOException {
        Properties props = new Properties();
        String propsPath = &quot;me/letian/user.properties&quot;;

        try (InputStream in = HelloJava.class.getClassLoader().getResourceAsStream(&quot;me/letian/user.properties&quot;);) {
            props.load(in);
            System.out.println(props.getProperty(&quot;name&quot;));
        }
    }
}
</code></pre><h3 id="以资源的形式（方法2）"><a href="#以资源的形式（方法2）" class="headerlink" title="以资源的形式（方法2）"></a>以资源的形式（方法2）</h3><hr>
<pre><code>package me.letian;

import java.io.IOException;
import java.util.ResourceBundle;

public class HelloJava {

    public static void main(String[] args) throws IOException {

        ResourceBundle rb1 = ResourceBundle.getBundle(&quot;me.letian.user&quot;); 
        System.out.println(rb1.getString(&quot;name&quot;)); 

        ResourceBundle rb2 = ResourceBundle.getBundle(&quot;me/letian/user&quot;); 
        System.out.println(rb2.getString(&quot;password&quot;)); 
    }
}
</code></pre><p>执行结果：</p>
<pre><code>root
hi
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/content/images/avatar.jpg"
               alt="Letian" />
          <p class="site-author-name" itemprop="name">Letian</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">209</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/letiantian" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Letian</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "0b5e0b416d0b4d9a845ed9b2e72ddc70",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['[latex]','[/latex]'], ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        },
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


  <!-- highlight -->
  <script src="/highlight/highlight.min.js"></script>
  <link rel="stylesheet" href="/highlight/styles/github.css">

  <script>
    // 高亮
    hljs.initHighlightingOnLoad();
  </script>

</body>
</html>
