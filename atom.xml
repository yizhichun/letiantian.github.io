<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>樂天笔记</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.letiantian.me/"/>
  <updated>2017-06-25T09:10:28.000Z</updated>
  <id>http://www.letiantian.me/</id>
  
  <author>
    <name>Letian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅入浅出Android EventBus库</title>
    <link href="http://www.letiantian.me/android-eventbus/"/>
    <id>http://www.letiantian.me/android-eventbus/</id>
    <published>2017-06-25T09:02:28.000Z</published>
    <updated>2017-06-25T09:10:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>EventBus是一个事件总线框架，使用订阅/发布模式让组件间的通信变得简单。</p>
<p>官网：<a href="http://greenrobot.org/eventbus/" target="_blank" rel="external">http://greenrobot.org/eventbus/</a></p>
<p>官方教程：<a href="http://greenrobot.org/eventbus/documentation/" target="_blank" rel="external">http://greenrobot.org/eventbus/documentation/</a></p>
<p>原理很简单，就是<strong>订阅/发布模式的一个实现</strong>。好处是什么？<strong>解耦</strong>。</p>
<p>这篇文章从示例的角度解释EventBus的使用方法和原理。</p>
<p>示例展示了两个fragment之间如何通过EventBus通信。在fragment1中点击按钮发送事件（说成消息也可以），fragment2接收事件，并展示事件内容。效果如下：</p>
<a id="more"></a>
<p><img src="/content/images/2017/2017-06-25-android-eventbus-demo.gif" alt=""></p>
<p>代码托管在 <a href="https://github.com/letiantian/EventBus-example" target="_blank" rel="external">EventBus-example</a>。</p>
<h2 id="示例1-fragment之间通信"><a href="#示例1-fragment之间通信" class="headerlink" title="示例1-fragment之间通信"></a>示例1-fragment之间通信</h2><p>fragment之间的通信可以通过直接调用对象方法、广播等形式实现。<a href="http://blog.csdn.net/u012702547/article/details/49786417" target="_blank" rel="external">这里</a>有做些讨论。不过如果使用EventBus实现，既解耦，又优雅。</p>
<p>创建项目，在build.gradle中添加：</p>
<pre><code>compile &#39;org.greenrobot:eventbus:3.0.0&#39;
</code></pre><p>添加代码，最终结构如下：</p>
<p><img src="/content/images/2017/2017-06-25-android-eventbus-01.png" alt=""></p>
<h3 id="MainActivity和布局文件"><a href="#MainActivity和布局文件" class="headerlink" title="MainActivity和布局文件"></a>MainActivity和布局文件</h3><p>这个是程序入口：</p>
<pre><code class="java">package com.example.letian.eventbusapplication;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
}
</code></pre>
<p>对应的布局文件<code>activity_main.xml</code>内容如下：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:orientation=&quot;vertical&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.example.letian.eventbusapplication.MainActivity&quot;&gt;

    &lt;fragment android:name=&quot;com.example.letian.eventbusapplication.Example01Fragment&quot;
              android:id=&quot;@+id/list&quot;
              android:layout_weight=&quot;1&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;match_parent&quot; /&gt;
    &lt;fragment android:name=&quot;com.example.letian.eventbusapplication.Example02Fragment&quot;
              android:id=&quot;@+id/viewer&quot;
              android:layout_weight=&quot;2&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;match_parent&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre>
<p>这里指定了两个fragment。对应<code>Example01Fragment</code>类和<code>Example02Fragment</code>类。</p>
<h3 id="MessageEvent事件类"><a href="#MessageEvent事件类" class="headerlink" title="MessageEvent事件类"></a>MessageEvent事件类</h3><p>事件类的本质就是封装消息，根据需要自定义即可。</p>
<pre><code class="java">package com.example.letian.eventbusapplication.event;

public class MessageEvent {
    private String data;

    public MessageEvent(String data) {
        this.data = data;
    }

    public void setData(String data) {
        this.data = data;
    }

    public String getData() {
        return data;
    }

    @Override
    public String toString() {
        return &quot;MessageEvent{&quot; +
                &quot;data=&#39;&quot; + data + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }

}
</code></pre>
<h3 id="Example01Fragment和布局文件"><a href="#Example01Fragment和布局文件" class="headerlink" title="Example01Fragment和布局文件"></a>Example01Fragment和布局文件</h3><p>Example01Fragment类内容如下：</p>
<pre><code class="java">package com.example.letian.eventbusapplication;

import android.app.Fragment;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;

import com.example.letian.eventbusapplication.event.MessageEvent;

import org.greenrobot.eventbus.EventBus;


public class Example01Fragment extends Fragment {

    private View rootView;

    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
        // return super.onCreateView(inflater, container, savedInstanceState);
        rootView = inflater.inflate(R.layout.example01_fragment, container, false);
        Button sendBtn = rootView.findViewById(R.id.send);
        sendBtn.setOnClickListener(new View.OnClickListener() {  // 点击按钮，发布事件
            @Override
            public void onClick(View view) {
                EventBus.getDefault().post(new MessageEvent(&quot;Hello everyone!&quot;));  // 发布事件
            }
        });
        return rootView;
    }

}
</code></pre>
<p> <code>EventBus.getDefault()</code>得到EventBus的默认实例，post方法用于发布事件。</p>
<p>布局文件<code>example01_fragment.xml</code>内容如下：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
              android:orientation=&quot;vertical&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;match_parent&quot;&gt;
    &lt;Button
        android:id=&quot;@+id/send&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;发送消息&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre>
<h3 id="Example02Fragment和布局文件"><a href="#Example02Fragment和布局文件" class="headerlink" title="Example02Fragment和布局文件"></a>Example02Fragment和布局文件</h3><p>Example02Fragment类内容如下：</p>
<pre><code class="java">package com.example.letian.eventbusapplication;

import android.app.Fragment;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

import com.example.letian.eventbusapplication.event.MessageEvent;

import org.greenrobot.eventbus.EventBus;
import org.greenrobot.eventbus.Subscribe;
import org.greenrobot.eventbus.ThreadMode;

public class Example02Fragment extends Fragment {

    private View rootView;
    private TextView textView;
    private static String TAG = &quot;Example02Fragment&quot;;
    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
        // return super.onCreateView(inflater, container, savedInstanceState);
        rootView = inflater.inflate(R.layout.example02_fragment, container, false);
        textView = rootView.findViewById(R.id.msg);
        return rootView;
    }

    @Override
    public void onStart() {
        super.onStart();
        EventBus.getDefault().register(this); // 将该对象注册到 EventBus
    }

    @Override
    public void onStop() {
        super.onStop();
        EventBus.getDefault().unregister(this); // 解除注册关系
    }

    @Subscribe(threadMode = ThreadMode.MAIN)
    public void onMessage(MessageEvent event) { // 监听 MessageEvent 事件
        Log.v(TAG, &quot;GET event: &quot;+event);
        textView.setText(event.getData());
    }
}
</code></pre>
<ul>
<li><code>EventBus.getDefault().register(this);</code>是将<code>Example02Fragment</code>作为订阅者注册到EventBus中；</li>
<li><code>EventBus.getDefault().unregister(this);</code>用于解除订阅关系。</li>
<li><code>onMessage</code>方法监听<code>MessageEvent</code>类型的事件，在<code>MAIN</code>线程（也就是主线程）收到事件后，将数据显示在textView中。</li>
</ul>
<p>布局文件<code>example02_fragment.xml</code>内容如下：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
              android:orientation=&quot;vertical&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;match_parent&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;接收消息&quot;/&gt;
    &lt;TextView
        android:id=&quot;@+id/msg&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre>
<h2 id="示例2-使用索引类提升性能"><a href="#示例2-使用索引类提升性能" class="headerlink" title="示例2-使用索引类提升性能"></a>示例2-使用索引类提升性能</h2><p>示例1中使用EventBus基于反射收集订阅者的信息，但是反射机制在性能上表现不佳，一个优化是将订阅者的信息生成索引写入一个Java类里。也就是生成一个包含订阅者信息的Java类，运行时就不需要用反射了。这里涉及到注解处理器的概念。EventBus的注解处理器实现在<a href="https://github.com/greenrobot/EventBus/tree/master/EventBusAnnotationProcessor" target="_blank" rel="external">这里</a>。</p>
<h3 id="生成索引文件"><a href="#生成索引文件" class="headerlink" title="生成索引文件"></a>生成索引文件</h3><p>修改build.gradle添加下面的内容：</p>
<pre><code class="gradle">android {
    defaultConfig {

        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [ eventBusIndex : &#39;com.example.letian.eventbusapplication.MyEventBusIndex&#39; ]
            }
        }
    }
}

dependencies {
    compile &#39;org.greenrobot:eventbus:3.0.0&#39;
    annotationProcessor &#39;org.greenrobot:eventbus-annotation-processor:3.0.1&#39;
}
</code></pre>
<p>首先通过编译参数指定注解处理器的参数是<code>eventBusIndex : &#39;com.example.letian.eventbusapplication.MyEventBusIndex&#39;</code></p>
<p>然后在dependencies中通过gradle内置的annotationProcessor指令指定注解处理器：<code>&#39;org.greenrobot:eventbus-annotation-processor:3.0.1&#39;</code>。</p>
<p>如此，在编译过程中会生成类<code>com.example.letian.eventbusapplication.MyEventBusIndex</code>。这个类生成后在不是放在代码目录，而是在build目录里。根据文件名可以搜索到这个文件，这里晒下它的内容：</p>
<pre><code class="java">package com.example.letian.eventbusapplication;

import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;
import org.greenrobot.eventbus.meta.SubscriberMethodInfo;
import org.greenrobot.eventbus.meta.SubscriberInfo;
import org.greenrobot.eventbus.meta.SubscriberInfoIndex;

import org.greenrobot.eventbus.ThreadMode;

import java.util.HashMap;
import java.util.Map;

/** This class is generated by EventBus, do not edit. */
public class MyEventBusIndex implements SubscriberInfoIndex {
    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();

        // 重点在这里
        putIndex(new SimpleSubscriberInfo(Example02Fragment.class, true, new SubscriberMethodInfo[] {
            new SubscriberMethodInfo(&quot;onMessage&quot;, com.example.letian.eventbusapplication.event.MessageEvent.class,
                    ThreadMode.MAIN),
        }));

    }

    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    @Override
    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
</code></pre>
<h3 id="使用索引文件"><a href="#使用索引文件" class="headerlink" title="使用索引文件"></a>使用索引文件</h3><p>要使用索引文件，就不需要用<code>EventBus.getDefault()</code>去做注册订阅者、取消注册订阅者、发送消息等事情了。而要使用自定义的EventBus对象。</p>
<p>首相编写类MyEventBus，如下：</p>
<pre><code class="java">package com.example.letian.eventbusapplication;

import org.greenrobot.eventbus.EventBus;

public class MyEventBus {

    public final static EventBus eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build();

}
</code></pre>
<p>将其他代码里的<code>EventBus.getDefault()</code>替换成<code>MyEventBus.eventBus</code>即可。</p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>EventBus支持多种ThreadMode，支持事件优先级，支持sticky模式，支持事件中断，这些内容都可以在简洁易懂的官方教程中找到。</p>
<p>下面的文章值得一读：</p>
<ul>
<li><a href="http://greenrobot.org/eventbus/documentation/" target="_blank" rel="external">官方教程</a></li>
<li><a href="http://www.jianshu.com/p/31e3528ca7e5" target="_blank" rel="external">EventBus3.0详解</a></li>
<li><a href="http://liuwangshu.cn/application/eventbus/1-eventbus.html" target="_blank" rel="external">Android事件总线（一）EventBus3.0用法全解析</a></li>
<li><a href="http://liuwangshu.cn/application/eventbus/2-eventbus-sourcecode.html" target="_blank" rel="external">Android事件总线（二）EventBus3.0源码解析</a></li>
<li><a href="https://www.race604.com/annotation-processing/" target="_blank" rel="external">Java注解处理器</a></li>
<li><a href="http://www.cnblogs.com/whoislcj/p/6148410.html" target="_blank" rel="external">Android注解使用之注解编译android-apt如何切换到annotationProcessor</a></li>
</ul>
<p>当然，除了EventBus，事件总线有很多实现，例如otto、guava、AndroidEventBus等。有时间了，搞一把。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;EventBus是一个事件总线框架，使用订阅/发布模式让组件间的通信变得简单。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;http://greenrobot.org/eventbus/&quot;&gt;http://greenrobot.org/eventbus/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方教程：&lt;a href=&quot;http://greenrobot.org/eventbus/documentation/&quot;&gt;http://greenrobot.org/eventbus/documentation/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原理很简单，就是&lt;strong&gt;订阅/发布模式的一个实现&lt;/strong&gt;。好处是什么？&lt;strong&gt;解耦&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这篇文章从示例的角度解释EventBus的使用方法和原理。&lt;/p&gt;
&lt;p&gt;示例展示了两个fragment之间如何通过EventBus通信。在fragment1中点击按钮发送事件（说成消息也可以），fragment2接收事件，并展示事件内容。效果如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.letiantian.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>浅入浅出Android Volley</title>
    <link href="http://www.letiantian.me/android-volley/"/>
    <id>http://www.letiantian.me/android-volley/</id>
    <published>2017-06-17T07:02:28.000Z</published>
    <updated>2017-06-17T07:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Volley is an HTTP library that makes networking for Android apps easier and, most importantly, faster.</p>
</blockquote>
<p>源码地址：　<a href="https://github.com/google/volley" target="_blank" rel="external">https://github.com/google/volley</a></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>已经有很多文章介绍了Volley，不再重复。下面是一些参考：</p>
<ul>
<li><a href="http://blog.csdn.net/guolin_blog/article/details/17482095" target="_blank" rel="external">Android Volley完全解析系列</a></li>
<li><a href="http://blog.csdn.net/t12x3456/article/details/9221611" target="_blank" rel="external">Android 网络通信框架Volley简介(Google IO 2013)</a></li>
</ul>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>在volley中有三种类型的线程：</p>
<ul>
<li>主程/其他线程：主线程即UI线程。<code>主程/其他线程</code>负责将网络请求交给RequestQueue。</li>
<li>网络线程：发起网络调用，得到返回数据。默认是4个线程。</li>
<li>缓存线程：如果请求允许使用缓存，则缓存线程尝试去取缓存数据。</li>
</ul>
<p><img src="/content/images/2017/2017-06-17-volley-thread-01.png" alt=""></p>
<a id="more"></a>
<p>那么网络线程、缓存线程是从什么地方拿到的请求呢？答案是<strong>阻塞式队列</strong>。</p>
<p>涉及到两个队列存储网络请求：</p>
<ul>
<li>网络线程从 PriorityBlockingQueue 类型的队列中取网络请求，称之为<code>mNetworkQueue</code>。</li>
<li>缓存线程也是 PriorityBlockingQueue 类型的队列中取网络请求，称之为<code>mCacheQueue</code>。</li>
</ul>
<p>而RequestQueue 本身不是队列，不过其内部主要逻辑是将请求对象放入<code>mNetworkQueue</code>或<code>mCacheQueue</code>。</p>
<p>这里有一个问题，两个相同的支持缓存的请求（请求1、请求2）几乎同时到来，那么其实没必要对请求2进行处理，只需要等请求1拿到响应数据后，把数据顺便给请求2即可。Volley中使用 <code>Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;</code>记录有没有支持缓存的请求正在进行，称之为<code>mWaitingRequests</code>。其中key是请求的key（默认是url），value是请求对象的容器。</p>
<h3 id="网络请求发起流程"><a href="#网络请求发起流程" class="headerlink" title="网络请求发起流程"></a>网络请求发起流程</h3><p>请求发起流程：</p>
<ol>
<li>主线程（其他线程也行）生成请求对象，对象内部包含了请求地址、请求方法、处理返回数据的回调对象等。</li>
<li>主线程将请求对象交给RequestQueue对象。以下是RequestQueue对象内部的处理逻辑：<ol>
<li>判断该请求对象是否允许使用缓存，若不允许，则将请求放入<code>mNetworkQueue</code>。<strong>流程结束</strong>。若允许缓存，进入下一步。</li>
<li>得到请求对象的key值（默认是网址Url），根据mWaitingRequests判断当前是否有相同key的网络请求正在进行。<strong>如果有</strong>，则将该请求对象先存到mWaitingRequests中key对应的容器中，等待已有的相同key的网络请求响应回来后，顺便把结果交给该请求。<strong>如果没有</strong>，则进入下一步：</li>
<li>将请求对象放入mCacheQueue，并记录当前有key为×××的请求正在进行处理。</li>
</ol>
</li>
</ol>
<h3 id="缓存线程"><a href="#缓存线程" class="headerlink" title="缓存线程"></a>缓存线程</h3><p>缓存线程是一直运行，内部就是死循环，每一次循环从mCacheQueue拿出一个网络请求进行处理，处理流程如下：</p>
<ol>
<li>根据网络请求的key，判断缓存中是否有已有内容，若没有内容、或者内容过期，则将网络请求扔到<code>mNetworkQueue</code>，让网络线程去处理。<strong>结束流程。</strong> </li>
<li>若有未过期的缓存，则将缓存内容作为响应内容。在主线程中执行网络请求中回调对象中的函数。</li>
</ol>
<h3 id="网络线程"><a href="#网络线程" class="headerlink" title="网络线程"></a>网络线程</h3><p>类似的，网络线程是一直运行，内部就是死循环，每一次循环从mNetworkQueue拿出一个网络请求进行处理，处理流程如下：</p>
<ol>
<li>BasicNetwork对网络请求进行处理，得到响应数据。</li>
<li>如果该网络请求允许缓存且HTTP响应头也给出了允许缓存相关的信息，则缓存响应结果。</li>
<li>在主线程中执行该网络请求中回调对象中的函数。</li>
</ol>
<h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>缓存使用key-value的形式存取，key是从Request类中拿出来的，默认是网址。<code>StringRequest</code>、<code>JsonArrayRequest</code>等网络请求类集成自<code>Request</code>。可以根据需要在自定义的Request子类中覆盖该方法。</p>
<pre><code class="java">public abstract class Request&lt;T&gt; implements Comparable&lt;Request&lt;T&gt;&gt; {
    // ...

    public String getCacheKey() {
        return getUrl();
    }

    // ...
}
</code></pre>
<p>而value是包含了多个属性，有响应头、响应体、ETag内容、Last-Modified内容、Expires内容等。</p>
<p><code>DiskBasedCache</code>是默认的缓存实现，一个基于文件存储的cache，所有文件存在一个目录里。有以下几个有趣的设计：</p>
<ul>
<li><p>文件名并不是key。key是存在文件里面的。而文件名是基于key生成的具有（伪）1对1关系的名称。不是md5哈。真的冲突了也没关系，key存在文件里呢。</p>
</li>
<li><p>初始化时，会将本地已有的缓存全部载入内存。但是内存中不会有响应体，如图片、html等。添加缓存时，既存入本地，也加入内存中。删除某条缓存，既删本地，也删内存中对应内容。根据key获取缓存时，先看内存中有没有，没有就直接返回null，有的话再从本地存储中把响应体拿出来。</p>
</li>
<li><p>针对响应体，默认允许本地存储最大为5MB。当添加缓存时，会判断有没有超出限制，若超出，则先删除之前已有的部分缓存，直到满足下面的条件才添加新缓存：</p>
</li>
</ul>
<pre><code class="plain">本地缓存占用空间+新缓存要占用的空间 &lt; 最大缓存大小*0.9
</code></pre>
<h3 id="超时和重试"><a href="#超时和重试" class="headerlink" title="超时和重试"></a>超时和重试</h3><p>超时时间和重试次数的代码在Request类中已经实现：</p>
<pre><code class="java">public Request&lt;?&gt; setRetryPolicy(RetryPolicy retryPolicy) {
    mRetryPolicy = retryPolicy;
    return this;
}

public final int getTimeoutMs() {
    return mRetryPolicy.getCurrentTimeout();　// 单位是毫秒
}

public RetryPolicy getRetryPolicy() {
    return mRetryPolicy;
}
</code></pre>
<p>直接在Request子类中实现<code>getTimeoutMs</code>方法是不可能了，所以设置重试策略即可。</p>
<p>重试策略是一个接口，内容如下：</p>
<pre><code class="java">public interface RetryPolicy {

    int getCurrentTimeout();

    int getCurrentRetryCount();

    void retry(VolleyError error) throws VolleyError;
}
</code></pre>
<p> 结束重试的方式是在<code>retry</code>方法在合适的时候抛出一个异常即可。</p>
<p><code>DefaultRetryPolicy</code>是<code>RetryPolicy</code>的默认实现，可以指定超时时间和重试次数，以及重试时超时时间如何变化。</p>
<h3 id="图片自动处理"><a href="#图片自动处理" class="headerlink" title="图片自动处理"></a>图片自动处理</h3><p>一张很大的图片直接在view中显示会耗费大量内存，甚至产生OOM（OutOfMemory）问题。一个有效的应对方法是imageview多大，就把图片先处理成相应大小，再在UI上展示。</p>
<p>volley提供了ImageRequest、ImageLoader、NetworkImageView类来处理图片，均使用了<code>IMageRequest</code>中<code>doParse</code>方法处理网络请求返回的图片，具体代码在<a href="https://github.com/google/volley/blob/master/src/main/java/com/android/volley/toolbox/ImageRequest.java#L170" target="_blank" rel="external">这里</a>。</p>
<h2 id="代码防御"><a href="#代码防御" class="headerlink" title="代码防御"></a>代码防御</h2><p>根据<a href="http://blog.csdn.net/t12x3456/article/details/9221611" target="_blank" rel="external">Android 网络通信框架Volley简介(Google IO 2013)</a>的建议，在Activity onStop　时，cancelAll　所有请求，这样网络请求如果未请求，则不会发起请求，如果已经请求，返回数据后不会执行网络请求的回调。示例：</p>
<pre><code class="java">@Override pubic void onStop() {
    mRequestQueue.cancelAll(this);
    //...
}
</code></pre>
<h2 id="一些问题的解决方案"><a href="#一些问题的解决方案" class="headerlink" title="一些问题的解决方案"></a>一些问题的解决方案</h2><h3 id="POST-不支持相同参数"><a href="#POST-不支持相同参数" class="headerlink" title="POST 不支持相同参数"></a>POST 不支持相同参数</h3><p>POST 方法如果要带数据，需要覆盖<code>getParams</code>方法。下面是来自 <a href="http://blog.csdn.net/guolin_blog/article/details/17482095" target="_blank" rel="external">Android Volley完全解析(一)，初识Volley的基本用法</a>的一段代码：</p>
<pre><code class="java">StringRequest stringRequest = new StringRequest(Method.POST, url,  listener, errorListener) {  
    @Override  
    protected Map&lt;String, String&gt; getParams() throws AuthFailureError {  
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();  
        map.put(&quot;params1&quot;, &quot;value1&quot;);  
        map.put(&quot;params2&quot;, &quot;value2&quot;);  
        return map;  
    }  
};
</code></pre>
<p>数据的组装其实是在<code>getBody</code>方法里：</p>
<pre><code class="java">public byte[] getBody() throws AuthFailureError {
    Map&lt;String, String&gt; params = getParams();
    if (params != null &amp;&amp; params.size() &gt; 0) {
        return encodeParameters(params, getParamsEncoding());
    }
    return null;
}
</code></pre>
<p>然而，这种实现不支持类似<code>a=1&amp;a=1&amp;b=123</code>参数名多次出现的场景。</p>
<p>解决办法是，生成Request对象时覆盖<code>getBody</code>方法。</p>
<h3 id="设置请求头"><a href="#设置请求头" class="headerlink" title="设置请求头"></a>设置请求头</h3><p>生成Request对象时，覆盖<code>getHeaders</code>方法即可。</p>
<pre><code class="java">public Map&lt;String, String&gt; getHeaders() throws AuthFailureError {
    return Collections.emptyMap();
}
</code></pre>
<h3 id="图片上传问题"><a href="#图片上传问题" class="headerlink" title="图片上传问题"></a>图片上传问题</h3><p>Volley没有图片上传的实用类/函数，解决办法有两个：</p>
<ol>
<li>将图片转换为base64，以字符串的形式将图片POST到服务器端。</li>
<li>基于HTTP上传图片原理，在<code>getBody</code>里生成数据。可以参考这里：<a href="http://blog.csdn.net/jxxfzgy/article/details/44064481" target="_blank" rel="external">Android volley 解析（三）之文件上传篇</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Volley is an HTTP library that makes networking for Android apps easier and, most importantly, faster.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;源码地址：　&lt;a href=&quot;https://github.com/google/volley&quot;&gt;https://github.com/google/volley&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实战&quot;&gt;&lt;a href=&quot;#实战&quot; class=&quot;headerlink&quot; title=&quot;实战&quot;&gt;&lt;/a&gt;实战&lt;/h2&gt;&lt;p&gt;已经有很多文章介绍了Volley，不再重复。下面是一些参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/guolin_blog/article/details/17482095&quot;&gt;Android Volley完全解析系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/t12x3456/article/details/9221611&quot;&gt;Android 网络通信框架Volley简介(Google IO 2013)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;设计思路&quot;&gt;&lt;a href=&quot;#设计思路&quot; class=&quot;headerlink&quot; title=&quot;设计思路&quot;&gt;&lt;/a&gt;设计思路&lt;/h2&gt;&lt;p&gt;在volley中有三种类型的线程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主程/其他线程：主线程即UI线程。&lt;code&gt;主程/其他线程&lt;/code&gt;负责将网络请求交给RequestQueue。&lt;/li&gt;
&lt;li&gt;网络线程：发起网络调用，得到返回数据。默认是4个线程。&lt;/li&gt;
&lt;li&gt;缓存线程：如果请求允许使用缓存，则缓存线程尝试去取缓存数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/content/images/2017/2017-06-17-volley-thread-01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.letiantian.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>一个红包随机分配算法</title>
    <link href="http://www.letiantian.me/2016-04-23-red-envelope/"/>
    <id>http://www.letiantian.me/2016-04-23-red-envelope/</id>
    <published>2016-04-23T04:15:00.000Z</published>
    <updated>2016-04-23T04:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单的讨论一下随机分配红包的算法实现。若有雷同，纯属巧合。</p>
<h2 id="如何生成指定范围内的随机整数"><a href="#如何生成指定范围内的随机整数" class="headerlink" title="如何生成指定范围内的随机整数"></a>如何生成指定范围内的随机整数</h2><p>Python的random库提供了randint函数用于得到整数a和整数b之间的一个随机的整数（包括a和b，其中a&lt;=b）。</p>
<pre><code class="python">import random
a=1
b=100
print random.randint(a,b)
</code></pre>
<a id="more"></a>
<p>randint函数可以基于random函数实现。random函数可以随机生成<code>[0.0, 1.0)</code>之间的一个小数，注意是左闭右开的区间。</p>
<p>下面的my_randint01函数可以得到一个左闭右开区间中的随机整数：</p>
<pre><code class="python">import random

def my_randint01(left, right):
    if left&gt;=right:
        raise Exception(&#39;...&#39;)
    rand_number = random.random()
    result = left+rand_number*(right-left)
    return int(result)

if __name__ == &#39;__main__&#39;:
    for _ in range(10):
        print my_randint01(2, 6)
</code></pre>
<p>下面的my_randint02函数可以得到一个左闭右闭区间中的随机整数：</p>
<pre><code class="python">import random

def my_randint02(left, right):
    if left&gt;right:
        raise Exception(&#39;...&#39;)
    rand_number = random.random()
    result = left+rand_number*(right-left+1)  # 此处略有改动
    return int(result)

if __name__ == &#39;__main__&#39;:
    for _ in range(10):
        print my_randint01(2, 6)
</code></pre>
<h2 id="红包分配要考虑的情况"><a href="#红包分配要考虑的情况" class="headerlink" title="红包分配要考虑的情况"></a>红包分配要考虑的情况</h2><p>用户看到的是红包单位是<code>元</code>，不过RMB的最小单位是分，将金额从<code>元</code>转换为<code>分</code>也许更容易处理。</p>
<p>用户拿到的红包转换为<code>分</code>时，必须是整数。</p>
<p>4分钱发给4个朋友，每个人都应该得到1分的红包。</p>
<p>4分钱不能发给5个朋友。</p>
<p>100分钱发给4个朋友要体现出随机性。</p>
<h2 id="来，发红包"><a href="#来，发红包" class="headerlink" title="来，发红包"></a>来，发红包</h2><p>100分钱发给4个人，可以先得到4个大于0的在一定范围内的随机整数。每个人对应一个随机整数，通过这个随机整数可以得到他收到的红包大小在100分钱中的比例，然后按照比例分配。在此基础上还需要考虑下面的细节问题：</p>
<p><strong>1、</strong> 涉及到浮点数的乘除法，如果一个人最终得到了<code>0.2</code>分钱，转转成整数该是0分钱还是1分钱？ 解决办法是先给每个人分配1分钱。</p>
<p><strong>2、</strong> 涉及到浮点数的乘除法，最后分配的红包取整后的和不一定等于100。解决方法是：每个人的红包向下取整，第4个人直接把剩下的拿到手即可。</p>
<p><strong>3、</strong> 按照上面的思路，5分钱分给4个人，第四个人稳拿2分钱。解决方法是：红包分配好后再随机打乱。</p>
<p>最终算法如下：</p>
<pre><code class="python">#coding: utf-8
import random

def red_envelope(cents, people_number):

    if (not isinstance(cents, int)) or (not isinstance(people_number, int)):
        raise Exception(&#39;invalid type!&#39;)

    if cents &lt; people_number:
        raise Exception(&#39;too many people!&#39;)

    if cents &lt;= 0 or people_number &lt;= 0:
        raise Exception(&#39;Are you kidding me ?&#39;)

    if cents == people_number:
        return [1] * people_number

    if people_number == 1:
        return [cents]

    fix_result = [1] * people_number
    cents = cents - 1*people_number
    balance = cents
    rand_result = []
    rand_numbers = []
    for _ in range(people_number):
        rand_numbers.append(random.randint(10,100))
    rand_sum = float(sum(rand_numbers))

    for idx in range(people_number):
        if idx == people_number - 1:
            rand_result.append(balance)
        else:
            scale = rand_numbers[idx] / rand_sum
            your_cents = int(cents*scale)
            rand_result.append(your_cents)
            balance = balance - your_cents

    result = []
    for fix, rand in zip(fix_result, rand_result):
        result.append(fix+rand)

    random.shuffle(result)  # shuffle the result

    return result


# test
if __name__ == &#39;__main__&#39;:
    result = red_envelope(100, 10)
    print result, sum(result)
</code></pre>
<p>某次输出结果：</p>
<pre><code class="plain">[15, 10, 11, 10, 3, 7, 14, 3, 20, 7] 100
</code></pre>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单的讨论一下随机分配红包的算法实现。若有雷同，纯属巧合。&lt;/p&gt;
&lt;h2 id=&quot;如何生成指定范围内的随机整数&quot;&gt;&lt;a href=&quot;#如何生成指定范围内的随机整数&quot; class=&quot;headerlink&quot; title=&quot;如何生成指定范围内的随机整数&quot;&gt;&lt;/a&gt;如何生成指定范围内的随机整数&lt;/h2&gt;&lt;p&gt;Python的random库提供了randint函数用于得到整数a和整数b之间的一个随机的整数（包括a和b，其中a&amp;lt;=b）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;import random
a=1
b=100
print random.randint(a,b)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://www.letiantian.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何实现拼音与汉字的互相转换</title>
    <link href="http://www.letiantian.me/2016-02-08-pinyin-hanzi/"/>
    <id>http://www.letiantian.me/2016-02-08-pinyin-hanzi/</id>
    <published>2016-02-08T08:45:00.000Z</published>
    <updated>2016-02-16T07:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>2016-02-08</p>
<h2 id="基于词库的汉字转拼音"><a href="#基于词库的汉字转拼音" class="headerlink" title="基于词库的汉字转拼音"></a>基于词库的汉字转拼音</h2><p>词库中既要包含每个字的拼音，也要包含常用单词/短语的读音。有些字是多音字，所以至少要保存其最常用的读音，不常用的读音多出现在单词/短语里。</p>
<p>好了，词库准备好了，现在手头有一句话要转换要转换为拼音，这句话是：</p>
<pre><code>你好世界杯
</code></pre><p>我们的词库是这样子的：</p>
<pre><code>你：nǐ
好：hǎo,hào
世：shì
界：jiè
杯：bēi
世界：shì,jiè
你好：nǐ,hǎo
苦尽甘来：kǔ,jìn,gān,lái
</code></pre><a id="more"></a>
<p>词库中最长的词<code>苦尽甘来</code>包含4个字。所以<code>你好世界杯</code>从4个字开始匹配：</p>
<ul>
<li>判断<code>你好世界</code>是否在词库中，不在；</li>
<li>判断<code>你好世</code>是否在词库中，不在；</li>
<li>判断<code>你好</code>是否在词库中，在，得到<code>nǐ,hǎo</code>；</li>
<li>判断<code>世界杯</code>是否在词库中，不在；</li>
<li>判断<code>世界</code>是否在词库中，在，得到<code>shì,jiè</code>；</li>
<li>判断<code>杯</code>是否在词库中，在，得到<code>bēi</code>；</li>
</ul>
<p>于是<code>你好世界杯</code>被转换为<code>nǐ,hǎo,shì,jiè,bēi</code>。</p>
<h2 id="基于词库和分词工具的汉字转拼音"><a href="#基于词库和分词工具的汉字转拼音" class="headerlink" title="基于词库和分词工具的汉字转拼音"></a>基于词库和分词工具的汉字转拼音</h2><p>纯粹的基于词库的方法在实际的使用中会遇到问题，例如<code>提出了解决方案</code>这句话中<code>了解</code>会被当作一个单词，所以会得到错误的结果：</p>
<pre><code>tí,chū,liǎo,jiě,jué,fāng,àn
</code></pre><p>更好的方法是先进行分词得到：</p>
<pre><code>提出
了
解决
方案
</code></pre><p>然后基于词库对每个结果分别处理。</p>
<h2 id="基于HMM的拼音转汉字"><a href="#基于HMM的拼音转汉字" class="headerlink" title="基于HMM的拼音转汉字"></a>基于HMM的拼音转汉字</h2><p>这里的拼音一般不带声调。</p>
<p>将汉字作为隐藏状态，拼音作为观测值，使用viterbi算法可以将多个拼音转换成合理的汉字。例如给出<code>ti,chu,le,jie,jue,fang,an</code>，viterbi算法会认为<code>提出了解决方案</code>是最合理的状态序列。</p>
<p>HMM需要三个分布，分别是：</p>
<ul>
<li>初始时各个状态的概率分布</li>
<li>各个状态互相转换的概率分布</li>
<li>状态到观测值的概率分布</li>
</ul>
<p>这个3个分布就是三个矩阵，根据一些文本库统计出来即可。</p>
<p>viterbi算法基于动态规划，<a href="https://en.wikipedia.org/wiki/Viterbi_algorithm" target="_blank" rel="external">维基百科 - Viterbi algorithm</a>给出了很好的解释和示例。</p>
<h2 id="基于词库的拼音转汉字"><a href="#基于词库的拼音转汉字" class="headerlink" title="基于词库的拼音转汉字"></a>基于词库的拼音转汉字</h2><p>原则：</p>
<ul>
<li>词的权重大于字的权重；</li>
<li>转换中匹配的词越多，权重越小。</li>
</ul>
<p>词库的格式是：</p>
<pre><code>拼音:单词:权重
</code></pre><p>例如：</p>
<pre><code>ni:你:0.15
ni:泥:0.12
a:啊:0.18
hao:好:0.14
nihao:你好:0.6
</code></pre><p>假如输入是<code>ni,hao,a</code>，我们计算一下各种组合的权重：</p>
<table>
<thead>
<tr>
<th>组合</th>
<th>权重</th>
</tr>
</thead>
<tbody>
<tr>
<td>你,好,啊</td>
<td>0.15×0.14×0.18 = 0.00378</td>
</tr>
<tr>
<td>泥,好,啊</td>
<td>0.12×0.14×0.18 = 0.003024</td>
</tr>
<tr>
<td>你好,啊</td>
<td>0.6×0.18 = 0.108</td>
</tr>
</tbody>
</table>
<p>可以看出，<code>你好,啊</code>是最好的结果。</p>
<p>实际实现中需要用到<strong>动态规划</strong>， 和求有向无环图中两点之间最短距离类似。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>基于上面的思路，我编写了两个工具，欢迎指教 ^^</p>
<ul>
<li>拼音转汉字（拼音输入法引擎）：<a href="https://github.com/letiantian/Pinyin2Hanzi" target="_blank" rel="external">https://github.com/letiantian/Pinyin2Hanzi</a></li>
<li>汉字转拼音：<a href="https://github.com/letiantian/ChineseTone" target="_blank" rel="external">https://github.com/letiantian/ChineseTone</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2016-02-08&lt;/p&gt;
&lt;h2 id=&quot;基于词库的汉字转拼音&quot;&gt;&lt;a href=&quot;#基于词库的汉字转拼音&quot; class=&quot;headerlink&quot; title=&quot;基于词库的汉字转拼音&quot;&gt;&lt;/a&gt;基于词库的汉字转拼音&lt;/h2&gt;&lt;p&gt;词库中既要包含每个字的拼音，也要包含常用单词/短语的读音。有些字是多音字，所以至少要保存其最常用的读音，不常用的读音多出现在单词/短语里。&lt;/p&gt;
&lt;p&gt;好了，词库准备好了，现在手头有一句话要转换要转换为拼音，这句话是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;你好世界杯
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们的词库是这样子的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;你：nǐ
好：hǎo,hào
世：shì
界：jiè
杯：bēi
世界：shì,jiè
你好：nǐ,hǎo
苦尽甘来：kǔ,jìn,gān,lái
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.letiantian.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="http://www.letiantian.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从零开始Docker化Ghost博客系统</title>
    <link href="http://www.letiantian.me/2015-12-06-docker-ghost/"/>
    <id>http://www.letiantian.me/2015-12-06-docker-ghost/</id>
    <published>2015-12-06T04:10:39.000Z</published>
    <updated>2015-12-07T08:45:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-12-06</p>
<p><a href="https://ghost.org/" target="_blank" rel="external">Ghost</a>是一基于node的博客系统，速度快，够简洁。</p>
<p>注意Ghost支持的Node的版本：</p>
<pre><code>$ node index.js 
ERROR: Unsupported version of Node
Ghost needs Node version ~0.10.0 || ~0.12.0 you are using version 4.2.2
</code></pre><h2 id="将容器转化为镜像"><a href="#将容器转化为镜像" class="headerlink" title="将容器转化为镜像"></a>将容器转化为镜像</h2><p>这一节把node安装在/node下，把ghost安装在/ghost目录下。</p>
<a id="more"></a>
<h3 id="拉取一个镜像"><a href="#拉取一个镜像" class="headerlink" title="拉取一个镜像"></a>拉取一个镜像</h3><pre><code class="plain">$ sudo docker pull ubuntu:14.04
</code></pre>
<p>使用<code>sudo docker images</code>查看本机有哪些容器。如果一个镜像有多个标签，则会显示多个。</p>
<h3 id="启动一个容器"><a href="#启动一个容器" class="headerlink" title="启动一个容器"></a>启动一个容器</h3><p>例如：</p>
<pre><code class="plain">$ sudo docker run -ti ubuntu:14.04 /bin/bash
root@5989ceee9a40:/# uname -a
Linux 5989ceee9a40 3.16.0-38-generic #52~14.04.1-Ubuntu SMP Fri May 8 09:43:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux
</code></pre>
<p>可以在宿主机上运行<code>sudo docker ps</code>查看有哪些容器正在运行。</p>
<h3 id="安装curl等"><a href="#安装curl等" class="headerlink" title="安装curl等"></a>安装curl等</h3><pre><code class="plain">root@5989ceee9a40:/# apt-get install -y curl
root@5989ceee9a40:/# apt-get install -y zip
</code></pre>
<h3 id="下载node"><a href="#下载node" class="headerlink" title="下载node"></a>下载node</h3><pre><code class="plain">root@5989ceee9a40:/node# curl -SLO https://nodejs.org/dist/v0.12.9/node-v0.12.9-linux-x64.tar.gz
root@5989ceee9a40:/node# tar -xzf node-v0.12.9-linux-x64.tar.gz
root@5989ceee9a40:/node# mv node-v0.12.9-linux-x64/* .
root@5989ceee9a40:/node# rm -rf node-v0.12.9-linux-x64
root@5989ceee9a40:/node# ls
ChangeLog  LICENSE  README.md  bin  etc  include  lib  node-v0.12.9-linux-x64.tar.gz  share
</code></pre>
<h3 id="下载ghost"><a href="#下载ghost" class="headerlink" title="下载ghost"></a>下载ghost</h3><pre><code class="plain">root@5989ceee9a40:/node# mkdir /ghost
root@5989ceee9a40:/node# cd /ghost/
root@5989ceee9a40:/ghost# curl -SLO https://ghost.org/zip/ghost-0.7.2.zip 
root@5989ceee9a40:/ghost# unzip ghost-0.7.2.zip
root@5989ceee9a40:/ghost# ls
Gruntfile.js  LICENSE  PRIVACY.md  README.md  config.example.js  config.js  content  core  ghost-0.7.2.zip  index.js  node_modules  npm-shrinkwrap.json  package.json
root@5989ceee9a40:/ghost# npm install -g npm@latest
root@5989ceee9a40:/ghost# npm install --production   # 比较耗时
root@5989ceee9a40:/ghost# sed &#39;s/127.0.0.1/0.0.0.0/&#39; config.example.js &gt; config.js
</code></pre>
<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><p>exit后会容器不再运行，通过下面方法重启容器：</p>
<pre><code class="plain">$ sudo docker start 5989ceee9a40
$ sudo docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
5989ceee9a40        ubuntu:14.04        &quot;/bin/bash&quot;              4 hours ago         Up 16 seconds                                desperate_dijkstra

$ sudo docker attach 5989ceee9a40
root@5989ceee9a40:/#
</code></pre>
<h3 id="将容器转换为镜像"><a href="#将容器转换为镜像" class="headerlink" title="将容器转换为镜像"></a>将容器转换为镜像</h3><p>commit的帮助文档如下：</p>
<pre><code class="plain">$ docker commit --help

Usage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]

Create a new image from a container&#39;s changes

  -a, --author=       Author (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;)
  -c, --change=[]     Apply Dockerfile instruction to the created image
  --help=false        Print usage
  -m, --message=      Commit message
  -p, --pause=true    Pause container during commit
</code></pre>
<p>在主机上，将刚才的容器转换为镜像：</p>
<pre><code class="plain">$ sudo docker commit -m &quot;ghost 0.7.2 on ubuntu&quot; -a &quot;letian&quot; 5989ceee9a40 letian/ghost:v1
33eb15dca18e4d7a77673b1a12282699a0dbaaa51c38f5db45d51ffbe77af08d

$ sudo docker images
REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
letian/ghost                       v1                  33eb15dca18e        4 minutes ago       457.5 MB
..........
</code></pre>
<p>个头有点大。。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>启动一个ghost服务：</p>
<pre><code class="plain">$ sudo docker run -d -p 8000:2368 letian/ghost:v1  /node/bin/node /ghost/index.js
88124fab0a0d43603ee50113a2380a5a22890d4040f27d144c412b4dedb66e7b

$ sudo docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
88124fab0a0d        letian/ghost:v1     &quot;/node/bin/node /ghos&quot;   38 seconds ago      Up 37 seconds       0.0.0.0:8000-&gt;2368/tcp   loving_colden
</code></pre>
<p>上面忘了把<code>NODE_ENV</code>设置为<code>production</code>了，加<code>-e</code>指定就行了：</p>
<pre><code class="plain">$ sudo docker run -d -e NODE_ENV=production -p 8008:2368 letian/ghost:v1  /node/bin/node /ghost/index.js
</code></pre>
<p>在宿主机上，用浏览器打开<code>http://&lt;your-ip&gt;:8008/</code>，可以查看ghost是否正常运行。</p>
<h2 id="使用Dockerfile构建镜像"><a href="#使用Dockerfile构建镜像" class="headerlink" title="使用Dockerfile构建镜像"></a>使用Dockerfile构建镜像</h2><p>现在我们尝试使用Dockerfile构建镜像。同时，为了解决上面遇到的<code>npm install</code>比较耗时的问题，将<a href="http://www.ghostchina.com/download/" target="_blank" rel="external">Ghost 中文集成版</a>直接作为文件添加进镜像。这个ghost中文集成版在汉化的基础上把所有的依赖都放进去了，所以不需要<code>npm install</code>。</p>
<p>创建目录ghost-0.7.0，其中的文件如下：</p>
<pre><code class="plain">$ ls
Dockerfile
Ghost-0.7.0-zh-full.zip
start.sh
</code></pre>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><pre><code class="plain">FROM ubuntu:14.04

ADD Ghost-0.7.0-zh-full.zip /tmp/Ghost-0.7.0-zh-full.zip
ADD start.sh /start-ghost.sh

ENV NODE_VERSION 0.12.9

RUN \
    apt-get update &amp;&amp; \
    apt-get install -y curl &amp;&amp; \
    apt-get install -y zip  &amp;&amp; \
    cd /tmp &amp;&amp; \
    curl -SLO &quot;https://nodejs.org/dist/v0.12.9/node-v$NODE_VERSION-linux-x64.tar.gz&quot;  &amp;&amp; \
    tar -xzf &quot;node-v$NODE_VERSION-linux-x64.tar.gz&quot; -C /usr/local --strip-components=1  &amp;&amp; \
    unzip Ghost-0.7.0-zh-full.zip -d /ghost &amp;&amp; \
    rm /tmp/Ghost-0.7.0-zh-full.zip &amp;&amp; \
    cd /ghost &amp;&amp; \
    sed &#39;s/127.0.0.1/0.0.0.0/&#39; config.example.js &gt; config.js

WORKDIR /ghost

CMD [&quot;bash&quot;, &quot;/start-ghost.sh&quot;]

EXPOSE 2368
</code></pre>
<p><code>Ghost-0.7.0-zh-full.zip</code>被放到<code>/tmp</code>目录，<code>start.sh</code>添加到<code>/start-ghost.sh</code>，创建容器时候会运行<code>bash /start-ghost.sh</code>。</p>
<h3 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h3><pre><code class="shell"># !/bin/bash

GHOST=&quot;/ghost&quot;

cd &quot;$GHOST&quot;

NODE_ENV=${NODE_ENV:-production} npm start
</code></pre>
<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><pre><code class="plain">$ cd ghost-0.7.0
$ sudo docker build -t letian/ghost:v2 .
</code></pre>
<h3 id="创建容器、测试"><a href="#创建容器、测试" class="headerlink" title="创建容器、测试"></a>创建容器、测试</h3><pre><code class="plain">$ sudo docker run -d -p 8080:2368 letian/ghost:v2
</code></pre>
<p>在宿主机上用浏览器打开<code>http://&lt;your-ip&gt;:8080/</code>，可以看到ghost正常运行。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>ghost的数据库和图片等最好是放在数据卷中（VOLUMN）。</p>
<h3 id="Dockerfile-1"><a href="#Dockerfile-1" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><pre><code class="plain">FROM ubuntu:14.04

ADD Ghost-0.7.0-zh-full.zip /tmp/Ghost-0.7.0-zh-full.zip
ADD start.sh /start-ghost.sh

ENV NODE_VERSION 0.12.9

RUN \
    apt-get update &amp;&amp; \
    apt-get install -y curl zip &amp;&amp; \
    cd /tmp &amp;&amp; \
    curl -SLO &quot;https://nodejs.org/dist/v0.12.9/node-v$NODE_VERSION-linux-x64.tar.gz&quot;  &amp;&amp; \
    tar -xzf &quot;node-v$NODE_VERSION-linux-x64.tar.gz&quot; -C /usr/local --strip-components=1  &amp;&amp; \
    unzip Ghost-0.7.0-zh-full.zip -d /ghost &amp;&amp; \
    rm /tmp/Ghost-0.7.0-zh-full.zip &amp;&amp; \
    cd /ghost &amp;&amp; \
    sed &#39;s/127.0.0.1/0.0.0.0/&#39; config.example.js &gt; config.js

VOLUME /ghost-external

WORKDIR /ghost

CMD [&quot;bash&quot;, &quot;/start-ghost.sh&quot;]

EXPOSE 2368
</code></pre>
<p>就是在之前的基础上加了行<code>VOLUME /ghost-external</code>。</p>
<h3 id="start-sh-1"><a href="#start-sh-1" class="headerlink" title="start.sh"></a>start.sh</h3><pre><code class="shell"># !/bin/bash

GHOST=&quot;/ghost&quot;
GHOST_EXTERNAL=&quot;/ghost-external&quot;

CONFIG=&quot;config.js&quot;
DATA=&quot;content/data&quot;
IMAGES=&quot;content/images&quot;
THEMES=&quot;content/themes&quot;

mkdir -p &quot;$GHOST_EXTERNAL/$DATA&quot;
rm -rf &quot;$GHOST/$DATA&quot;
ln -s &quot;$GHOST_EXTERNAL/$DATA&quot; &quot;$GHOST/$DATA&quot;

mkdir -p &quot;$GHOST_EXTERNAL/$IMAGES&quot;
rm -rf &quot;$GHOST/$IMAGES&quot;
ln -s &quot;$GHOST_EXTERNAL/$IMAGES&quot; &quot;$GHOST/$IMAGES&quot;

if [ -d &quot;$GHOST_EXTERNAL/$THEMES&quot; ]; then
    rm -rf &quot;$GHOST/$THEMES&quot;
    ln -s &quot;$GHOST_EXTERNAL/$THEMES&quot; &quot;$GHOST/$THEMES&quot; 
fi

if [ -f &quot;$GHOST_EXTERNAL/$CONFIG&quot; ]; then
    rm -f &quot;$GHOST/$CONFIG&quot;
    ln -s &quot;$GHOST_EXTERNAL/$CONFIG&quot; &quot;$GHOST/$CONFIG&quot;
fi

cd &quot;$GHOST&quot;

NODE_ENV=${NODE_ENV:-production} npm start
</code></pre>
<p>数据卷<code>/ghost-external</code>中的目录、文件被软链接到<code>/ghost</code>对应的位置上。</p>
<h3 id="构建镜像-1"><a href="#构建镜像-1" class="headerlink" title="构建镜像"></a>构建镜像</h3><pre><code class="plain">$ sudo docker build -t letian/ghost:v3 .
</code></pre>
<h3 id="创建容器、测试-1"><a href="#创建容器、测试-1" class="headerlink" title="创建容器、测试"></a>创建容器、测试</h3><p>创建容器，将宿主机目录挂载到数据卷：</p>
<pre><code class="plain">$ mkdir ~/local-ghost
$ sudo docker run -d -p 8090:2368 -v ~/local-ghost:/ghost-external letian/ghost:v3
</code></pre>
<p>在宿主机上用浏览器打开<code>http://&lt;your-ip&gt;:8090/</code>，可以看到ghost正常运行。<code>~/local-ghost</code>也有相应的文件、目录被创建。</p>
<h2 id="在云服务中构建镜像"><a href="#在云服务中构建镜像" class="headerlink" title="在云服务中构建镜像"></a>在云服务中构建镜像</h2><p>这里选择<a href="http://www.alauda.cn/" target="_blank" rel="external">灵雀云</a>构建镜像。</p>
<p>首先将Dockerfile等上传到Github（也可以是Git@OSC、BitBucket）中。</p>
<p>登录灵雀云，</p>
<p><img src="/content/images/2015/12/2015-12-06-docker-ghost-01.jpeg" alt=""></p>
<p>点击“创建构建镜像仓库”，授权读取Github中的repo，选择ghost对应的项目构建即可。</p>
<p>然后在“服务”中选择“创建服务”，会提示用户选择镜像，选择“我的镜像”中刚才构建好的docker-ghost，<br><img src="/content/images/2015/12/2015-12-06-docker-ghost-02.jpeg" alt=""></p>
<p>点击“配置镜像”后：<br><img src="/content/images/2015/12/2015-12-06-docker-ghost-03.jpeg" alt=""></p>
<p>填写指定服务名称，将服务类型改为“有状态服务”，然后进入“高级配置”：</p>
<p><img src="/content/images/2015/12/2015-12-06-docker-ghost-04.jpeg" alt=""></p>
<p>此处，需要指定存储卷大小，端口的服务地址类型需要配置成http-endpoint：</p>
<p><img src="/content/images/2015/12/2015-12-06-docker-ghost-05.jpeg" alt=""></p>
<p>然后创建服务，查看服务详情：</p>
<p><img src="/content/images/2015/12/2015-12-06-docker-ghost-06.jpeg" alt=""></p>
<p>浏览器打开红线处的URL就可以看到Ghost博客了。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><pre><code class="shell">ln -s from-file to-link-file
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/dockerfile/ghost" target="_blank" rel="external">dockerfile/ghost</a><br><a href="https://github.com/nodejs/docker-node" target="_blank" rel="external">nodejs/docker-node</a><br><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="external">Docker 技术入门与实战</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-12-06&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ghost.org/&quot;&gt;Ghost&lt;/a&gt;是一基于node的博客系统，速度快，够简洁。&lt;/p&gt;
&lt;p&gt;注意Ghost支持的Node的版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node index.js 
ERROR: Unsupported version of Node
Ghost needs Node version ~0.10.0 || ~0.12.0 you are using version 4.2.2
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;将容器转化为镜像&quot;&gt;&lt;a href=&quot;#将容器转化为镜像&quot; class=&quot;headerlink&quot; title=&quot;将容器转化为镜像&quot;&gt;&lt;/a&gt;将容器转化为镜像&lt;/h2&gt;&lt;p&gt;这一节把node安装在/node下，把ghost安装在/ghost目录下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="nodejs" scheme="http://www.letiantian.me/tags/nodejs/"/>
    
      <category term="docker" scheme="http://www.letiantian.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>n的解析</title>
    <link href="http://www.letiantian.me/2015-11-06-n/"/>
    <id>http://www.letiantian.me/2015-11-06-n/</id>
    <published>2015-11-06T08:58:55.000Z</published>
    <updated>2015-12-08T11:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-11-06</p>
<p>n是TJ大神为node设计的版本管理工具，使用shell编写，是用来学习和巩固shell的很不错的例子。</p>
<p>源码地址： <a href="https://github.com/tj/n" target="_blank" rel="external">https://github.com/tj/n</a></p>
<p>源码注释： <a href="https://github.com/letiantian/n-source" target="_blank" rel="external">https://github.com/letiantian/n-source</a></p>
<a id="more"></a>
<h2 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h2><h3 id="文件存放位置"><a href="#文件存放位置" class="headerlink" title="文件存放位置"></a>文件存放位置</h3><p>n会把下载的各个版本的node放到<code>/usr/local/n/versions/</code>目录中。当指定某个版本的node时，对应的node、npm命令会复制到<code>/usr/local/bin/</code>目录中，lib、include等文件也会复制到<code>/usr/local/</code>下对应的文件中。而全局安装的package会放到<code>/usr/local/lib/node_modules/</code>目录下。</p>
<p>node有一个基本目录，再这个基本目录下，各个文件的布局是固定的。查看基本目录：</p>
<pre><code>$ npm get prefix
/usr/local
</code></pre><h3 id="n的help"><a href="#n的help" class="headerlink" title="n的help"></a>n的help</h3><pre><code>$ n -h

  Usage: n [options/env] [COMMAND] [args]

  Environments:
    n [COMMAND] [args]            Uses default env (node)
    n io [COMMAND]                Sets env as io
    n project [COMMAND]           Uses custom env-variables to use non-official sources

  Commands:

    n                              Output versions installed
    n latest                       Install or activate the latest node release
    n -a x86 latest                As above but force 32 bit architecture
    n stable                       Install or activate the latest stable node release
    n &lt;version&gt;                    Install node &lt;version&gt;
    n use &lt;version&gt; [args ...]     Execute node &lt;version&gt; with [args ...]
    n bin &lt;version&gt;                Output bin path for &lt;version&gt;
    n rm &lt;version ...&gt;             Remove the given version(s)
    n --latest                     Output the latest node version available
    n --stable                     Output the latest stable node version available
    n ls                           Output the versions of node available

  (iojs):
    n io latest                    Install or activate the latest iojs release
    n io -a x86 latest             As above but force 32 bit architecture
    n io &lt;version&gt;                 Install iojs &lt;version&gt;
    n io use &lt;version&gt; [args ...]  Execute iojs &lt;version&gt; with [args ...]
    n io bin &lt;version&gt;             Output bin path for &lt;version&gt;
    n io rm &lt;version ...&gt;          Remove the given version(s)
    n io --latest                  Output the latest iojs version available
    n io ls                        Output the versions of iojs available

  Options:

    -V, --version   Output current version of n
    -h, --help      Display help information
    -q, --quiet     Disable curl output (if available)
    -d, --download  Download only
    -a, --arch      Override system architecture

  Aliases:

    which   bin
    use     as
    list    ls
    -       rm
</code></pre><h3 id="处理命令行参数"><a href="#处理命令行参数" class="headerlink" title="处理命令行参数"></a>处理命令行参数</h3><p>下面是n处理参数的代码：</p>
<pre><code class="shell">if test $# -eq 0; then    # 参数个数为0
  test -z &quot;$(versions_paths)&quot; &amp;&amp; err_no_installed_print_help   # versions_paths是函数
  display_versions
else
  while test $# -ne 0; do
    case $1 in
      -V|--version) display_n_version ;;    # display_n_version函数里有exit
      -h|--help|help) display_help; exit ;;
      -q|--quiet) set_quiet ;;
      -d|--download) ACTIVATE=false ;;
      --latest) display_latest_version; exit ;;
      --stable) display_latest_stable_version; exit ;;
      io) set_default $1 ;; # set bin and continue
      project) DEFAULT=2 ;;
      -a|--arch) shift; set_arch $1;; # set arch and continue
      bin|which) display_bin_path_for_version $2; exit ;;
      as|use) shift; execute_with_version $@; exit ;;
      rm|-) shift; remove_versions $@; exit ;;
      latest) install_latest; exit ;;
      stable) install_stable; exit ;;
      ls|list) display_remote_versions; exit ;;
      *) install $1; exit ;;
    esac
    shift
  done
fi
</code></pre>
<p><code>$#</code>是参数数量，<code>$@</code>是参数列表。</p>
<p>如果运行n时，没有给出任何参数，n要尝试显示当前已经安装的所有版本的node。如果没有安装任何node，则报错，并退出程序。如果有若干版本，则全屏显示，可以用上下方向键选择某一版本，回车后该版本的node生效。</p>
<p>假如第一个参数为<code>-V</code>，<code>case</code>代码块中匹配<code>-V后</code>会去执行<code>display_n_version</code>函数，然后break（即<code>;;</code>）。出了<code>case</code>代码块，通过<code>shift</code>从参数列表从删除位于第一个位置的参数<code>-V</code>，然后继续处理其他参数。</p>
<p>假如现在第一个参数是<code>io</code>，则意味着要处理的不是默认的node，而是iojs，<code>set_default io</code>会将这一设置放入脚本的全局变量<code>DEFAULT</code>中，之后安装、删除等操作都是针对iojs的。<strong>为方便介绍，下文中都不考虑io这一情况。</strong></p>
<p>假如现在第一个参数是<code>which</code>，则第2个参数应该是版本号，n会调用display_bin_path_for_version函数将该版本号的node的路径输出：</p>
<pre><code class="plain">$ n bin 4.2.2
/usr/local/n/versions/node/4.2.2/bin/node 
$ n bin 4.2.3

  Error: 4.2.3 is not installed
</code></pre>
<p>输出后程序结束。</p>
<p>假如现在第一个参数是<code>use</code>，则下一个参数应该是版本号，此时会执行指定版本号的node或者iojs：</p>
<pre><code class="plain">$ n use 4.2.2
&gt; 1+1
2
</code></pre>
<p>然后退出程序。</p>
<p>假如现在第一个参数是<code>ls</code>，<code>DEFAULT</code>仍然指向默认的node，<code>display_remote_versions</code>函数会被调用，该函数拉取<code>https://nodejs.org/dist/</code>的网页源码，把所有的版本信息提取出来并输出，其中本地安装的版本和正在使用的版本的字体颜色会不一样。然后，程序退出。</p>
<p>假如现在第一个参数与给定的那些关键字都不同，则认为是一个版本号，n应该尝试去安装它。</p>
<h3 id="查找指定的主、次版本号的对应的最新版本"><a href="#查找指定的主、次版本号的对应的最新版本" class="headerlink" title="查找指定的主、次版本号的对应的最新版本"></a>查找指定的主、次版本号的对应的最新版本</h3><p>node的安装文件是在<code>https://nodejs.org/dist/</code>下载的。假如现在我们要查找<code>4.2</code>的最新版本，过程如下：</p>
<p>1、获取<code>https://nodejs.org/dist/</code>网页源码：<br>可以用curl或者wget，这里用curl。  </p>
<pre><code class="plain">$ curl -s https://nodejs.org/dist/
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Index of /dist/&lt;/title&gt;&lt;/head&gt;
&lt;body bgcolor=&quot;white&quot;&gt;
&lt;h1&gt;Index of /dist/&lt;/h1&gt;&lt;hr&gt;

&lt;a href=&quot;latest/&quot;&gt;latest/&lt;/a&gt;                                            29-Oct-2015 21
:04                   -
...........省略.........
&lt;a href=&quot;v0.10.2/&quot;&gt;v0.10.2/&lt;/a&gt;                                           03-Apr-2013 0
5:01                   -
&lt;a href=&quot;v0.10.20/&quot;&gt;v0.10.20/&lt;/a&gt;                                          09-Oct-2013 
17:25                   -
...........省略.........   
&lt;hr&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>2、提取所有的链接<br>使用<code>egrep</code>命令将所有含链接的行提取出来。</p>
<pre><code class="plain">$ curl -s https://nodejs.org/dist/ | egrep &#39;&lt;/a&gt;&#39;
...........省略.........
&lt;a href=&quot;v0.9.9/&quot;&gt;v0.9.9/&lt;/a&gt;                                            14-Oct-2015 10:38                   -
&lt;a href=&quot;v4.0.0/&quot;&gt;v4.0.0/&lt;/a&gt;                                            08-Sep-2015 22:08                   -
...........省略.........
</code></pre>
<p><code>egrep</code>就是<code>grep -E</code>。</p>
<p>3、把每一行的版本号提取出来<br>继续用<code>egrep</code>把所有版本号提取出来。</p>
<pre><code class="plain">$ curl -s https://nodejs.org/dist/ | egrep &#39;&lt;/a&gt;&#39; | egrep -o &#39;[0-9]+\.[0-9]+\.[0-9]+&#39;
...........省略.........
0.8.3
0.8.4
0.8.4
0.8.5
...........省略.........
0.9.9
4.0.0                  -
...........省略.........
</code></pre>
<p>4、去除0.0~0.7、0.8.0~0.8.5这些版本</p>
<pre><code class="plain">$ curl -s https://nodejs.org/dist/ | egrep &#39;&lt;/a&gt;&#39; | egrep -o &#39;[0-9]+\.[0-9]+\.[0-9]+&#39; | egrep -v &#39;^0\.[0-7]\.&#39; | egrep -v &#39;^0\.8\.[0-5]$&#39;
</code></pre>
<p>5、去重，排序<br>使用<code>sort</code>命令对版本号去重、排序。</p>
<pre><code class="plain">$ curl -s https://nodejs.org/dist/ | egrep &#39;&lt;/a&gt;&#39; | egrep -o &#39;[0-9]+\.[0-9]+\.[0-9]+&#39; | egrep -v &#39;^0\.[0-7]\.&#39; | egrep -v &#39;^0\.8\.[0-5]$&#39; | sort -u -k 1,1n -k 2,2n -k 3,3n -t .
</code></pre>
<p>6、找到以<code>4.2</code>开头的所有版本</p>
<pre><code class="plain">$ curl -s https://nodejs.org/dist/ | egrep &#39;&lt;/a&gt;&#39; | egrep -o &#39;[0-9]+\.[0-9]+\.[0-9]+&#39; | egrep -v &#39;^0\.[0-7]\.&#39; | egrep -v &#39;^0\.8\.[0-5]$&#39; | sort -u -k 1,1n -k 2,2n -k 3,3n -t . | egrep &quot;^4.2&quot;
4.2.0
4.2.1
4.2.2
</code></pre>
<p>7、使用tail得到最新的版本号</p>
<pre><code>$ curl -s https://nodejs.org/dist/ | egrep &#39;&lt;/a&gt;&#39; | egrep -o &#39;[0-9]+\.[0-9]+\.[0-9]+&#39; | egrep -v &#39;^0\.[0-7]\.&#39; | egrep -v &#39;^0\.8\.[0-5]$&#39; | sort -u -k 1,1n -k 2,2n -k 3,3n -t . | egrep &quot;^4.2&quot; | tail -n 1
4.2.2
</code></pre><p>8、把以上命令转换成shell脚本</p>
<pre><code class="shell"># !/usr/bin/env bash
prefix=4.2
version=$(curl -s https://nodejs.org/dist/ 2&gt; /dev/null \
      | egrep &quot;&lt;/a&gt;&quot; \
      | egrep -o &#39;[0-9]+\.[0-9]+\.[0-9]+&#39; \
      | egrep -v &#39;^0\.[0-7]\.&#39; \
      | egrep -v &#39;^0\.8\.[0-5]$&#39; \
      | sort -u -k 1,1n -k 2,2n -k 3,3n -t . \
      | egrep ^$prefix \
      | tail -n1)
echo $version
</code></pre>
<h3 id="安装某一版本"><a href="#安装某一版本" class="headerlink" title="安装某一版本"></a>安装某一版本</h3><p>安装某一版本时，调用的是install函数，参数是版本号。</p>
<p>主要流程如下：</p>
<ol>
<li>如果版本号只给出了主、次版本，没有给修订版本，则拉取最新的修订版本号。</li>
<li>若该版本对应的目录存在，且目录下没有<code>n.lock</code>文件（有则意味着正在被其他运行的n安装），意味着该版本已经被安装，根据其他条件判断是否激活该版本，然后退出。</li>
<li>生成该版本对应的安装文件的url，判断该url是否有效（返回200），无效则退出。</li>
<li>创建该版本对应的目录，并在该目录下创建文件<code>n.lock</code>，代表正在安装。下载文件，解压到该目录。</li>
<li>删除<code>n.lock</code>，安装完成。</li>
<li>根据其他条件判断是否激活该版本，然后退出。</li>
</ol>
<p>这里非常有意思的是用<code>n.lock</code>代表安装状态。</p>
<h3 id="如何进入全屏、退出全屏"><a href="#如何进入全屏、退出全屏" class="headerlink" title="如何进入全屏、退出全屏"></a>如何进入全屏、退出全屏</h3><p>下面的例子可以用来理解如何进入全屏、退出全屏：</p>
<pre><code class="shell"># !/usr/bin/env bash
enter_fullscreen() {
  tput smcup    # Save the display
  stty -echo    # 不回显输入的字符
}

leave_fullscreen() {
  tput rmcup    # Restore the display
  stty echo     # 回显输入的字符
}

enter_fullscreen
echo &quot;已经进入全屏&quot;
sleep 12

leave_fullscreen
</code></pre>
<h3 id="捕捉方向键"><a href="#捕捉方向键" class="headerlink" title="捕捉方向键"></a>捕捉方向键</h3><p>方向键对应长度为3的特殊字符，可以在<a href="https://www.gnu.org/software/screen/manual/html_node/Input-Translation.html" target="_blank" rel="external">Input Translation</a>找到这些按键的字符标识。</p>
<p>下面是一个示例：</p>
<pre><code># !/usr/bin/env bash
while true; do
    read -n 3 c   # 读取3个字符放入变量c中
    case &quot;$c&quot; in
      $&#39;\033[A&#39;)
        echo &quot;上方向键&quot;
        ;;        # 相当于break
      $&#39;\033[B&#39;)      # 下方向键
        echo &quot;下方向键&quot;
        ;;
      $&#39;\033[D&#39;)      # 下方向键
        echo &quot;左方向键&quot;
        ;;
      $&#39;\033[C&#39;)      # 下方向键
        echo &quot;右方向键&quot;
        ;;
      *)          # 默认
        echo $c   # 如果直接回车，$c是空字符串
        echo &quot;退出程序&quot;
        exit
        ;;
    esac
done
</code></pre><p>如何退出上面的程序呢？<br>方法1是按回车键。<br>方法2是依次按三个数字或者字母或者其他字符，只要达到三个，就会退出。  </p>
<p>一个小问题，<strong>回车键如何捕捉</strong>，见下面的代码：</p>
<pre><code class="shell"># !/usr/bin/env bash
while true; do
    read -n 3 c  
    case &quot;$c&quot; in
      &quot;&quot;)
        printf &quot;\t enter \n&quot;
        ;;        
      *)
        exit
        ;;
    esac
done
</code></pre>
<h3 id="如何激活某个版本的node"><a href="#如何激活某个版本的node" class="headerlink" title="如何激活某个版本的node"></a>如何激活某个版本的node</h3><p>这里的“激活”就是指将某一版本的node、npm等文件从<code>/usr/local/n/versions/</code>拷贝到<code>/usr/local/bin</code>，其他的相关文件也拷贝到对应目录的动作。</p>
<p>在n中，该功能由<code>display_versions</code>函数实现。</p>
<p>在终端输入n，回车后会进入全屏：<br><img src="/content/images/2015/11/2015-11-06-n-02.png" alt=""></p>
<p>此时，通过执行<code>check_current_version</code>函数得到当前使用的node版本，通过<code>versions_paths</code>函数得到本机安装的所有node版本，并排序。<code>display_versions_with_selected</code>函数用来显示本机所有的node版本，并高亮目前在使用的版本。</p>
<p>然后在一个while循环里监视键盘的输入，如果是上方向键或者下方向键选择其他的版本，就清屏，用<code>display_versions_with_selected</code>函数用来显示本机所有的node版本，并高亮目前选择的版本。</p>
<p>如果输入的是其他字符，则激活当前选中的版本，退出程序。</p>
<h3 id="删除某个版本的node"><a href="#删除某个版本的node" class="headerlink" title="删除某个版本的node"></a>删除某个版本的node</h3><p>删除操作由<code>remove_versions</code>函数实现。思路很简单，如果要删除的版本和当前在使用的版本不一致，则直接在<code>/usr/local/n/versions/</code>目录中删除对应版本的整个目录；若一致，则不删除。</p>
<p><code>remove_versions</code>函数可以接受多个版本号作为参数。</p>
<h3 id="隐藏-显示光标、删除当前行"><a href="#隐藏-显示光标、删除当前行" class="headerlink" title="隐藏/显示光标、删除当前行"></a>隐藏/显示光标、删除当前行</h3><p>先看下面的示例：<br><img src="/content/images/2015/11/2015-11-06-n-03.gif" alt=""></p>
<p>（如何制作gif图片，可以参考<a href="http://www.letiantian.me/2015-11-06-linux-gif/">Linux下GIF制作指南</a>）</p>
<p>代码为：</p>
<pre><code class="shell"># !/usr/bin/env bash
hide_cursor() {
  printf &quot;\e[?25l&quot;
}

show_cursor() {
  printf &quot;\e[?25h&quot;
}

erase_line() {
  printf &quot;\033[1A\033[2K&quot;
}

hide_cursor
echo &quot;hide_cursor&quot;

sleep 4
erase_line

show_cursor
echo &quot;show_cursor&quot;

sleep 4
erase_line
</code></pre>
<p>这里面就是特殊控制字符的使用。在<code>erase_line</code>函数中，<code>033</code>是八进制，十进制值是27，在ASCII表中代表特殊字符ESC (escape)，转义的意思。 <code>\033[1A</code>是将光标移动到前一行, <code>\033[2K</code>是清除光标所在行。</p>
<p>资料：<br><a href="http://wiki.bash-hackers.org/scripting/terminalcodes" target="_blank" rel="external">Terminal codes (ANSI/VT100) introduction</a><br><a href="http://stackoverflow.com/questions/15011478/ansi-questions-x1b25h-and-x1be" target="_blank" rel="external">ANSI questions: “… x1B ..?25h” and … x1BE”</a><br><a href="https://en.wikipedia.org/wiki/ANSI_escape_code" target="_blank" rel="external">ANSI escape code</a><br><a href="http://stackoverflow.com/questions/9134638/using-read-without-triggering-a-newline-action-on-terminal" target="_blank" rel="external">Using read without triggering a newline action on terminal</a>  </p>
<h2 id="n的Makefile"><a href="#n的Makefile" class="headerlink" title="n的Makefile"></a>n的Makefile</h2><p>下面是n的Makefile：</p>
<pre><code class="plain">PREFIX ?= /usr/local

install: bin/n
    mkdir -p $(PREFIX)/$(dir $&lt;)
    cp $&lt; $(PREFIX)/$&lt;

uninstall:
    rm -f $(PREFIX)/bin/n

.PHONY: install uninstall
</code></pre>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p><code>?=</code>是赋值操作符，如果PREFIX已经有值就仍为原值，否则就用<code>/usr/local</code>。 </p>
<p>关于赋值，可以参考<a href="">Makefile 中:= ?= += =的区别</a></p>
<h3 id="dir命令"><a href="#dir命令" class="headerlink" title="dir命令"></a>dir命令</h3><p>dir用于列出目录中内容，例如：</p>
<pre><code class="plain">$ dir /usr/
bin  games  include  lib  local  NX  sbin  share  src
$ dir /etc/passwd
/etc/passwd
</code></pre>
<p>不过在Makefile里，<code>$(dir path/to/file)</code>是用来获取目录的。这个可以参考<a href="https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html" target="_blank" rel="external">8.3 Functions for File Names</a>。  </p>
<p>例如下面的Makefile：</p>
<pre><code class="plain">test: 
    echo $(dir /etc/hosts)
    $(dir /etc/hosts)
</code></pre>
<p>执行结果如下：</p>
<pre><code>$ make test 
echo /etc/
/etc/
/etc/
make: execvp: /etc/: Permission denied
make: *** [test] Error 127
</code></pre><p>上面报了一个<code>Permission denied</code>的错误，这是因为make尝试将<code>/etc/</code>当作可执行命令去执行了。</p>
<h3 id="文件依赖"><a href="#文件依赖" class="headerlink" title="文件依赖"></a>文件依赖</h3><p>举个例子，有的makefile可能有类似下面的内容：</p>
<pre><code class="plain">prog1: prog1.o utils.o
    cc -o prog1 prog1.o utils.o
</code></pre>
<p>这是在告诉make，目标文件prog1的生成依赖于prog1.o、utils.o。若依赖文件有缺失，会报错。</p>
<h3 id="lt-、-、"><a href="#lt-、-、" class="headerlink" title="$&lt;、$@、$^"></a>$&lt;、$@、$^</h3><p><code>$@</code>：目标文件<br><code>$^</code>：所有的依赖文件<br><code>$&lt;</code>：第一个依赖文件  </p>
<p>下面举个例子：</p>
<p>新建一个Makefile文件，内容如下（注意要用tab进行缩进）：</p>
<pre><code class="plain">prog1: prog1.o utils.o
    echo $@
    echo $^
    echo $&lt;
</code></pre>
<p>执行make：</p>
<pre><code class="plain">$ make prog1 
make: *** No rule to make target `prog1.o&#39;, needed by `prog1&#39;.  Stop.
</code></pre>
<p>为了快速解决这个报错，我们伪造两个<code>.o</code>格式的文件：</p>
<pre><code class="plain">$ touch prog1.o
$ touch utils.o
</code></pre>
<p>现在运行make：</p>
<pre><code class="plain">$ make prog1 
echo prog1
prog1
echo prog1.o utils.o
prog1.o utils.o
echo prog1.o
prog1.o
</code></pre>
<h3 id="PHONY"><a href="#PHONY" class="headerlink" title=".PHONY"></a>.PHONY</h3><p>PHONY的含义是：假的、伪造的。用来说明哪些文件是假的，例如n的Makefile中目标文件install、uninstall就是假的。</p>
<h3 id="默认操作"><a href="#默认操作" class="headerlink" title="默认操作"></a>默认操作</h3><p>定义目标文件all即可。</p>
<p>例如Makefile内容如下：</p>
<pre><code class="plain">prog1: prog1.o utils.o
    echo $@
    echo $^
    echo $&lt;

all: prog1
</code></pre>
<p>运行结果：</p>
<pre><code class="plain">$ make
echo prog1
prog1
echo prog1.o utils.o
prog1.o utils.o
echo prog1.o
prog1.o
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://blog.csdn.net/guodongxiaren/article/details/39544805" target="_blank" rel="external">玩转Bash脚本：特殊变量</a><br><a href="http://blog.sina.com.cn/s/blog_64e166580100vwk2.html" target="_blank" rel="external">shell编程——if语句 if -z -n -f -eq -ne -lt</a><br><a href="http://www.cnblogs.com/fhefh/archive/2011/04/15/2017613.html" target="_blank" rel="external">linux中shell变量$#,$@,$0,$1,$2的含义解释</a><br><a href="http://rosettacode.org/wiki/Terminal_control/Preserve_screen#UNIX_Shell" target="_blank" rel="external">Terminal control/Preserve screen</a><br><a href="http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x329.html" target="_blank" rel="external">ANSI Escape Sequences: Colours and Cursor Movement</a><br><strong><a href="http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/index.html" target="_blank" rel="external">Bash Prompt HOWTO</a></strong><br><a href="http://blog.csdn.net/zhuce0001/article/details/35840257" target="_blank" rel="external">shell中${ } 的一些特异功能</a>  </p>
<h2 id="细碎的知识点"><a href="#细碎的知识点" class="headerlink" title="细碎的知识点"></a>细碎的知识点</h2><p>以下是我阅读n源码时候整理的细碎的知识点，与n的设计无关。</p>
<h3 id=""><a href="#" class="headerlink" title="$#"></a><code>$#</code></h3><p>作用：获取参数个数。<br>示例：</p>
<pre><code class="sh"># !/usr/bin/env bash
echo $#
</code></pre>
<p>用例：  </p>
<pre><code class="sh">$ bash mytest.sh 
0
$ bash mytest.sh foo
1
$ bash mytest.sh foo bar
2
</code></pre>
<h3 id="var-value"><a href="#var-value" class="headerlink" title="${var-value}"></a>${var-value}</h3><p>value作为默认值。如果$var是空值，那么使用value。</p>
<p>示例：</p>
<pre><code class="shelll"># !/usr/bin/env bash
N_PREFIX=${N_PREFIX-/usr/local}
echo $N_PREFIX
</code></pre>
<p>用例：</p>
<pre><code class="plain">$ bash mytest.sh 
/usr/local
$ N_PREFIX=/usr bash mytest.sh 
/usr
</code></pre>
<h3 id="与"><a href="#与" class="headerlink" title="$* 与 $@"></a>$* 与 $@</h3><blockquote>
<p>通配符*将所有参数视作一个变量，而@则可以理解为所有参数的集合。</p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><a href="http://www.cnblogs.com/chengmo/archive/2010/09/30/1839632.html" target="_blank" rel="external">linux shell 数组建立及使用技巧</a><br><a href="http://my.oschina.net/ylchou/blog/486753" target="_blank" rel="external">Linux Shell数组和关联数组</a>  </p>
<p>示例：</p>
<pre><code class="shell"># !/usr/bin/env bash
BINS=(&quot;node&quot;
      &quot;io&quot;)

echo $BINS          # 输出node
echo ${BINS[*]}     # 输出node io
echo ${BINS[0]}     # 输出node
echo ${BINS[1]}     # 输出io
echo ${#BINS[*]}    # 输出2, 数组长度

# 遍历，依次输出node，io
for var in ${BINS[*]}
do
    echo $var
done
</code></pre>
<p>运行结果：</p>
<pre><code class="plain">$ bash mytest.sh 
node
node io
node
io
2
node
io
</code></pre>
<h3 id="判断语句中的-n，-z"><a href="#判断语句中的-n，-z" class="headerlink" title="判断语句中的-n，-z"></a>判断语句中的-n，-z</h3><p><code>if [ -n $string ]</code>：如果string 非空(非0），返回0(true)。<br><code>if [ -z $string ]</code>：如果string 为空。</p>
<p>示例：</p>
<pre><code class="shell"># !/usr/bin/env bash
BINS=(&quot;node&quot;
      &quot;io&quot;)

echo &quot;PROJECT_NAME： $PROJECT_NAME&quot;
echo &quot;PROJECT_URL： $PROJECT_URL&quot;

if [ -n &quot;$PROJECT_NAME&quot; ]; then     # 如果不为空
  BINS+=($PROJECT_NAME)             # 数组中追加元素
  if [ -z &quot;$PROJECT_URL&quot; ]; then    # 如果为空
    echo &quot;Must specify PROJECT_URL when supplying PROJECT_NAME&quot;
  fi
fi

echo ${BINS[*]}                      # 输出数组中所有元素
</code></pre>
<p>输出：</p>
<pre><code class="plain">$ bash mytest.sh 
PROJECT_NAME： 
PROJECT_URL： 
node io

$ PROJECT_NAME=&quot;dev&quot; bash mytest.sh 
PROJECT_NAME： dev
PROJECT_URL： 
Must specify PROJECT_URL when supplying PROJECT_NAME
node io dev

$ PROJECT_NAME=&quot;dev&quot; PROJECT_URL=&quot;urlllll&quot; bash mytest.sh 
PROJECT_NAME： dev
PROJECT_URL： urlllll
node io dev
</code></pre>
<h3 id="curl命令的若干参数"><a href="#curl命令的若干参数" class="headerlink" title="curl命令的若干参数"></a>curl命令的若干参数</h3><p><code>-#</code>： 用于显示进度条。</p>
<p><code>-L</code>： 用于跳转。如果访问的网页响应3××，则去请求新的网址。</p>
<p><code>-s</code>：–silent，即quiet。</p>
<h3 id="wget命令的参数"><a href="#wget命令的参数" class="headerlink" title="wget命令的参数"></a>wget命令的参数</h3><p><code>--no-check-certificate</code>： 不校验证书。<br><code>-q</code>： quiet，关掉wget的输出。<br><code>-O</code>： 指定获取的数据存放的位置。</p>
<p>下面的命令是将数据存放在baidu.html这个文件中：</p>
<pre><code>$ wget http://www.baidu.com -O baidu.html
--2015-11-05 10:44:45--  http://www.baidu.com/
Resolving www.baidu.com (www.baidu.com)... 119.75.218.70, 119.75.217.109
Connecting to www.baidu.com (www.baidu.com)|119.75.218.70|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 761
Saving to: ‘baidu.html’
....
</code></pre><p>下面的命令是将数据输出到终端：</p>
<pre><code>$ wget http://www.baidu.com -O-
--2015-11-05 10:45:58--  http://www.baidu.com/
Resolving www.baidu.com (www.baidu.com)... 119.75.218.70, 119.75.217.109
Connecting to www.baidu.com (www.baidu.com)|119.75.218.70|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 761
Saving to: ‘STDOUT’
....
</code></pre><p>去掉多余的信息，将数据输出到终端：</p>
<pre><code>$ wget http://www.baidu.com -O- -q
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot;&gt;var u=&#39;https://www.baidu.com/?tn=91055223_hao_pg&amp;rsr=5&#39;,ua=navigator.userAgent.toLowerCase();if(u.indexOf(&#39;baidu.com&#39;)&gt;0||u.indexOf(&#39;360.cn&#39;)&gt;0||u.indexOf(&#39;hao123.com&#39;)&gt;0){var cc = document.cookie.split(&#39;;&#39;);for(var i=0;i&lt;cc.length;i++){var name = cc[i].split(&quot;=&quot;)[0];document.cookie = name + &#39;=; path=/; domain=.baidu.com; expires=Thu, 01 Jan 1970 00:00:01 GMT;&#39;;}}if(ua.indexOf(&#39;applewebkit&#39;)&gt;0){var h = document.createElement(&#39;a&#39;);h.rel = &#39;noreferrer&#39;;h.href = u;document.body.appendChild(h);var evt = document.createEvent(&quot;MouseEvents&quot;);evt.initEvent(&quot;click&quot;, true, true);h.dispatchEvent(evt);} else {document.write(&#39;&lt;meta http-equiv=&quot;Refresh&quot; Content=&quot;0; Url=&#39; + u + &#39;&quot; &gt;&#39;);}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;
</code></pre><h3 id="command命令"><a href="#command命令" class="headerlink" title="command命令"></a>command命令</h3><pre><code class="plain">$ command -v wget
/usr/bin/wget
$ command -v wget &gt;/dev/null
$ command -v wget &amp;&amp; echo &quot;has wget&quot;
/usr/bin/wget
has wget
$ command -v wget &gt;/dev/null &amp;&amp; echo &quot;has wget&quot;
has wget
</code></pre>
<h3 id="脚本的参数"><a href="#脚本的参数" class="headerlink" title="脚本的参数"></a>脚本的参数</h3><p>示例：</p>
<pre><code># !/usr/bin/env bash
echo &quot;脚本名：$0&quot;
echo &quot;参数个数：$#&quot;
echo &quot;所有参数：$@&quot;
echo &quot;第1个参数：$1&quot;
echo &quot;第2个参数：$2&quot;
</code></pre><p>用例：</p>
<pre><code class="plain">$ bash mytest.sh 
脚本名：mytest.sh
参数个数：0
所有参数：
第1个参数：
第2个参数：

$ bash mytest.sh --name=letian -q
脚本名：mytest.sh
参数个数：2
所有参数：--name=letian -q
第1个参数：--name=letian
第2个参数：-q
</code></pre>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>示例：</p>
<pre><code class="plain"># !/usr/bin/env bash

function foo() {
    echo &quot;脚本名：$0&quot;
    echo &quot;参数个数：$#&quot;
    echo &quot;所有参数：$@&quot;
    echo &quot;第1个参数：$1&quot;
    echo &quot;第2个参数：$2&quot;
}

foo
echo # 添加空行
foo --name=letian -q
</code></pre>
<p>关键字<code>function</code>可以省略。</p>
<p>运行结果：</p>
<pre><code>脚本名：mytest.sh
参数个数：0
所有参数：
第1个参数：
第2个参数：

脚本名：mytest.sh
参数个数：2
所有参数：--name=letian -q
第1个参数：--name=letian
第2个参数：-q
</code></pre><h3 id="前一命令的退出码"><a href="#前一命令的退出码" class="headerlink" title="前一命令的退出码$?"></a>前一命令的退出码$?</h3><p>编写mytest.sh：</p>
<pre><code># !/usr/bin/env bash
exit 1
</code></pre><p>测试：</p>
<pre><code>$ bash mytest.sh
$ echo $?
1
</code></pre><p>0代表正常退出。</p>
<h3 id="-1"><a href="#-1" class="headerlink" title="$$"></a>$$</h3><p><code>$$</code>是当前进程的pid。<br>示例：</p>
<pre><code>$ echo $$
7662
</code></pre><h3 id="tput命令"><a href="#tput命令" class="headerlink" title="tput命令"></a>tput命令</h3><p><a href="http://blog.csdn.net/fdipzone/article/details/9993961" target="_blank" rel="external">tput 命令行使用说明</a><br><strong><a href="http://rosettacode.org/wiki/Terminal_control/Preserve_screen" target="_blank" rel="external">Terminal control/Preserve screen</a></strong>  </p>
<p>关于smcup、rmcup，可以在终端中依次输入下面的命令看看效果：</p>
<pre><code>tput smcup    # Save the display
echo &#39;Hello&#39;
tput rmcup    # Restore the display
</code></pre><h3 id="将命令执行的结果放入一个变量中"><a href="#将命令执行的结果放入一个变量中" class="headerlink" title="将命令执行的结果放入一个变量中"></a>将命令执行的结果放入一个变量中</h3><p>有两种方法，一个是<code>$()</code>，另外一种是是用反引号```。<br>示例：</p>
<pre><code>$ result=$(ls)
$ echo $result
baidu.html mytest.sh
$ result=&quot;$(ls)&quot;
$ echo $result
baidu.html mytest.sh
$ result=`ls`
$ echo $result
baidu.html mytest.sh
</code></pre><h3 id="node命令直接执行字符串中的nodejs代码"><a href="#node命令直接执行字符串中的nodejs代码" class="headerlink" title="node命令直接执行字符串中的nodejs代码"></a>node命令直接执行字符串中的nodejs代码</h3><pre><code>$ node -p &quot;1+1;&quot;
2
$ node -p &quot;console.log(1+1);&quot;
2
undefined
</code></pre><h3 id="grep命令的-A、-B参数"><a href="#grep命令的-A、-B参数" class="headerlink" title="grep命令的-A、-B参数"></a>grep命令的-A、-B参数</h3><p><img src="/content/images/2015/11/2015-11-06-n-01.png" alt=""></p>
<h3 id="关于函数中变量的取值范围"><a href="#关于函数中变量的取值范围" class="headerlink" title="关于函数中变量的取值范围"></a>关于函数中变量的取值范围</h3><p>要函数中定义的变量只在函数中有效，需要使用local关键字。<br>示例：</p>
<pre><code class="shell"># !/usr/bin/env bash
foo() {
    bar=&quot;hi&quot;
    local var=&quot;hello&quot;
}

foo
echo &quot;$bar&quot;     # 输出hi
echo &quot;$var&quot;     # 输出空字符
</code></pre>
<h3 id="键盘中特殊键与字符的对应"><a href="#键盘中特殊键与字符的对应" class="headerlink" title="键盘中特殊键与字符的对应"></a>键盘中特殊键与字符的对应</h3><p>上方向键与<code>\033[A</code>对应，下方向键与<code>\033[B</code>对应。更多见<a href="https://www.gnu.org/software/screen/manual/html_node/Input-Translation.html" target="_blank" rel="external">Input Translation</a>。  </p>
<p>这些字符的长度为3：</p>
<pre><code class="plain">$ char=$&#39;\033[A&#39;; echo ${#char}
3
</code></pre>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>示例1：  </p>
<pre><code class="shell"># !/usr/bin/env bash
for subdir in bin lib include share; do
    echo $subdir
done
</code></pre>
<p>输出：</p>
<pre><code class="plain">bin
lib
include
share
</code></pre>
<h3 id="关于Pax"><a href="#关于Pax" class="headerlink" title="关于Pax"></a>关于Pax</h3><p><a href="https://en.wikipedia.org/wiki/PaX" target="_blank" rel="external">PaX - Wikipedia</a><br><a href="https://pax.grsecurity.net/docs/mprotect.txt" target="_blank" rel="external">MPROTECT</a>  </p>
<h3 id="字符串中字符的替换"><a href="#字符串中字符的替换" class="headerlink" title="字符串中字符的替换"></a>字符串中字符的替换</h3><p>示例：</p>
<pre><code class="shell"># !/usr/bin/env bash
version=4.2.2
echo ${version//./ }   # 将.替换为空格

version=v4.2.2
echo ${version//./--}  # 将.替换为--
</code></pre>
<p>运行结果：</p>
<pre><code>4 2 2
v4--2--2
</code></pre><h3 id="提取字符串中数字"><a href="#提取字符串中数字" class="headerlink" title="提取字符串中数字"></a>提取字符串中数字</h3><p>示例：</p>
<pre><code class="shell"># !/usr/bin/env bash
semver=&quot;004 2 2&quot;
echo $semver | grep -o -E &#39;[0-9]+&#39;  # 分行输出004、2、1
echo $semver | grep -o -E &#39;[0-9]+&#39; | head -1  # 输出004
echo $semver | grep -o -E &#39;[0-9]+&#39;  | head -1 | sed -e &#39;s/^0\+//&#39;   # 输出4
echo $semver | awk &#39;{print $2}&#39;     # 输出2
</code></pre>
<p>grep的<code>-o</code>是指只输出匹配的部分，<code>-E</code>指扩展的正则表达式。<br>head -1是把第一行提取出来。<br><code>sed -e &#39;s/^0\+//&#39;</code>是把最前面的0替换为空。  </p>
<h3 id="使用shift删除指定数量的参数"><a href="#使用shift删除指定数量的参数" class="headerlink" title="使用shift删除指定数量的参数"></a>使用shift删除指定数量的参数</h3><p>shift命令用于删除参数列表中的前若干个参数，默认是1,也可以指定数量。</p>
<p>示例：</p>
<pre><code class="shell"># !/usr/bin/env bash
foo() {
    echo $@
    shift 
    echo $@
    shift 3
    echo $@
}

foo 1 2 3 4 5 6
</code></pre>
<p>运行结果：</p>
<pre><code>1 2 3 4 5 6
2 3 4 5 6
5 6
</code></pre><h3 id="字体颜色配置"><a href="#字体颜色配置" class="headerlink" title="字体颜色配置"></a>字体颜色配置</h3><p>我们在设置PS1变量的时候常常与颜色打交道。使用printf、echo命令时也可以设置字体颜色，例如：  </p>
<p><img src="/content/images/2015/11/2015-11-06-n-04.png" alt=""></p>
<p><code>033</code>是八进制，十进制值是27，在ASCII表中代表特殊字符ESC (escape)，转义的意思。36m对应的颜色是Cyan，，91m对应的颜色是red，0m的作用是重置。</p>
<p>资料：<br><a href="http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x329.html" target="_blank" rel="external">Chapter 6. ANSI Escape Sequences: Colours and Cursor Movement</a><br><a href="https://wiki.archlinux.org/index.php/Color_Bash_Prompt" target="_blank" rel="external">Color Bash Prompt - ArchLinux</a><br>[What does a bash sequence ‘\033<a href="http://unix.stackexchange.com/questions/116243/what-does-a-bash-sequence-033999d-mean-and-where-is-it-explained" target="_blank" rel="external">999D’ mean and where is it explained?</a><br><a href="http://mediadoneright.com/content/ultimate-git-ps1-bash-prompt" target="_blank" rel="external">Ultimate GIT PS1 bash prompt</a>  </p>
<h3 id="sort命令"><a href="#sort命令" class="headerlink" title="sort命令"></a>sort命令</h3><p><code>-k</code>参数的解释：</p>
<blockquote>
<p>-k, –key=POS1[,POS2]  start a key at POS1 (origin 1), end it at POS2(default end of line)</p>
</blockquote>
<p>position是从1开始的。</p>
<p>示例1：</p>
<pre><code class="shell"># !/usr/bin/env bash
cat &lt;&lt;EOF | sort -k 1 -t ,
4,23,12
3,26,1
4,4,16
5,4,4
5,0,4
EOF
</code></pre>
<p>运行结果：</p>
<pre><code>3,26,1
4,23,12
4,4,16
5,0,4
5,4,4
</code></pre><p>示例2：</p>
<pre><code># !/usr/bin/env bash
cat &lt;&lt;EOF | sort -k 1,1 -t ,
4,23,12
3,26,1
4,4,16
5,4,4
5,0,4
EOF
</code></pre><p>运行结果：</p>
<pre><code>3,26,1
4,23,12
4,4,16
5,0,4
5,4,4
</code></pre><p>从第2、3行可以看到，23&lt;4，这是按照字符串来比较的。</p>
<p>示例3：</p>
<pre><code># !/usr/bin/env bash
cat &lt;&lt;EOF | sort -k 1,2n -t ,
4,23,12
3,26,1
4,4,16
5,4,4
5,0,4
EOF
</code></pre><p><code>1,2n</code>是指将第1个和第2个字段放在一起，当作数字来排序，n就numeric sort。<br>所以运行结果是：</p>
<pre><code>4,4,16
5,0,4
5,4,4
3,26,1
4,23,12
</code></pre><p>示例4：</p>
<pre><code class="shell"># !/usr/bin/env bash
cat &lt;&lt;EOF | sort -k 1,1n -k 2,2n -t ,
4,23,12
3,26,1
4,4,16
5,4,4
5,0,4
EOF
</code></pre>
<p>运行结果：</p>
<pre><code>3,26,1
4,4,16
4,23,12
5,0,4
5,4,4
</code></pre><p>资料：<br><a href="http://man.linuxde.net/sort" target="_blank" rel="external">sort命令</a><br><a href="http://yejinxin.github.io/linux-sort-command-usage/" target="_blank" rel="external">Linux中sort命令用法</a><br><a href="http://unix.stackexchange.com/questions/52762/trying-to-sort-on-two-fields-second-then-first" target="_blank" rel="external">Trying to sort on two fields, second then first</a><br><a href="http://stackoverflow.com/questions/357560/sorting-multiple-keys-with-unix-sort" target="_blank" rel="external">Sorting multiple keys with Unix sort</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-11-06&lt;/p&gt;
&lt;p&gt;n是TJ大神为node设计的版本管理工具，使用shell编写，是用来学习和巩固shell的很不错的例子。&lt;/p&gt;
&lt;p&gt;源码地址： &lt;a href=&quot;https://github.com/tj/n&quot;&gt;https://github.com/tj/n&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码注释： &lt;a href=&quot;https://github.com/letiantian/n-source&quot;&gt;https://github.com/letiantian/n-source&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="http://www.letiantian.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux下GIF制作指南</title>
    <link href="http://www.letiantian.me/2015-11-06-linux-gif/"/>
    <id>http://www.letiantian.me/2015-11-06-linux-gif/</id>
    <published>2015-11-06T08:53:59.000Z</published>
    <updated>2015-11-06T09:00:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-11-06</p>
<p>样图：<br><img src="/content/images/2015/11/2015-11-06-n-03.gif" alt=""></p>
<h2 id="安装桌面录制工具"><a href="#安装桌面录制工具" class="headerlink" title="安装桌面录制工具"></a>安装桌面录制工具</h2><p>这些工具有：Record my desktop、Kazam、Vokoscreen等。</p>
<p>Record my desktop生成ogv格式，Kazam生成Mp4格式。</p>
<p>Kazam更好用，还可以用来截屏。</p>
<p>安装Kazam：</p>
<pre><code>sudo apt-get install kazam
</code></pre><h2 id="安装mplayer、ffmpeg（或者avconv）、convert等工具"><a href="#安装mplayer、ffmpeg（或者avconv）、convert等工具" class="headerlink" title="安装mplayer、ffmpeg（或者avconv）、convert等工具"></a>安装mplayer、ffmpeg（或者avconv）、convert等工具</h2><pre><code>sudo apt-get install mplayer imagemagick libav-tools
</code></pre><h2 id="从视频中提取图片"><a href="#从视频中提取图片" class="headerlink" title="从视频中提取图片"></a>从视频中提取图片</h2><p>例如将output.mp4提取图片放入output目录：</p>
<pre><code>mplayer -ao null input.mp4 -vo jpeg:outdir=output
</code></pre><p>也可以用avconv/ffmpeg命令：</p>
<pre><code> avconv -i input.mp4 -r 1 output/%04d.jpg
</code></pre><p><code>-r 1</code>是指每秒提取1帧。</p>
<p>这些命令可以对视频进行更加细致的操作，可以参考stackoverflow中的讨论：<br><a href="http://superuser.com/questions/135117/how-to-convert-video-to-images" target="_blank" rel="external">How to convert video to images?</a><br><a href="http://unix.stackexchange.com/questions/185877/how-to-extract-images-from-video-file" target="_blank" rel="external">How to extract images from video file?</a>  </p>
<h2 id="由多张图片生成gif"><a href="#由多张图片生成gif" class="headerlink" title="由多张图片生成gif"></a>由多张图片生成gif</h2><pre><code>convert output/* output.gif
</code></pre><p>可以用<code>-delay</code>指定两张图片之间的延时。  </p>
<pre><code>convert -delay 100 output/* output.gif
</code></pre><p>可以使用下面的方法优化output.gif文件的体积：</p>
<pre><code>convert output.gif -fuzz 20% -layers optimize optimised.gif
</code></pre><p><code>fuzz</code>，模糊的意思，这个参数的说明如下：</p>
<pre><code>-fuzz distance       colors within this distance are considered equal
</code></pre><p>在<a href="http://www.imagemagick.org/Usage/bugs/fuzz_distance/" target="_blank" rel="external">Fuzz Distance and Transparent Colors</a>有参数值的解释。黑与白之间的距离是100%。fuzz应该是针对每个颜色通道的。</p>
<p><code>-layers</code>的解释见<a href="http://www.imagemagick.org/script/command-line-options.php?#layers" target="_blank" rel="external">http://www.imagemagick.org/script/command-line-options.php?#layers</a>。  </p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>一个比较实用的方案是使用<a href="http://www.cockos.com/licecap/" target="_blank" rel="external">LICEcap</a>，不过需要在wine中安装。</p>
<p><a href="https://procedural.github.io/post/GifRecorder/" target="_blank" rel="external">https://procedural.github.io/post/GifRecorder/</a> 看起来也不错。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://apps.ubuntu.com/cat/applications/gtk-recordmydesktop/" target="_blank" rel="external">recordMyDesktop </a><br><a href="http://hackerspace.kinja.com/screen-recording-in-linux-1686055808" target="_blank" rel="external">Top 4 screen recorders in Linux</a><br><a href="http://askubuntu.com/questions/432542/is-ffmpeg-missing-from-the-official-repositories-in-14-04" target="_blank" rel="external">Is FFmpeg missing from the official repositories in 14.04?</a><br><a href="http://askubuntu.com/questions/107726/how-to-create-animated-gif-images-of-a-screencast" target="_blank" rel="external">How to create animated GIF images of a screencast?</a><br><a href="http://unix.stackexchange.com/questions/35282/convert-ogv-video-to-gif-animation" target="_blank" rel="external">Convert Ogv -video to Gif -animation?</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-11-06&lt;/p&gt;
&lt;p&gt;样图：&lt;br&gt;&lt;img src=&quot;/content/images/2015/11/2015-11-06-n-03.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装桌面录制工具&quot;&gt;&lt;a href=&quot;#安装桌面录制工具&quot; class=&quot;
    
    </summary>
    
    
      <category term="linux" scheme="http://www.letiantian.me/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>如何使用redis构建异步任务处理程序</title>
    <link href="http://www.letiantian.me/2015-11-03-redis-async-task/"/>
    <id>http://www.letiantian.me/2015-11-03-redis-async-task/</id>
    <published>2015-11-03T13:57:24.000Z</published>
    <updated>2015-11-04T13:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-11-03</p>
<p>如果一些任务没必要马上知道结果，可以将其放入队列中，让后台处理程序去处理，这同时也达到了异步的效果。本文围绕python的rq模块，介绍如何使用redis构建异步任务处理程序。</p>
<p>rq官方地址：  <a href="http://python-rq.org/" target="_blank" rel="external">http://python-rq.org/</a><br>Github：    <a href="https://github.com/nvie/rq" target="_blank" rel="external">https://github.com/nvie/rq</a> </p>
<p>本文分为以下几个部分：  </p>
<ul>
<li>如何安装rq</li>
<li>命令行工具的实现</li>
<li>rq如何在redis中存储数据</li>
<li>rq的设计思路</li>
<li>关于rq的源码</li>
<li>python、redis基础</li>
</ul>
<a id="more"></a>
<h2 id="如何安装rq"><a href="#如何安装rq" class="headerlink" title="如何安装rq"></a>如何安装rq</h2><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><p>解压源码，将<code>rq</code>的目录放在PYTHONPATH变量里。然后：</p>
<pre><code class="shell">export PYTHONPATH=$PYTHONPATH:/home/letian/Desktop/rq/
</code></pre>
<h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><pre><code class="plain">$ sudo python setup.py install
</code></pre>
<h3 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h3><p>该方法是将rq安装到当前用户目录，我也是采用的该方法：</p>
<pre><code class="plain">$ python setup.py install --user
...
Installed /home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg
Processing dependencies for rq==0.5.6
...
</code></pre>
<p>另外，rq会在<code>$HOME/.local/bin</code>安装几个命令行工具(rq、rqinfo、rqworker)，所以需要：</p>
<pre><code class="plain">$ export PATH=$PATH:$HOME/.local/bin
</code></pre>
<p>注意，rq对click包有依赖，如果安装rq时出现问题，可以先安装<a href="https://github.com/mitsuhiko/click" target="_blank" rel="external">click</a>。  </p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://docs.python.org/2/install/" target="_blank" rel="external">Installing Python Modules</a><br><a href="http://scicomp.stackexchange.com/questions/2987/what-is-the-simplest-way-to-do-a-user-local-install-of-a-python-package" target="_blank" rel="external">What is the simplest way to do a user-local install of a python package?</a><br><a href="http://stackoverflow.com/questions/7465445/how-to-install-python-modules-without-root-access" target="_blank" rel="external">How to install python modules without root access?</a>  </p>
<h2 id="命令行工具的实现"><a href="#命令行工具的实现" class="headerlink" title="命令行工具的实现"></a>命令行工具的实现</h2><p>我们看一下命令行工具的实现：</p>
<p>首先rq源码中的setup.py中有以下内容：</p>
<pre><code class="json">entry_points={
    &#39;console_scripts&#39;: [
        &#39;rq = rq.cli:main&#39;,

        # NOTE: rqworker/rqinfo are kept for backward-compatibility,
        # remove eventually (TODO)
        &#39;rqinfo = rq.cli:info&#39;,
        &#39;rqworker = rq.cli:worker&#39;,
    ],
},
</code></pre>
<p>很容易看懂，rq就是执行rq.cli模块下main函数，另外两个类似。</p>
<p>查看rqworker的代码：</p>
<pre><code class="plain">$ cd ~/.local/bin
letian@myhost:~/.local/bin

$ cat rqworker 
# !/usr/bin/python
# EASY-INSTALL-ENTRY-SCRIPT: &#39;rq==0.5.6&#39;,&#39;console_scripts&#39;,&#39;rqworker&#39;
__requires__ = &#39;rq==0.5.6&#39;
import sys
from pkg_resources import load_entry_point

if __name__ == &#39;__main__&#39;:
    sys.exit(
        load_entry_point(&#39;rq==0.5.6&#39;, &#39;console_scripts&#39;, &#39;rqworker&#39;)()
    )
</code></pre>
<p>其中<code>rq=0.5.6</code>代表着包<code>site-packages/rq-0.5.6-py2.7.egg</code>，在这里，实际位置是<code>~/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg</code>。进入该目录，查看<code>EGG-INFO/entry_points.txt</code>的内容：</p>
<pre><code class="plain">$ cat EGG-INFO/entry_points.txt 
[console_scripts]
rq = rq.cli:main
rqinfo = rq.cli:info
rqworker = rq.cli:worker
</code></pre>
<p>相关资料：<br><a href="http://www.cnblogs.com/babykick/archive/2012/03/09/2387808.html" target="_blank" rel="external">pkg_resources—-Entry Points为程序提供扩展点</a><br><a href="https://pythonhosted.org/setuptools/pkg_resources.html" target="_blank" rel="external">Package Discovery and Resource Access using pkg_resources</a>  </p>
<h2 id="rq如何在redis中存储数据"><a href="#rq如何在redis中存储数据" class="headerlink" title="rq如何在redis中存储数据"></a>rq如何在redis中存储数据</h2><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>按照<a href="http://python-rq.org/" target="_blank" rel="external">rq官网</a>给的例子写代码：</p>
<p>建立项目目录<code>python-code</code>和文件，结构如下：</p>
<pre><code class="plain">$ tree python-code/
python-code/
├── my_module.py
└── test.py
</code></pre>
<p><code>my_module.py</code>内容如下：</p>
<pre><code class="py">import requests

def count_words_at_url(url):
    resp = requests.get(url)
    return len(resp.text.split())
</code></pre>
<p><code>test.py</code>内容如下：</p>
<pre><code class="py">from redis import Redis
from rq import Queue
from my_module import count_words_at_url

q = Queue(connection=Redis())
result = q.enqueue(count_words_at_url, &#39;http://www.baidu.com&#39;)
print result
</code></pre>
<p>执行<code>test.py</code>，</p>
<pre><code class="plain">$ python test.py 
&lt;Job ca82af29-5744-4d62-afe0-3cba45b2d31d: my_module.count_words_at_url(&#39;http://www.baidu.com&#39;)&gt;
</code></pre>
<h3 id="查看redis"><a href="#查看redis" class="headerlink" title="查看redis"></a>查看redis</h3><p>现在看下redis：</p>
<pre><code class="plain">$ redis-cli 
127.0.0.1:6379&gt; KEYS *
1) &quot;rq:job:ca82af29-5744-4d62-afe0-3cba45b2d31d&quot;
2) &quot;rq:queue:default&quot;
3) &quot;rq:queues&quot;
</code></pre>
<p>出现三个键值对。</p>
<p>看看<code>rq:queues</code>有什么：  </p>
<pre><code class="plain">127.0.0.1:6379&gt; TYPE rq:queues
set
127.0.0.1:6379&gt; SMEMBERS rq:queues
1) &quot;rq:queue:default&quot;
</code></pre>
<p><code>rq:queues</code>是一个集合，保存着有哪些队列。</p>
<p><code>rq:queue:default</code>就是当一个队列来用了：</p>
<pre><code class="plain">127.0.0.1:6379&gt; TYPE rq:queue:default
list
127.0.0.1:6379&gt; LRANGE rq:queue:default 0 12
1) &quot;ca82af29-5744-4d62-afe0-3cba45b2d31d&quot;
</code></pre>
<p>default队列中有一个任务，任务的标识是<code>ca82af29-5744-4d62-afe0-3cba45b2d31d</code>，这正好和<code>rq:job:ca82af29-5744-4d62-afe0-3cba45b2d31d</code>对应。</p>
<p>接着看看这个job里有什么：</p>
<pre><code class="plain">127.0.0.1:6379&gt; TYPE rq:job:ca82af29-5744-4d62-afe0-3cba45b2d31d
hash
127.0.0.1:6379&gt; HGETALL rq:job:ca82af29-5744-4d62-afe0-3cba45b2d31d
 1) &quot;origin&quot;
 2) &quot;default&quot;
 3) &quot;status&quot;
 4) &quot;queued&quot;
 5) &quot;created_at&quot;
 6) &quot;2015-11-03T02:42:35Z&quot;
 7) &quot;enqueued_at&quot;
 8) &quot;2015-11-03T02:42:35Z&quot;
 9) &quot;data&quot;
10) &quot;\x80\x02(X\x1c\x00\x00\x00my_module.count_words_at_urlq\x01NU\x14http://www.baidu.comq\x02\x85q\x03}q\x04tq\x05.&quot;
11) &quot;description&quot;
12) &quot;my_module.count_words_at_url(&#39;http://www.baidu.com&#39;)&quot;
13) &quot;timeout&quot;
14) &quot;180&quot;
</code></pre>
<p>这个job的信息是以hash形式存储的，奇数行是key，偶数是value。我们看下data的内容：</p>
<pre><code class="plain">$ ipython
&gt;&gt;&gt; aa
&#39;\x80\x02(X\x1c\x00\x00\x00my_module.count_words_at_urlq\x01NU\x14http://www.baidu.comq\x02\x85q\x03}q\x04tq\x05.&#39;
&gt;&gt;&gt; import pickle
&gt;&gt;&gt; pickle.loads(aa)
(u&#39;my_module.count_words_at_url&#39;, None, (&#39;http://www.baidu.com&#39;,), {})
</code></pre>
<h3 id="不在项目目录中执行rqworker"><a href="#不在项目目录中执行rqworker" class="headerlink" title="不在项目目录中执行rqworker"></a>不在项目目录中执行rqworker</h3><pre><code class="plain">$ rqworker 
13:38:17 RQ worker u&#39;rq:worker:myhost.10179&#39; started, version 0.5.6
13:38:17 
13:38:17 *** Listening on default...
13:38:17 default: my_module.count_words_at_url(&#39;http://www.baidu.com&#39;) (ca82af29-5744-4d62-afe0-3cba45b2d31d)
13:38:17 ImportError: No module named my_module
Traceback (most recent call last):
  File &quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/worker.py&quot;, line 568, in perform_job
    rv = job.perform()
  File &quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/job.py&quot;, line 495, in perform
    self._result = self.func(*self.args, **self.kwargs)
  File &quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/job.py&quot;, line 206, in func
    return import_attribute(self.func_name)
  File &quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/utils.py&quot;, line 150, in import_attribute
    module = importlib.import_module(module_name)
  File &quot;/usr/lib/python2.7/importlib/__init__.py&quot;, line 37, in import_module
    __import__(name)
ImportError: No module named my_module
Traceback (most recent call last):
  File &quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/worker.py&quot;, line 568, in perform_job
    rv = job.perform()
  File &quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/job.py&quot;, line 495, in perform
    self._result = self.func(*self.args, **self.kwargs)
  File &quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/job.py&quot;, line 206, in func
    return import_attribute(self.func_name)
  File &quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/utils.py&quot;, line 150, in import_attribute
    module = importlib.import_module(module_name)
  File &quot;/usr/lib/python2.7/importlib/__init__.py&quot;, line 37, in import_module
    __import__(name)
ImportError: No module named my_module
13:38:17 Moving job to u&#39;failed&#39; queue
13:38:17 
13:38:17 *** Listening on default...
</code></pre>
<p>执行失败，因为<code>No module named my_module</code>。</p>
<p>注意，<code>rqworker</code>输出的第一行中<code>rq:worker:myhost.10179</code>是该worker的标识。</p>
<p>我们看一下redis中内容的变化：</p>
<pre><code class="plain">127.0.0.1:6379&gt; KEYS *
1) &quot;rq:queue:failed&quot;
2) &quot;rq:workers&quot;
3) &quot;rq:queues&quot;
4) &quot;rq:job:ca82af29-5744-4d62-afe0-3cba45b2d31d&quot;
5) &quot;rq:worker:myhost.10179&quot;
</code></pre>
<p>新增加了一个<code>rq:queue:failed</code>队列，<code>rq:workers</code>集合。</p>
<p>查看<code>rq:job:ca82af29-5744-4d62-afe0-3cba45b2d31d</code>的变化：</p>
<pre><code class="plain">127.0.0.1:6379&gt; HGETALL rq:job:ca82af29-5744-4d62-afe0-3cba45b2d31d
 1) &quot;ttl&quot;
 2) &quot;-1&quot;
 3) &quot;created_at&quot;
 4) &quot;2015-11-03T02:42:35Z&quot;
 5) &quot;ended_at&quot;
 6) &quot;2015-11-03T05:38:17Z&quot;
 7) &quot;origin&quot;
 8) &quot;default&quot;
 9) &quot;enqueued_at&quot;
10) &quot;2015-11-03T02:42:35Z&quot;
11) &quot;exc_info&quot;
12) &quot;Traceback (most recent call last):\n  File \&quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/worker.py\&quot;, line 568, in perform_job\n    rv = job.perform()\n  File \&quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/job.py\&quot;, line 495, in perform\n    self._result = self.func(*self.args, **self.kwargs)\n  File \&quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/job.py\&quot;, line 206, in func\n    return import_attribute(self.func_name)\n  File \&quot;/home/letian/.local/lib/python2.7/site-packages/rq-0.5.6-py2.7.egg/rq/utils.py\&quot;, line 150, in import_attribute\n    module = importlib.import_module(module_name)\n  File \&quot;/usr/lib/python2.7/importlib/__init__.py\&quot;, line 37, in import_module\n    __import__(name)\nImportError: No module named my_module\n&quot;
13) &quot;data&quot;
14) &quot;\x80\x02(X\x1c\x00\x00\x00my_module.count_words_at_urlq\x01NU\x14http://www.baidu.comq\x02\x85q\x03}q\x04tq\x05.&quot;
15) &quot;description&quot;
16) &quot;my_module.count_words_at_url(&#39;http://www.baidu.com&#39;)&quot;
17) &quot;timeout&quot;
18) &quot;180&quot;
19) &quot;status&quot;
20) &quot;failed&quot;
</code></pre>
<p>可以看到出现了新的键值对，例如<code>ended_at</code>、<code>exc_info</code>。<code>status</code>的值也发生了变化：由<code>queued</code>变成了<code>failed</code>。</p>
<p>查看<code>rq:workers</code>中的内容：  </p>
<pre><code class="plain">127.0.0.1:6379&gt; TYPE rq:workers
set
127.0.0.1:6379&gt; SMEMBERS rq:workers
1) &quot;rq:worker:myhost.10179&quot;
</code></pre>
<p>有一个worker，其中myhost是hostname，10179是该worker的pid，查看其信息：</p>
<pre><code class="plain">127.0.0.1:6379&gt; TYPE rq:worker:myhost.10179
hash

127.0.0.1:6379&gt; HGETALL rq:worker:myhost.10179
1) &quot;birth&quot;
2) &quot;2015-11-03T05:38:17Z&quot;
3) &quot;queues&quot;
4) &quot;default&quot;
5) &quot;state&quot;
6) &quot;idle&quot;
7) &quot;current_job&quot;
8) &quot;ca82af29-5744-4d62-afe0
</code></pre>
<p>查看队列<code>rq:queue:default</code>中的内容：</p>
<pre><code class="plain">127.0.0.1:6379&gt; LRANGE rq:queue:default 0 12
(empty list or set)
</code></pre>
<p>查看队列<code>rq:queue:failed</code>中的内容：</p>
<pre><code>127.0.0.1:6379&gt; LRANGE rq:queue:failed 0 12
1) &quot;ca82af29-5744-4d62-afe0-3cba45b2d31d&quot;
</code></pre><h3 id="应该这样执行"><a href="#应该这样执行" class="headerlink" title="应该这样执行"></a>应该这样执行</h3><p>把上面运行的rqworker停掉，清空redis：</p>
<pre><code class="plain">127.0.0.1:6379&gt; FLUSHALL
OK
</code></pre>
<p>重新在redis中添加job：</p>
<pre><code class="plain">$ python test.py 
&lt;Job 4122eed3-d521-4738-8cf6-20d9501d0ab0: my_module.count_words_at_url(&#39;http://www.baidu.com&#39;)&gt;
</code></pre>
<p>然后，<strong>在项目目录下执行rqworker</strong>：</p>
<pre><code class="plain">$ rqworker 
20:17:21 RQ worker u&#39;rq:worker:myhost.27283&#39; started, version 0.5.6
20:17:21 
20:17:21 *** Listening on default...
20:17:21 default: my_module.count_words_at_url(&#39;http://www.baidu.com&#39;) (4122eed3-d521-4738-8cf6-20d9501d0ab0)
20:17:22 Job OK
</code></pre>
<p>查看redis：</p>
<pre><code class="plain"># rqworker运行之前
127.0.0.1:6379&gt; KEYS *
1) &quot;rq:job:4122eed3-d521-4738-8cf6-20d9501d0ab0&quot;
2) &quot;rq:queue:default&quot;
3) &quot;rq:queues&quot;

# rqworker运行之后
127.0.0.1:6379&gt; KEYS *
1) &quot;rq:worker:myhost.27283&quot;
2) &quot;rq:workers&quot;
3) &quot;rq:finished:default&quot;
4) &quot;rq:queues&quot;
5) &quot;rq:job:4122eed3-d521-4738-8cf6-20d9501d0ab0&quot;

127.0.0.1:6379&gt; HGETALL rq:job:4122eed3-d521-4738-8cf6-20d9501d0ab0
 1) &quot;ttl&quot;
 2) &quot;-1&quot;
 3) &quot;created_at&quot;
 4) &quot;2015-11-03T12:17:12Z&quot;
 5) &quot;ended_at&quot;
 6) &quot;2015-11-03T12:17:22Z&quot;
 7) &quot;origin&quot;
 8) &quot;default&quot;
 9) &quot;enqueued_at&quot;
10) &quot;2015-11-03T12:17:12Z&quot;
11) &quot;result&quot;
12) &quot;\x80\x02K-.&quot;
13) &quot;data&quot;
14) &quot;\x80\x02(X\x1c\x00\x00\x00my_module.count_words_at_urlq\x01NU\x14http://www.baidu.comq\x02\x85q\x03}q\x04tq\x05.&quot;
15) &quot;timeout&quot;
16) &quot;180&quot;
17) &quot;description&quot;
18) &quot;my_module.count_words_at_url(&#39;http://www.baidu.com&#39;)&quot;
19) &quot;status&quot;
20) &quot;finished&quot;

# zset是有序集合
127.0.0.1:6379&gt; TYPE rq:finished:default
zset

127.0.0.1:6379&gt; ZRANGE rq:finished:default 0 -1
1) &quot;4122eed3-d521-4738-8cf6-20d9501d0ab0&quot;
</code></pre>
<p>可以看到job的<code>status</code>是<code>finished</code>；<code>result</code>是<code>\x80\x02K-.</code>，用pickle处理这个值：</p>
<pre><code class="plain">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; pickle.loads(&quot;\x80\x02K-.&quot;)
45
</code></pre>
<p>注意，可以同时执行多个<code>rqworker</code>。</p>
<h2 id="rq的设计思路"><a href="#rq的设计思路" class="headerlink" title="rq的设计思路"></a>rq的设计思路</h2><h3 id="redis中如何存储一个job"><a href="#redis中如何存储一个job" class="headerlink" title="redis中如何存储一个job"></a>redis中如何存储一个job</h3><p>一个job，在这里就是一个函数或者可执行对象。</p>
<p>job的id由uuid模块生成，加上固定前缀<code>rq:job:</code>，作为该job在redis中的key。value是hash类型，同样以键值对保存该job的信息。一个job的信息包括：入队时间，job使用的函数（或者可执行对象）本身的名称、所属的module名称，函数（或者可执行对象）的参数，状态（排队中、完成、失败等），执行结果等。这些信息有些是直接保存，有些用pickle模块处理之后才保存。</p>
<h3 id="如何将job添加到队列"><a href="#如何将job添加到队列" class="headerlink" title="如何将job添加到队列"></a>如何将job添加到队列</h3><p>假设待处理job队列只有一个，即默认的<code>rq:queue:default</code>，这个队列名称同时也是它在redis中的键，对应的值是list类型，在这个list中记录job的id即可。</p>
<p>job如果执行失败，则将其记录到失败队列（即<code>rq:queue:failed</code>）中。如果执行成功，则记录到<code>rq:finished:default</code>对应的有序集合中。</p>
<h3 id="rqworker命令如何工作"><a href="#rqworker命令如何工作" class="headerlink" title="rqworker命令如何工作"></a>rqworker命令如何工作</h3><p>rqworker从给定的队列中取出一个job，提取job的信息，其中最重要的是：</p>
<ul>
<li>job使用的函数（或者可执行对象）所属的module名称</li>
<li>job使用的函数（或者可执行对象）本身的名称</li>
<li>job使用的函数（或者可执行对象）的参数</li>
</ul>
<p>job基本是我们自己写的，都是放在当前项目下的某个模块中，rqworker使用<code>importlib</code>库导入模块，使用<code>getattr</code>函数从模块中拿到job使用的函数（或者可执行对象），然后就可以执行任务了。也因为这个原因，rqworker命令需要在当前项目的目录中执行。</p>
<p>rqworker在处理完一个job后，将该job放入成功队列或者失败队列。</p>
<p>rqworker在执行job时候会fork一个子进程去处理job，但是父进程会等待子进程完成，所以认为rqworker是串行执行的。若要加快处理速度，可以执行多个rqworker。</p>
<p>如果要在多台主机上去处理一个任务队列执行rqworker，这些主机都应该部署项目源码。</p>
<h3 id="job依赖"><a href="#job依赖" class="headerlink" title="job依赖"></a>job依赖</h3><p>假设场景是job B需要在job A完成后再执行，那么：</p>
<ul>
<li>在job A中保存job B的的id，也就是在redis中保存依赖关系。</li>
<li>如果job A的状态是已经完成，那么直接把job B放入待处理任务队列。</li>
<li>如果job A的状态不是已经完成，把job B的状态设置为延迟（deferred）。</li>
<li>rqworker执行完job A后发现了job B对job A的依赖，将job B放入待处理队列。</li>
</ul>
<p>上面的部分操作在rq的实现中用到了redis事务。</p>
<h2 id="关于rq的源码"><a href="#关于rq的源码" class="headerlink" title="关于rq的源码"></a>关于rq的源码</h2><p>可以到github上下载rq的源码。源码中最主要的是三个文件：<code>queue.py</code>，<code>worker.py</code>，<code>job.py</code>。 如果要阅读，不建议从细节下手，建议由顶向下。<code>local.py</code>中的代码也很有趣。 我对部分代码做了注释，放在了 <a href="https://github.com/letiantian/rq-source" target="_blank" rel="external">https://github.com/letiantian/rq-source</a> 。 </p>
<h2 id="python、redis基础"><a href="#python、redis基础" class="headerlink" title="python、redis基础"></a>python、redis基础</h2><p>以下是阅读源码时候遇到的一些基本概念，很基础，但是我之前不了解/熟练。</p>
<h3 id="python操作redis"><a href="#python操作redis" class="headerlink" title="python操作redis"></a>python操作redis</h3><pre><code class="shell">$ sudo pip install redis
</code></pre>
<pre><code class="python">import redis
r = redis.StrictRedis(host=&#39;localhost&#39;, port=6379, db=0)
r.set(&#39;foo&#39;, &#39;bar&#39;)
r.get(&#39;foo&#39;)
</code></pre>
<p>示例2：</p>
<pre><code class="py">import redis
r = redis.StrictRedis(host=&#39;localhost&#39;, port=6300, db=0)
r.set(r, &#39;bar&#39;)
print r
print r.get(r)
</code></pre>
<p>运行结果输出：</p>
<pre><code>StrictRedis&lt;ConnectionPool&lt;Connection&lt;host=localhost,port=6300,db=0&gt;&gt;&gt;
bar
</code></pre><p>看下redis：</p>
<pre><code>$ redis-cli -h 127.0.0.1 -p 6300
127.0.0.1:6300&gt; KEYS *
1) &quot;StrictRedis&lt;ConnectionPool&lt;Connection&lt;host=localhost,port=6300,db=0&gt;&gt;&gt;&quot;
2) &quot;name&quot;
127.0.0.1:6300&gt; exit
</code></pre><h3 id="python-slots"><a href="#python-slots" class="headerlink" title="python __slots__"></a>python __slots__</h3><p>默认情况下每个类都会有一个dict,通过<strong>dict</strong>访问，这个dict维护了这个实例的所有属性。slots的作用是阻止在实例化类时为实例分配dict。具体见<a href="http://blog.csdn.net/tianqio/article/details/2374086" target="_blank" rel="external">http://blog.csdn.net/tianqio/article/details/2374086</a>。  </p>
<h3 id="python-thread下的get-ident-函数"><a href="#python-thread下的get-ident-函数" class="headerlink" title="python thread下的get_ident()函数"></a>python thread下的get_ident()函数</h3><p>返回当前线程的标识，是一个非0的整数。</p>
<blockquote>
<p>Return the ‘thread identifier’ of the current thread. This is a nonzero integer. Its value has no direct meaning; it is intended as a magic cookie to be used e.g. to index a dictionary of thread-specific data. Thread identifiers may be recycled when a thread exits and another thread is created.</p>
</blockquote>
<h3 id="python-property函数"><a href="#python-property函数" class="headerlink" title="python property函数"></a>python property函数</h3><p>摘自<a href="http://blog.csdn.net/yatere/article/details/6658457" target="_blank" rel="external">http://blog.csdn.net/yatere/article/details/6658457</a>。</p>
<p>就是为类定义一个属性。</p>
<pre><code class="python">class C(object):
    def __init__(self): self._x = None
    def getx(self): print &quot;get x&quot;;return self._x
    def setx(self, value): print &quot;set x&quot;; self._x = value
    def delx(self): print &quot;del x&quot;;del self._x
    x = property(getx, setx, delx, &quot;I&#39;m the &#39;x&#39; property.&quot;)
</code></pre>
<p>使用</p>
<pre><code class="plain">&gt;&gt;&gt; t=C()
&gt;&gt;&gt; t.x
get x
&gt;&gt;&gt; t.x=&quot;en&quot;
set x
&gt;&gt;&gt; print t.x
get x
en
&gt;&gt;&gt; del t.x
del x
&gt;&gt;&gt; t.x
get x
</code></pre>
<h3 id="python-property装饰器"><a href="#python-property装饰器" class="headerlink" title="python property装饰器"></a>python property装饰器</h3><pre><code class="py">class C(object):
    def __init__(self):
        self.__x = 10

    @property
    def x(self):
        return self.__x

if __name__ == &quot;__main__&quot;:
    c = C()
    print c.x   # 10
    c.x = 10    # 报错 AttributeError: can’t set attribute
</code></pre>
<h3 id="python-all函数的用法"><a href="#python-all函数的用法" class="headerlink" title="python all函数的用法"></a>python all函数的用法</h3><pre><code class="plain">&gt;&gt;&gt; print all.__doc__
all(iterable) -&gt; bool

Return True if bool(x) is True for all values x in the iterable.
If the iterable is empty, return True.
&gt;&gt;&gt; all([1==1, &#39;a&#39; != &#39;b&#39;])
True
</code></pre>
<h3 id="function模块下的partial函数"><a href="#function模块下的partial函数" class="headerlink" title="function模块下的partial函数"></a>function模块下的partial函数</h3><p><a href="https://docs.python.org/2/library/functools.html#functools.partial" target="_blank" rel="external">https://docs.python.org/2/library/functools.html#functools.partial</a>  </p>
<p>举个例子，先看一下int函数的用法：</p>
<pre><code class="plain">&gt;&gt;&gt; print int.__doc__
int(x=0) -&gt; int or long
int(x, base=10) -&gt; int or long

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is floating point, the conversion truncates towards zero.
If x is outside the integer range, the function returns a long instead.

If x is not a number or if base is given, then x must be a string or
Unicode object representing an integer literal in the given base.  The
literal can be preceded by &#39;+&#39; or &#39;-&#39; and be surrounded by whitespace.
The base defaults to 10.  Valid bases are 0 and 2-36.  Base 0 means to
interpret the base from the string as an integer literal.
&gt;&gt;&gt; int(&#39;0b100&#39;, base=0)
4
</code></pre>
<pre><code class="plain">&gt;&gt;&gt; from functools import partial
&gt;&gt;&gt; basetwo = partial(int, base=2)
&gt;&gt;&gt; basetwo.__doc__ = &#39;Convert base 2 string to an int.&#39;
&gt;&gt;&gt; basetwo(&#39;10010&#39;)
18
</code></pre>
<h3 id="function模块下的total-ordering数"><a href="#function模块下的total-ordering数" class="headerlink" title="function模块下的total_ordering数"></a>function模块下的total_ordering数</h3><p>见<a href="https://docs.python.org/2/library/functools.html#functools.total_ordering" target="_blank" rel="external">https://docs.python.org/2/library/functools.html#functools.total_ordering</a>。  </p>
<p>是一个装饰器，使相同类的对象之间可以使用各种比较符号。</p>
<h3 id="python相对导入和绝对导入"><a href="#python相对导入和绝对导入" class="headerlink" title="python相对导入和绝对导入"></a>python相对导入和绝对导入</h3><p><a href="http://blog.tankywoo.com/python/2013/10/07/python-relative-and-absolute-import.html" target="_blank" rel="external">Python Relative and Absolute Import</a>  </p>
<h3 id="python-signal"><a href="#python-signal" class="headerlink" title="python signal"></a>python signal</h3><p>SIG_DFL：默认信号处理程序。<br>SIG_IGN：忽略信号的处理程序。<br>SIGALRM是在定时器终止时发送给进程的信号。<br>signal.alarm函数。将signal文档，<a href="https://docs.python.org/2/library/signal.html" target="_blank" rel="external">signal — Set handlers for asynchronous events</a>。  </p>
<blockquote>
<p>signal.alarm(time)<br>    If time is non-zero, this function requests that a SIGALRM signal be sent to the process in time seconds. Any previously scheduled alarm is canceled (only one alarm can be scheduled at any time). The returned value is then the number of seconds before any previously set alarm was to have been delivered. If time is zero, no alarm is scheduled, and any scheduled alarm is canceled. If the return value is zero, no alarm is currently scheduled. (See the Unix man page alarm(2).) Availability: Unix.</p>
</blockquote>
<h3 id="python-from-contextlib-import-contextmanager"><a href="#python-from-contextlib-import-contextmanager" class="headerlink" title="python from contextlib import contextmanager"></a>python from contextlib import contextmanager</h3><p>见<a href="http://www.cnblogs.com/coser/archive/2013/01/28/2880328.html" target="_blank" rel="external">python中关于with及contextlib的用法</a>。  </p>
<p>示例：</p>
<pre><code class="py">from contextlib import contextmanager

@contextmanager
def make_context() :
    print &#39;enter&#39;
    try :
        yield {}
    except RuntimeError, err :
        print &#39;error&#39; , err
    finally :
        print &#39;exit&#39;

with make_context() as value :
    print value
</code></pre>
<p>运行结果：</p>
<pre><code class="plain">enter
{}
exit
</code></pre>
<h3 id="python-all"><a href="#python-all" class="headerlink" title="python __all__"></a>python __all__</h3><p><code>__all__</code>可用于模块导入时限制，如：<br>from module import *<br>此时被导入模块若定义了<strong>all</strong>属性，则只有all内指定的属性、方法、类可被导入~<br>若没定义，则模块内的所有将被导入。</p>
<p>见<a href="http://leequery.blog.163.com/blog/static/16842209620117184345180/" target="_blank" rel="external">http://leequery.blog.163.com/blog/static/16842209620117184345180/</a>。  </p>
<h3 id="python-logging-config-dictConfig"><a href="#python-logging-config-dictConfig" class="headerlink" title="python logging.config.dictConfig"></a>python logging.config.dictConfig</h3><p><a href="https://docs.python.org/2/library/logging.config.html#logging.config.dictConfig" target="_blank" rel="external">https://docs.python.org/2/library/logging.config.html#logging.config.dictConfig</a>  </p>
<p><a href="http://stackoverflow.com/questions/7507825/python-complete-example-of-dict-for-logging-config-dictconfig" target="_blank" rel="external">python: complete example of dict for logging.config.dictConfig?</a>  </p>
<h3 id="python-类方法、静态方法"><a href="#python-类方法、静态方法" class="headerlink" title="python 类方法、静态方法"></a>python 类方法、静态方法</h3><p><a href="http://blog.csdn.net/maoersong/article/details/32714781" target="_blank" rel="external">Python中类方法和静态方法</a>  </p>
<h3 id="python-importlib"><a href="#python-importlib" class="headerlink" title="python importlib"></a>python importlib</h3><p>用于导入字符串指定的模块。<br><a href="https://docs.python.org/2/library/importlib.html" target="_blank" rel="external">importlib – Convenience wrappers for __import__()</a>  </p>
<h3 id="python-name-和-module"><a href="#python-name-和-module" class="headerlink" title="python __name__和__module__"></a>python __name__和__module__</h3><pre><code class="plain">&gt;&gt;&gt; import pickle as pk
&gt;&gt;&gt; pk.load.__name__
&#39;load&#39;
&gt;&gt;&gt; pk.load.__module__
&#39;pickle&#39;
&gt;&gt;&gt; int.__module__
&#39;__builtin__&#39;
&gt;&gt;&gt; __builtin__.int(1.23)
1
</code></pre>
<h3 id="python-inspect模块"><a href="#python-inspect模块" class="headerlink" title="python inspect模块"></a>python inspect模块</h3><p><a href="https://docs.python.org/2/library/inspect.html" target="_blank" rel="external">inspect — Inspect live objects</a><br><a href="http://stackoverflow.com/questions/17019949/why-is-there-a-difference-between-inspect-ismethod-and-inspect-isfunction-from-p" target="_blank" rel="external">Why is there a difference between inspect.ismethod and inspect.isfunction from python 2 -&gt; 3?</a>  </p>
<hr>
<h3 id="redis-pipeline"><a href="#redis-pipeline" class="headerlink" title="redis pipeline"></a>redis pipeline</h3><p><a href="http://weipengfei.blog.51cto.com/1511707/1215042" target="_blank" rel="external">Redis 新特性—pipeline（管道）</a><br><a href="http://shift-alt-ctrl.iteye.com/blog/1863790" target="_blank" rel="external">Redis编程实践【pipeline和事务】</a>  </p>
<h3 id="redis-事务"><a href="#redis-事务" class="headerlink" title="redis 事务"></a>redis 事务</h3><p><a href="http://shift-alt-ctrl.iteye.com/blog/1863790" target="_blank" rel="external">Redis编程实践【pipeline和事务】</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-11-03&lt;/p&gt;
&lt;p&gt;如果一些任务没必要马上知道结果，可以将其放入队列中，让后台处理程序去处理，这同时也达到了异步的效果。本文围绕python的rq模块，介绍如何使用redis构建异步任务处理程序。&lt;/p&gt;
&lt;p&gt;rq官方地址：  &lt;a href=&quot;http://python-rq.org/&quot;&gt;http://python-rq.org/&lt;/a&gt;&lt;br&gt;Github：    &lt;a href=&quot;https://github.com/nvie/rq&quot;&gt;https://github.com/nvie/rq&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;本文分为以下几个部分：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何安装rq&lt;/li&gt;
&lt;li&gt;命令行工具的实现&lt;/li&gt;
&lt;li&gt;rq如何在redis中存储数据&lt;/li&gt;
&lt;li&gt;rq的设计思路&lt;/li&gt;
&lt;li&gt;关于rq的源码&lt;/li&gt;
&lt;li&gt;python、redis基础&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://www.letiantian.me/tags/python/"/>
    
      <category term="redis" scheme="http://www.letiantian.me/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>理解Python WSGI</title>
    <link href="http://www.letiantian.me/2015-09-10-understand-python-wsgi/"/>
    <id>http://www.letiantian.me/2015-09-10-understand-python-wsgi/</id>
    <published>2015-09-10T09:19:40.000Z</published>
    <updated>2015-09-11T03:05:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-09-10</p>
<p>本文内容主要来自以下网址：</p>
<p><a href="http://wsgi.readthedocs.org/en/latest/what.html" target="_blank" rel="external">What is WSGI?</a><br><a href="http://wsgi.tutorial.codepoint.net/" target="_blank" rel="external">WSGI Tutorial</a><br><a href="http://ivory.idyll.org/articles/wsgi-intro/what-is-wsgi.html" target="_blank" rel="external">An Introduction to the Python Web Server Gateway Interface (WSGI)</a></p>
<p>可以看成一次简单粗暴的翻译。</p>
<h2 id="什么是WSGI"><a href="#什么是WSGI" class="headerlink" title="什么是WSGI"></a>什么是WSGI</h2><p>WSGI的全称是Web Server Gateway Interface，这是一个规范，描述了web server如何与web application交互、web application如何处理请求。该规范的具体描述在<a href="http://www.python.org/dev/peps/pep-3333/" target="_blank" rel="external">PEP 3333</a>。注意，WSGI既要实现web server，也要实现web application。</p>
<a id="more"></a>
<p>实现了WSGI的模块/库有<a href="http://docs.python.org/library/wsgiref.html" target="_blank" rel="external">wsgiref</a>(python内置)、<a href="http://werkzeug.pocoo.org/docs/serving/" target="_blank" rel="external">werkzeug.serving</a>、<a href="http://twistedmatrix.com/trac/wiki/TwistedWeb/" target="_blank" rel="external">twisted.web</a>等，具体可见<a href="http://wsgi.readthedocs.org/en/latest/servers.html" target="_blank" rel="external">Servers which support WSGI</a>。</p>
<p>当前运行在WSGI之上的web框架有Bottle、Flask、Django等，具体可见<a href="http://wsgi.readthedocs.org/en/latest/frameworks.html" target="_blank" rel="external">Frameworks that run on WSGI</a>。</p>
<p>WSGI server所做的工作仅仅是将从客户端收到的请求传递给WSGI application，然后将WSGI application的返回值作为响应传给客户端。WSGI applications 可以是栈式的，这个栈的中间部分叫做<code>中间件</code>，两端是必须要实现的application和server。</p>
<h2 id="WSGI教程"><a href="#WSGI教程" class="headerlink" title="WSGI教程"></a>WSGI教程</h2><hr>
<p>这部分内容主要来自<a href="http://wsgi.tutorial.codepoint.net/" target="_blank" rel="external">WSGI Tutorial</a>。</p>
<h3 id="WSGI-application接口"><a href="#WSGI-application接口" class="headerlink" title="WSGI application接口"></a>WSGI application接口</h3><p>WSGI application接口应该实现为一个可调用对象，例如函数、方法、类、含<code>__call__</code>方法的实例。这个可调用对象可以接收2个参数：</p>
<ul>
<li>一个字典，该字典可以包含了客户端请求的信息以及其他信息，可以认为是请求上下文，一般叫做environment（编码中多简写为environ、env）；</li>
<li>一个用于发送HTTP响应状态（HTTP status ）、响应头（HTTP headers）的回调函数。</li>
</ul>
<p>同时，可调用对象的返回值是响应正文（response body），响应正文是可迭代的、并包含了多个字符串。</p>
<p>WSGI application结构如下：</p>
<pre><code class="py">def application (environ, start_response):

    response_body = &#39;Request method: %s&#39; % environ[&#39;REQUEST_METHOD&#39;]

    # HTTP响应状态
    status = &#39;200 OK&#39;

    # HTTP响应头，注意格式
    response_headers = [
        (&#39;Content-Type&#39;, &#39;text/plain&#39;),
        (&#39;Content-Length&#39;, str(len(response_body)))
    ]

    # 将响应状态和响应头交给WSGI server
    start_response(status, response_headers)

    # 返回响应正文
    return [response_body]
</code></pre>
<h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p>下面的程序可以将environment字典的内容返回给客户端（<code>environment.py</code>）：</p>
<pre><code class="py"># ! /usr/bin/env python
# -*- coding: utf-8 -*- 

# 导入python内置的WSGI server
from wsgiref.simple_server import make_server

def application (environ, start_response):

    response_body = [
        &#39;%s: %s&#39; % (key, value) for key, value in sorted(environ.items())
    ]
    response_body = &#39;\n&#39;.join(response_body)  # 由于下面将Content-Type设置为text/plain，所以`\n`在浏览器中会起到换行的作用

    status = &#39;200 OK&#39;
    response_headers = [
        (&#39;Content-Type&#39;, &#39;text/plain&#39;),
        (&#39;Content-Length&#39;, str(len(response_body)))
    ]
    start_response(status, response_headers)

    return [response_body]

# 实例化WSGI server
httpd = make_server (
    &#39;127.0.0.1&#39;, 
    8051, # port
    application # WSGI application，此处就是一个函数
)

# handle_request函数只能处理一次请求，之后就在控制台`print &#39;end&#39;`了
httpd.handle_request()

print &#39;end&#39;
</code></pre>
<p>浏览器（或者curl、wget等）访问<code>http://127.0.0.1:8051/</code>，可以看到environment的内容。</p>
<p>另外，浏览器请求一次后，<code>environment.py</code>就结束了，程序在终端中输出内容如下：</p>
<pre><code>127.0.0.1 - - [09/Sep/2015 23:39:09] &quot;GET / HTTP/1.1&quot; 200 5540
end
</code></pre><h3 id="可迭代的响应"><a href="#可迭代的响应" class="headerlink" title="可迭代的响应"></a>可迭代的响应</h3><p>如果把上面的可调用对象application的返回值：</p>
<pre><code class="py">return [response_body]
</code></pre>
<p>改成：</p>
<pre><code class="py">return response_body
</code></pre>
<p>这会导致WSGI程序的响应变慢。原因是字符串<code>response_body</code>也是可迭代的，它的每一次迭代只能得到1 byte的数据量，这也意味着每一次只向客户端发送1 byte的数据，直到发送完毕为止。所以，推荐使用<code>return [response_body]</code>。</p>
<p>如果可迭代响应含有多个字符串，那么<code>Content-Length</code>应该是这些字符串长度之和：</p>
<pre><code class="py"># ! /usr/bin/env python
# -*- coding: utf-8 -*- 

from wsgiref.simple_server import make_server

def application(environ, start_response):

    response_body = [
        &#39;%s: %s&#39; % (key, value) for key, value in sorted(environ.items())
    ]
    response_body = &#39;\n&#39;.join(response_body)

    response_body = [
        &#39;The Beggining\n&#39;,
        &#39;*&#39; * 30 + &#39;\n&#39;,
        response_body,
        &#39;\n&#39; + &#39;*&#39; * 30 ,
        &#39;\nThe End&#39;
    ]

    # 求Content-Length
    content_length = sum([len(s) for s in response_body])

    status = &#39;200 OK&#39;
    response_headers = [
        (&#39;Content-Type&#39;, &#39;text/plain&#39;),
        (&#39;Content-Length&#39;, str(content_length))
    ]

    start_response(status, response_headers)
    return response_body

httpd = make_server(&#39;localhost&#39;, 8051, application)
httpd.handle_request()

print &#39;end&#39;
</code></pre>
<h3 id="解析GET请求"><a href="#解析GET请求" class="headerlink" title="解析GET请求"></a>解析GET请求</h3><p>运行<code>environment.py</code>，在浏览器中访问<code>http://localhost:8051/?age=10&amp;hobbies=software&amp;hobbies=tunning</code>，可以在响应的内容中找到：</p>
<pre><code>QUERY_STRING: age=10&amp;hobbies=software&amp;hobbies=tunning
REQUEST_METHOD: GET
</code></pre><p><code>cgi.parse_qs()</code>函数可以很方便的处理QUERY_STRING，同时需要<code>cgi.escape()</code>处理特殊字符以防止脚本注入，下面是个例子：</p>
<pre><code># ! /usr/bin/env python
# -*- coding: utf-8 -*- 
from cgi import parse_qs, escape

QUERY_STRING = &#39;age=10&amp;hobbies=software&amp;hobbies=tunning&#39;
d = parse_qs(QUERY_STRING)
print d.get(&#39;age&#39;, [&#39;&#39;])[0]   # [&#39;&#39;]是默认值，如果在QUERY_STRING中没找到age则返回默认值
print d.get(&#39;hobbies&#39;, [])
print d.get(&#39;name&#39;, [&#39;unknown&#39;])

print 10 * &#39;*&#39;
print escape(&#39;&lt;script&gt;alert(123);&lt;/script&gt;&#39;)
</code></pre><p>输出如下：</p>
<pre><code>10
[&#39;software&#39;, &#39;tunning&#39;]
[&#39;unknown&#39;]
**********
&amp;lt;script&amp;gt;alert(123);&amp;lt;/script&amp;gt;
</code></pre><p>然后，我们可以写一个基本的处理GET请求的动态网页了：</p>
<pre><code class="py"># ! /usr/bin/env python
# -*- coding: utf-8 -*- 

from wsgiref.simple_server import make_server
from cgi import parse_qs, escape

# html中form的method是get，action是当前页面
html = &quot;&quot;&quot;
&lt;html&gt;
&lt;body&gt;
   &lt;form method=&quot;get&quot; action=&quot;&quot;&gt;
        &lt;p&gt;
           Age: &lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;%(age)s&quot;&gt;
        &lt;/p&gt;
        &lt;p&gt;
            Hobbies:
            &lt;input
                name=&quot;hobbies&quot; type=&quot;checkbox&quot; value=&quot;software&quot;
                %(checked-software)s
            &gt; Software
            &lt;input
                name=&quot;hobbies&quot; type=&quot;checkbox&quot; value=&quot;tunning&quot;
                %(checked-tunning)s
            &gt; Auto Tunning
        &lt;/p&gt;
        &lt;p&gt;
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;
        &lt;/p&gt;
    &lt;/form&gt;
    &lt;p&gt;
        Age: %(age)s&lt;br&gt;
        Hobbies: %(hobbies)s
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
&quot;&quot;&quot;

def application (environ, start_response):

    # 解析QUERY_STRING
    d = parse_qs(environ[&#39;QUERY_STRING&#39;])

    age = d.get(&#39;age&#39;, [&#39;&#39;])[0] # 返回age对应的值
    hobbies = d.get(&#39;hobbies&#39;, []) # 以list形式返回所有的hobbies

    # 防止脚本注入
    age = escape(age)
    hobbies = [escape(hobby) for hobby in hobbies]

    response_body = html % { 
        &#39;checked-software&#39;: (&#39;&#39;, &#39;checked&#39;)[&#39;software&#39; in hobbies],
        &#39;checked-tunning&#39;: (&#39;&#39;, &#39;checked&#39;)[&#39;tunning&#39; in hobbies],
        &#39;age&#39;: age or &#39;Empty&#39;,
        &#39;hobbies&#39;: &#39;, &#39;.join(hobbies or [&#39;No Hobbies?&#39;])
    }

    status = &#39;200 OK&#39;

    # 这次的content type是text/html
    response_headers = [
        (&#39;Content-Type&#39;, &#39;text/html&#39;),
        (&#39;Content-Length&#39;, str(len(response_body)))
    ]

    start_response(status, response_headers)
    return [response_body]

httpd = make_server(&#39;localhost&#39;, 8051, application)

# 能够一直处理请求
httpd.serve_forever()

print &#39;end&#39;
</code></pre>
<p>启动程序，在浏览器中访问<code>http://localhost:8051/</code>、<code>http://localhost:8051/?age=10&amp;hobbies=software&amp;hobbies=tunning</code>感受一下～</p>
<p>这个程序会一直运行，可以使用快捷键<code>Ctrl-C</code>终止它。</p>
<p>这段代码涉及两个我个人之前没用过的小技巧：</p>
<pre><code class="plain">&gt;&gt;&gt; &quot;Age: %(age)s&quot; % {&#39;age&#39;:12}
&#39;Age: 12&#39;
&gt;&gt;&gt; 
&gt;&gt;&gt; hobbies = [&#39;software&#39;]
&gt;&gt;&gt; (&#39;&#39;, &#39;checked&#39;)[&#39;software&#39; in hobbies]
&#39;checked&#39;
&gt;&gt;&gt; (&#39;&#39;, &#39;checked&#39;)[&#39;tunning&#39; in hobbies]
&#39;&#39;
</code></pre>
<h3 id="解析POST请求"><a href="#解析POST请求" class="headerlink" title="解析POST请求"></a>解析POST请求</h3><p>对于POST请求，查询字符串（query string）是放在HTTP请求正文（request body）中的，而不是放在URL中。请求正文在environment字典变量中键<code>wsgi.input</code>对应的值中，这是一个类似file的变量，这个值是一个。<a href="https://www.python.org/dev/peps/pep-3333/#id24" target="_blank" rel="external">The PEP 3333</a> 指出，请求头中<code>CONTENT_LENGTH</code>字段表示正文的大小，但是可能为空、或者不存在，所以读取请求正文时候要用<code>try/except</code>。</p>
<p>下面是一个可以处理POST请求的动态网站：</p>
<pre><code class="py"># ! /usr/bin/env python
# -*- coding: utf-8 -*- 

from wsgiref.simple_server import make_server
from cgi import parse_qs, escape

# html中form的method是post
html = &quot;&quot;&quot;
&lt;html&gt;
&lt;body&gt;
   &lt;form method=&quot;post&quot; action=&quot;&quot;&gt;
        &lt;p&gt;
           Age: &lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;%(age)s&quot;&gt;
        &lt;/p&gt;
        &lt;p&gt;
            Hobbies:
            &lt;input
                name=&quot;hobbies&quot; type=&quot;checkbox&quot; value=&quot;software&quot;
                %(checked-software)s
            &gt; Software
            &lt;input
                name=&quot;hobbies&quot; type=&quot;checkbox&quot; value=&quot;tunning&quot;
                %(checked-tunning)s
            &gt; Auto Tunning
        &lt;/p&gt;
        &lt;p&gt;
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;
        &lt;/p&gt;
    &lt;/form&gt;
    &lt;p&gt;
        Age: %(age)s&lt;br&gt;
        Hobbies: %(hobbies)s
    &lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
&quot;&quot;&quot;

def application(environ, start_response):

    # CONTENT_LENGTH 可能为空，或者没有
    try:
        request_body_size = int(environ.get(&#39;CONTENT_LENGTH&#39;, 0))
    except (ValueError):
        request_body_size = 0

    request_body = environ[&#39;wsgi.input&#39;].read(request_body_size)
    d = parse_qs(request_body)

    # 获取数据
    age = d.get(&#39;age&#39;, [&#39;&#39;])[0] 
    hobbies = d.get(&#39;hobbies&#39;, []) 

    # 转义，防止脚本注入
    age = escape(age)
    hobbies = [escape(hobby) for hobby in hobbies]

    response_body = html % { 
        &#39;checked-software&#39;: (&#39;&#39;, &#39;checked&#39;)[&#39;software&#39; in hobbies],
        &#39;checked-tunning&#39;: (&#39;&#39;, &#39;checked&#39;)[&#39;tunning&#39; in hobbies],
        &#39;age&#39;: age or &#39;Empty&#39;,
        &#39;hobbies&#39;: &#39;, &#39;.join(hobbies or [&#39;No Hobbies?&#39;])
    }

    status = &#39;200 OK&#39;

    response_headers = [
        (&#39;Content-Type&#39;, &#39;text/html&#39;),
        (&#39;Content-Length&#39;, str(len(response_body)))
    ]

    start_response(status, response_headers)
    return [response_body]

httpd = make_server(&#39;localhost&#39;, 8051, application)

httpd.serve_forever()

print &#39;end&#39;
</code></pre>
<h2 id="Python-WSGI入门"><a href="#Python-WSGI入门" class="headerlink" title="Python WSGI入门"></a>Python WSGI入门</h2><p>这段内容参考自<a href="http://ivory.idyll.org/articles/wsgi-intro/what-is-wsgi.html" target="_blank" rel="external">An Introduction to the Python Web Server Gateway Interface (WSGI)</a>。</p>
<h3 id="Web-server"><a href="#Web-server" class="headerlink" title="Web server"></a>Web server</h3><p>WSGI server就是一个web server，其处理一个HTTP请求的逻辑如下：</p>
<pre><code>iterable = app(environ, start_response)
for data in iterable:
   # send data to client
</code></pre><p>app即WSGI application，environ即上文中的environment。可调用对象app返回一个可迭代的值，WSGI server获得这个值后将数据发送给客户端。</p>
<h3 id="Web-framework-app"><a href="#Web-framework-app" class="headerlink" title="Web framework/app"></a>Web framework/app</h3><p>即<code>WSGI application</code>。</p>
<h3 id="中间件（Middleware）"><a href="#中间件（Middleware）" class="headerlink" title="中间件（Middleware）"></a>中间件（Middleware）</h3><p>中间件位于WSGI server和WSGI application之间，所以</p>
<h3 id="一个示例"><a href="#一个示例" class="headerlink" title="一个示例"></a>一个示例</h3><p>该示例中使用了中间件。</p>
<pre><code class="py"># ! /usr/bin/env python
# -*- coding: utf-8 -*- 

from wsgiref.simple_server import make_server

def application(environ, start_response):

    response_body = &#39;hello world!&#39;

    status = &#39;200 OK&#39;

    response_headers = [
        (&#39;Content-Type&#39;, &#39;text/plain&#39;),
        (&#39;Content-Length&#39;, str(len(response_body)))
    ]

    start_response(status, response_headers)
    return [response_body]

# 中间件
class Upperware:
   def __init__(self, app):
      self.wrapped_app = app

   def __call__(self, environ, start_response):
      for data in self.wrapped_app(environ, start_response):
        yield data.upper()

wrapped_app = Upperware(application)

httpd = make_server(&#39;localhost&#39;, 8051, wrapped_app)

httpd.serve_forever()

print &#39;end&#39;
</code></pre>
<h2 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h2><p>有了这些基础知识，就可以打造一个web框架了。感兴趣的话，可以阅读一下Bottle、Flask等的源码。</p>
<p>在<a href="http://wsgi.readthedocs.org/en/latest/learn.html" target="_blank" rel="external">Learn about WSGI</a>还有更多关于WSGI的内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-09-10&lt;/p&gt;
&lt;p&gt;本文内容主要来自以下网址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wsgi.readthedocs.org/en/latest/what.html&quot;&gt;What is WSGI?&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://wsgi.tutorial.codepoint.net/&quot;&gt;WSGI Tutorial&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ivory.idyll.org/articles/wsgi-intro/what-is-wsgi.html&quot;&gt;An Introduction to the Python Web Server Gateway Interface (WSGI)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看成一次简单粗暴的翻译。&lt;/p&gt;
&lt;h2 id=&quot;什么是WSGI&quot;&gt;&lt;a href=&quot;#什么是WSGI&quot; class=&quot;headerlink&quot; title=&quot;什么是WSGI&quot;&gt;&lt;/a&gt;什么是WSGI&lt;/h2&gt;&lt;p&gt;WSGI的全称是Web Server Gateway Interface，这是一个规范，描述了web server如何与web application交互、web application如何处理请求。该规范的具体描述在&lt;a href=&quot;http://www.python.org/dev/peps/pep-3333/&quot;&gt;PEP 3333&lt;/a&gt;。注意，WSGI既要实现web server，也要实现web application。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://www.letiantian.me/tags/python/"/>
    
      <category term="web" scheme="http://www.letiantian.me/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>如何快速更新数据库中的百万条数据</title>
    <link href="http://www.letiantian.me/2015-06-22-update-faster/"/>
    <id>http://www.letiantian.me/2015-06-22-update-faster/</id>
    <published>2015-06-22T06:40:27.000Z</published>
    <updated>2015-07-22T15:11:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-06-22</p>
<p>环境：ubuntu 14.04，Mysql 5.6，python 2.7。</p>
<p>本文使用python的MySQLdb这个库，<a href="http://zetcode.com/db/mysqlpython/" target="_blank" rel="external">MySQL Python tutorial</a>这个教程很赞。</p>
<p>MySQLDBdb处理INSERT、UPDATE、DELETE时需要显式得commit()才能使更新有效，这也意味着commit之前的更新语句是放在一个事务中的。</p>
<blockquote>
<p>For databases that support transactions, the Python interface silently starts a transaction when the cursor is created. The commit() method commits the updates made using that cursor, and the rollback() method discards them. Each method starts a new transaction.</p>
</blockquote>
<p>对比如下：</p>
<table>
<thead>
<tr>
<th>更新方式</th>
<th>总时间(ms)</th>
<th>rows</th>
<th>平均(ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>57831</td>
<td>1000</td>
<td>57.8</td>
</tr>
<tr>
<td>2</td>
<td>89695</td>
<td>10</td>
<td>896</td>
</tr>
<tr>
<td>3</td>
<td>92941</td>
<td>40×10000</td>
<td>0.23</td>
</tr>
<tr>
<td>4</td>
<td>47956</td>
<td>40×10000</td>
<td>0.119</td>
</tr>
<tr>
<td>5</td>
<td>28407</td>
<td>40×10000</td>
<td>0.071</td>
</tr>
<tr>
<td>6</td>
<td>3272</td>
<td>48×10000</td>
<td>0.008</td>
</tr>
</tbody>
</table>
<p>方式1是单线程，where使用了索引，一个更新对应一个commit。<br>方式2是单线程，where没有使用索引，所有更新对应一个commit。<br>方式3是单线程，where使用了索引，所有更新对应一个commit。<br>方式4使用了2个进程来更新，where使用了索引，每个进程里的所有更新对应一个commit。<br>方式5使用了4个进程来更新，where使用了索引，每个进程里的所有更新对应一个commit。<br>方式6是在一个update语句里面更新所有的数据。  </p>
<a id="more"></a>
<h2 id="建立表"><a href="#建立表" class="headerlink" title="建立表"></a>建立表</h2><pre><code class="sql">mysql&gt; CREATE TABLE `test`.`number` (
  `id` INT NOT NULL COMMENT &#39;&#39;,
  `num` INT NULL COMMENT &#39;&#39;,
  PRIMARY KEY (`id`)  COMMENT &#39;&#39;);

mysql&gt; show create table number \G
*************************** 1. row ***************************
       Table: number
Create Table: CREATE TABLE `number` (
  `id` int(11) NOT NULL,
  `num` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
</code></pre>
<h2 id="使用mysqldb插入数据-100-000条"><a href="#使用mysqldb插入数据-100-000条" class="headerlink" title="使用mysqldb插入数据(100*000条)"></a>使用mysqldb插入数据(100*000条)</h2><pre><code class="python"># coding: UTF-8
__author__ = &#39;letian&#39;

import MySQLdb
import time

host=&#39;127.0.0.1&#39;
user=&#39;root&#39;
passwd=&#39;123456&#39;
db=&#39;test&#39;
port = 3306


start_time = time.time()

conn = MySQLdb.connect(host, user, passwd, db, port)
cur = conn.cursor()

for x in xrange(100*10000): # 0 到 999999
    print x
    sql = &quot;INSERT INTO number VALUES(%s,%s)&quot; % (x, x)
    cur.execute(sql)

conn.commit()

end_time = time.time()

print &#39;用时：&#39;, end_time - start_time
</code></pre>
<p>运行结果：</p>
<pre><code>...
999997
999998
999999
用时：219.332565069
</code></pre><p>挺快。</p>
<p>看下数据：</p>
<pre><code>mysql&gt; select count(*) from number;
+----------+
| count(*) |
+----------+
|  1000000 |
+----------+
1 row in set (0.60 sec)

mysql&gt; select * from number limit 3;
+----+------+
| id | num  |
+----+------+
|  0 |    0 |
|  1 |    1 |
|  2 |    2 |
+----+------+
3 rows in set (0.00 sec)
</code></pre><h2 id="更新方式1：单线程，使用索引，多个commmit，更新1000条"><a href="#更新方式1：单线程，使用索引，多个commmit，更新1000条" class="headerlink" title="更新方式1：单线程，使用索引，多个commmit，更新1000条"></a>更新方式1：单线程，使用索引，多个commmit，更新1000条</h2><pre><code># coding: UTF-8
__author__ = &#39;letian&#39;

import MySQLdb
import time

host=&#39;127.0.0.1&#39;
user=&#39;root&#39;
passwd=&#39;123456&#39;
db=&#39;test&#39;
port = 3306


start_time = time.time()

conn = MySQLdb.connect(host, user, passwd, db, port)
cur = conn.cursor()

for x in xrange(1000):
    print x
    sql = &quot;UPDATE number SET num=%s where id=%s&quot; % (x+1, x)
    cur.execute(sql)
    conn.commit()

cur.close()
conn.close()

end_time = time.time()

print &#39;用时：&#39;, end_time - start_time
</code></pre><p>输出：</p>
<pre><code>...
997
998
999
用时：57.8318688869
</code></pre><p>1000条用时约60秒。</p>
<p>为什么慢？</p>
<p>先explain一下：</p>
<pre><code>mysql&gt; explain update number set num=3 where id=2 \G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: number
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: const
         rows: 1
        Extra: Using where
1 row in set (0.06 sec)
</code></pre><p>sql语句没什么问题。</p>
<p>再看一下磁盘IO：</p>
<pre><code>letian $ iostat -d -k 1 100
Linux 3.13.0-37-generic (myhost)  06/22/2015  _x86_64_  (4 CPU)

............

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              57.00         4.00       468.00          4        468

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              71.00        28.00       404.00         28        404

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              71.00        28.00       608.00         28        608

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              61.00         4.00       492.00          4        492

............

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              73.00         0.00       536.00          0        536

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              69.00         4.00       516.00          4        516

............

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              61.00         4.00       472.00          4        472

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              63.00         4.00       452.00          4        452

............

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              16.00         0.00      1804.00          0       1804

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               3.00         0.00        16.00          0         16

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               0.00         0.00         0.00          0          0

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               2.00         0.00        12.00          0         12
</code></pre><p><code>tps</code>代表每秒IO传输的次数，与下面的<code>更新方式4</code>对比一下，可以看出当前的更新方式IO较多。（为什么呢？移步<a href="http://stackoverflow.com/questions/14675147/why-does-transaction-commit-improve-performance-so-much-with-php-mysql-innodb" target="_blank" rel="external">Why does TRANSACTION / COMMIT improve performance so much with PHP/MySQL (InnoDB)?</a>）</p>
<h2 id="更新方式2，单线程，不使用索引，一个commit，更新100条"><a href="#更新方式2，单线程，不使用索引，一个commit，更新100条" class="headerlink" title="更新方式2，单线程，不使用索引，一个commit，更新100条"></a>更新方式2，单线程，不使用索引，一个commit，更新100条</h2><pre><code># coding: UTF-8
__author__ = &#39;letian&#39;

import MySQLdb
import time

host=&#39;127.0.0.1&#39;
user=&#39;root&#39;
passwd=&#39;123456&#39;
db=&#39;test&#39;
port = 3306


start_time = time.time()

conn = MySQLdb.connect(host, user, passwd, db, port)
cur = conn.cursor()

for x in xrange(100):
    print x
    sql = &quot;UPDATE number SET num=%s where num=%s&quot; % (x*2, x)
    cur.execute(sql)

conn.commit()
cur.close()
conn.close()

end_time = time.time()

print &#39;用时：&#39;, end_time - start_time
</code></pre><p>输出：</p>
<pre><code>...
97
98
99
用时： 89.695207119
</code></pre><p>为什么这么慢：</p>
<pre><code>mysql&gt; explain update number set num=4 where num=2 \G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: number
         type: index
possible_keys: NULL
          key: PRIMARY
      key_len: 4
          ref: NULL
         rows: 979800
        Extra: Using where
1 row in set (0.05 sec)
</code></pre><p>可以看到，每次update几乎要扫全表（rows: 979800）。</p>
<h2 id="更新方式3：单线程，使用索引，一个commit，更新40×10000条"><a href="#更新方式3：单线程，使用索引，一个commit，更新40×10000条" class="headerlink" title="更新方式3：单线程，使用索引，一个commit，更新40×10000条"></a>更新方式3：单线程，使用索引，一个commit，更新40×10000条</h2><pre><code class="python"># coding: UTF-8
__author__ = &#39;letian&#39;

import MySQLdb
import time

host=&#39;127.0.0.1&#39;
user=&#39;root&#39;
passwd=&#39;123456&#39;
db=&#39;test&#39;
port = 3306

start_time = time.time()

conn = MySQLdb.connect(host, user, passwd, db, port)
cur = conn.cursor()

for x in xrange(40*10000): # 0 到 999999
    print x
    sql = &quot;UPDATE number SET num=%s where id=%s&quot; % (x+1, x)
    cur.execute(sql)

conn.commit()

end_time = time.time()

print &#39;用时：&#39;, end_time - start_time
</code></pre>
<p>输出：</p>
<pre><code>...
399997
399998
399999
用时：92.9413559437
</code></pre><p>查看磁盘IO：</p>
<pre><code>letian $ iostat -d -k 1 100
Linux 3.13.0-37-generic (myhost)  06/22/2015  _x86_64_  (4 CPU)

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              20.88       288.50       283.18    2458129    2412772

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              18.00       116.00       328.00        116        328

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              17.00         8.00       548.00          8        548

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              11.00        12.00       396.00         12        396

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              10.00         4.00       488.00          4        488

............


Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              10.00         4.00       460.00          4        460

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              10.00         4.00       448.00          4        448

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              10.00         4.00       464.00          4        464

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              10.00         4.00       456.00          4        456

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               9.00         4.00       452.00          4        452

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               9.00         0.00       140.00          0        140

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              15.00         4.00      2448.00          4       2448

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              43.00       144.00      2544.00        144       2544

............

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               9.00         0.00       516.00          0        516

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              10.00         4.00       512.00          4        512

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              12.00         4.00       540.00          4        540

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              14.00         4.00      2288.00          4       2288

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              10.00         4.00       528.00          4        528

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               6.00         0.00       184.00          0        184

............

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              14.00         0.00      3868.00          0       3868

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              15.00         0.00      2604.00          0       2604

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              15.00         0.00      1516.00          0       1516

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               3.00         0.00        16.00          0         16

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              12.00         0.00        68.00          0         68

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               4.00         0.00        28.00          0         28

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               0.00         0.00         0.00          0          0

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               0.00         0.00         0.00          0          0

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               0.00         0.00         0.00          0          0
</code></pre><h2 id="更新方式4：2个进程，一个进程里一个commit，共更新40-10000条"><a href="#更新方式4：2个进程，一个进程里一个commit，共更新40-10000条" class="headerlink" title="更新方式4：2个进程，一个进程里一个commit，共更新40*10000条"></a>更新方式4：2个进程，一个进程里一个commit，共更新40*10000条</h2><p>两个进程：</p>
<pre><code class="python"># coding: UTF-8
__author__ = &#39;letian&#39;

import MySQLdb
import time
import multiprocessing

host=&#39;127.0.0.1&#39;
user=&#39;root&#39;
passwd=&#39;123456&#39;
db=&#39;test&#39;
port = 3306

start_time = time.time()

def update(int_iter):
    conn = MySQLdb.connect(host, user, passwd, db, port)
    cur = conn.cursor()
    for x in int_iter:
        print x
        sql = &quot;UPDATE number SET num=%s where id=%s&quot; % (x+5, x)
        cur.execute(sql)
    conn.commit()
    cur.close()
    conn.close()

pool = multiprocessing.Pool(processes = 2)

pool.apply_async(update, (xrange(20*10000), ))
pool.apply_async(update, (xrange(20*10000, 40*10000), ))
pool.close()
pool.join()

end_time = time.time()

print &#39;用时：&#39;, end_time - start_time
</code></pre>
<p>输出：</p>
<pre><code>...
199998
199999
用时： 47.9561839104
</code></pre><p>看下数据：</p>
<pre><code>mysql&gt; select * from number where id=1;
+----+------+
| id | num  |
+----+------+
|  1 |    6 |
+----+------+
1 row in set (0.00 sec)

mysql&gt; select * from number where id=399999;
+--------+--------+
| id     | num    |
+--------+--------+
| 399999 | 400004 |
+--------+--------+
1 row in set (0.00 sec)
</code></pre><h2 id="更新方式5：4个进程，一个进程里一个commit，共更新40-10000条"><a href="#更新方式5：4个进程，一个进程里一个commit，共更新40-10000条" class="headerlink" title="更新方式5：4个进程，一个进程里一个commit，共更新40*10000条"></a>更新方式5：4个进程，一个进程里一个commit，共更新40*10000条</h2><pre><code># coding: UTF-8
__author__ = &#39;letian&#39;

import MySQLdb
import time
import multiprocessing

host=&#39;127.0.0.1&#39;
user=&#39;root&#39;
passwd=&#39;123456&#39;
db=&#39;test&#39;
port = 3306

start_time = time.time()

def update(int_iter):
    conn = MySQLdb.connect(host, user, passwd, db, port)
    cur = conn.cursor()
    for x in int_iter:
        print x
        sql = &quot;UPDATE number SET num=%s where id=%s&quot; % (x+10, x)
        cur.execute(sql)
    conn.commit()
    cur.close()
    conn.close()

pool = multiprocessing.Pool(processes = 4)

pool.apply_async(update, (xrange(10*10000), ))
pool.apply_async(update, (xrange(10*10000, 20*10000), ))
pool.apply_async(update, (xrange(20*10000, 30*10000), ))
pool.apply_async(update, (xrange(30*10000, 40*10000), ))

pool.close()
pool.join()

end_time = time.time()

print &#39;用时：&#39;, end_time - start_time
</code></pre><p>运行结果：</p>
<pre><code>299996
299997
299998
299999
用时： 28.4070010185
</code></pre><p>查看更新效果：</p>
<pre><code>mysql&gt; select * from number where id=1;
+----+------+
| id | num  |
+----+------+
|  1 |   11 |
+----+------+
1 row in set (0.00 sec)

mysql&gt; select * from number where id=399999;
+--------+--------+
| id     | num    |
+--------+--------+
| 399999 | 400009 |
+--------+--------+
1 row in set (0.00 sec)
</code></pre><h2 id="更新方式6：一次更新多行，更新40-10000条"><a href="#更新方式6：一次更新多行，更新40-10000条" class="headerlink" title="更新方式6：一次更新多行，更新40*10000条"></a>更新方式6：一次更新多行，更新40*10000条</h2><pre><code># coding: UTF-8
__author__ = &#39;letian&#39;

import MySQLdb
import time

host=&#39;127.0.0.1&#39;
user=&#39;root&#39;
passwd=&#39;123456&#39;
db=&#39;test&#39;
port = 3306

start_time = time.time()

conn = MySQLdb.connect(host, user, passwd, db, port)
cur = conn.cursor()

sql = &quot;UPDATE number SET num=id+100 where id&lt;%s&quot; % (40*10000, )
cur.execute(sql)
conn.commit()

cur.close()
conn.close()

end_time = time.time()

print &#39;用时：&#39;, end_time - start_time
</code></pre><p>输出：</p>
<pre><code>用时： 3.27281808853
</code></pre><p>查看更新效果：</p>
<pre><code>mysql&gt; select * from number where id=1;
+----+------+
| id | num  |
+----+------+
|  1 |  101 |
+----+------+
1 row in set (0.00 sec)

mysql&gt; select * from number where id=399999;
+--------+--------+
| id     | num    |
+--------+--------+
| 399999 | 400099 |
+--------+--------+
1 row in set (0.00 sec)
</code></pre><p>分析使用的sql语句：</p>
<pre><code>mysql&gt; explain UPDATE number SET num=id+100 where id&lt;400000 \G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: number
         type: range
possible_keys: PRIMARY
          key: PRIMARY
      key_len: 4
          ref: const
         rows: 489900
        Extra: Using where
1 row in set (0.00 sec)
</code></pre><p>这种方式非常快，灵活性不够。</p>
<p>如果遇到这样一个场景：将id为0、1、2的num置为2,其他全部置为4，可以先全部置为4,然后在更新id为0、1、2的记录，这样速度会很快。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-06-22&lt;/p&gt;
&lt;p&gt;环境：ubuntu 14.04，Mysql 5.6，python 2.7。&lt;/p&gt;
&lt;p&gt;本文使用python的MySQLdb这个库，&lt;a href=&quot;http://zetcode.com/db/mysqlpython/&quot;&gt;MySQL Python tutorial&lt;/a&gt;这个教程很赞。&lt;/p&gt;
&lt;p&gt;MySQLDBdb处理INSERT、UPDATE、DELETE时需要显式得commit()才能使更新有效，这也意味着commit之前的更新语句是放在一个事务中的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For databases that support transactions, the Python interface silently starts a transaction when the cursor is created. The commit() method commits the updates made using that cursor, and the rollback() method discards them. Each method starts a new transaction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对比如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;更新方式&lt;/th&gt;
&lt;th&gt;总时间(ms)&lt;/th&gt;
&lt;th&gt;rows&lt;/th&gt;
&lt;th&gt;平均(ms)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;57831&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;57.8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;89695&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;896&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;92941&lt;/td&gt;
&lt;td&gt;40×10000&lt;/td&gt;
&lt;td&gt;0.23&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;47956&lt;/td&gt;
&lt;td&gt;40×10000&lt;/td&gt;
&lt;td&gt;0.119&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;28407&lt;/td&gt;
&lt;td&gt;40×10000&lt;/td&gt;
&lt;td&gt;0.071&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;3272&lt;/td&gt;
&lt;td&gt;48×10000&lt;/td&gt;
&lt;td&gt;0.008&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;方式1是单线程，where使用了索引，一个更新对应一个commit。&lt;br&gt;方式2是单线程，where没有使用索引，所有更新对应一个commit。&lt;br&gt;方式3是单线程，where使用了索引，所有更新对应一个commit。&lt;br&gt;方式4使用了2个进程来更新，where使用了索引，每个进程里的所有更新对应一个commit。&lt;br&gt;方式5使用了4个进程来更新，where使用了索引，每个进程里的所有更新对应一个commit。&lt;br&gt;方式6是在一个update语句里面更新所有的数据。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://www.letiantian.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="http://www.letiantian.me/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java并发概念汇总</title>
    <link href="http://www.letiantian.me/2015-05-27-java-concurrency-summary/"/>
    <id>http://www.letiantian.me/2015-05-27-java-concurrency-summary/</id>
    <published>2015-05-27T02:19:02.000Z</published>
    <updated>2015-05-27T07:28:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-05-27</p>
<p>看了《Java编程思想 第4版》<code>并发</code>这一章，觉得有必要整理一下其中的概念。</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>为什么要并发？ 比如因为IO操作遇到了阻塞，CPU可以转去执行其他线程，这时并发的优点就显示出来了：更高效的利用CPU，提高程序的响应速度。</p>
<p>Java的线程机制是抢占式的，会为每个线程分配时间片。</p>
<h3 id="线程中断与上下文切换"><a href="#线程中断与上下文切换" class="headerlink" title="线程中断与上下文切换"></a>线程中断与上下文切换</h3><p><a href="http://www.cnblogs.com/ktgu/p/3529144.html" target="_blank" rel="external">并发编程 - 多线程的代价及上下文切换</a><br><a href="http://ifeve.com/context-switching-and-multi-processor/" target="_blank" rel="external">上下文切换与多处理器</a></p>
<h3 id="Java本身还有另外一个“线程中断”"><a href="#Java本身还有另外一个“线程中断”" class="headerlink" title="Java本身还有另外一个“线程中断”"></a>Java本身还有另外一个“线程中断”</h3><p><a href="http://www.infoq.com/cn/articles/java-interrupt-mechanism" target="_blank" rel="external">详细分析Java中断机制</a>  </p>
<a id="more"></a>
<h2 id="基本的线程机制"><a href="#基本的线程机制" class="headerlink" title="基本的线程机制"></a>基本的线程机制</h2><h3 id="使用Runnable和Thread创建线程："><a href="#使用Runnable和Thread创建线程：" class="headerlink" title="使用Runnable和Thread创建线程："></a>使用Runnable和Thread创建线程：</h3><p><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html" target="_blank" rel="external">Defining and Starting a Thread</a><br><a href="http://stackoverflow.com/questions/541487/implements-runnable-vs-extends-thread" target="_blank" rel="external">“implements Runnable” vs. “extends Thread”</a></p>
<h3 id="使用执行器Executor执行线程："><a href="#使用执行器Executor执行线程：" class="headerlink" title="使用执行器Executor执行线程："></a>使用执行器Executor执行线程：</h3><p><a href="http://blog.csdn.net/ns_code/article/details/17465497" target="_blank" rel="external">并发新特性—Executor框架与线程池（含代码）</a><br><a href="http://blog.csdn.net/ghsau/article/details/7443324" target="_blank" rel="external">Java线程(六)：线程池</a><br><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html" target="_blank" rel="external">Interface Executor</a></p>
<h3 id="让线程中的任务返回值：Callable"><a href="#让线程中的任务返回值：Callable" class="headerlink" title="让线程中的任务返回值：Callable"></a>让线程中的任务返回值：Callable</h3><p><a href="http://blog.csdn.net/ghsau/article/details/7451464" target="_blank" rel="external">Java线程(七)：Callable和Future</a><br><a href="http://www.journaldev.com/1090/java-callable-future-example" target="_blank" rel="external">Java Callable Future Example</a></p>
<h3 id="休眠sleep-、让步yield"><a href="#休眠sleep-、让步yield" class="headerlink" title="休眠sleep()、让步yield()"></a>休眠sleep()、让步yield()</h3><p>休眠（sleep）和让步(yield)会导致线程阻塞，CPU转而执行其他线程。对调用yield时，是在建议具有相同优先级的其他线程运行。</p>
<p><a href="http://dylanxu.iteye.com/blog/1322066" target="_blank" rel="external">java之yield(),sleep(),wait()区别详解</a>  </p>
<h3 id="线程优先级、后台线程"><a href="#线程优先级、后台线程" class="headerlink" title="线程优先级、后台线程"></a>线程优先级、后台线程</h3><p><a href="http://www.cnblogs.com/ChrisWang/archive/2009/11/28/1612815.html" target="_blank" rel="external">关于Java的Daemon线程的理解</a><br><a href="http://www.cnblogs.com/luochengor/archive/2011/08/11/2134818.html" target="_blank" rel="external">JAVA并发编程——守护线程(Daemon Thread)</a><br><a href="http://www.cnblogs.com/skywang12345/p/3479982.html" target="_blank" rel="external">Java多线程系列–“基础篇”10之 线程优先级和守护线程</a><br><a href="http://blog.sina.com.cn/s/blog_5c5bc9070100yty5.html" target="_blank" rel="external">java 线程的优先级Priority</a>  </p>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p><a href="http://www.cnblogs.com/techyc/p/3286678.html" target="_blank" rel="external">简谈Java的join()方法</a><br><a href="http://uule.iteye.com/blog/1101994" target="_blank" rel="external">Java多线程中join方法的理解</a>  </p>
<h3 id="捕获线程的异常"><a href="#捕获线程的异常" class="headerlink" title="捕获线程的异常"></a>捕获线程的异常</h3><p><a href="http://www.cnblogs.com/chenfei0801/archive/2013/04/23/3039286.html" target="_blank" rel="external">JAVA 线程中的异常捕获</a>  </p>
<h2 id="共享受限资源"><a href="#共享受限资源" class="headerlink" title="共享受限资源"></a>共享受限资源</h2><p><a href="http://blog.csdn.net/xiao__gui/article/details/8934832" target="_blank" rel="external">Java线程安全和非线程安全</a>  </p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><a href="http://blog.csdn.net/ghsau/article/details/7424694" target="_blank" rel="external">Java线程(二)：线程同步synchronized和volatile</a><br><a href="http://stackoverflow.com/questions/1085709/what-does-synchronized-mean" target="_blank" rel="external">What does ‘synchronized’ mean?</a></p>
<h3 id="重入锁ReentrantLock"><a href="#重入锁ReentrantLock" class="headerlink" title="重入锁ReentrantLock"></a>重入锁ReentrantLock</h3><p><a href="http://blog.csdn.net/ghsau/article/details/7461369" target="_blank" rel="external">Java线程(八)：锁对象Lock-同步问题更完美的处理方式</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-jtp10264/" target="_blank" rel="external">Java 理论与实践: JDK 5.0 中更灵活、更具可伸缩性的锁定机制</a>  </p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><a href="http://ifeve.com/java_lock_see1/" target="_blank" rel="external">java锁的种类以及辨析（一）：自旋锁</a><br><a href="http://ifeve.com/java_lock_see2/" target="_blank" rel="external">Java锁的种类以及辨析（二）：自旋锁的其他种类</a><br><a href="http://ifeve.com/java_lock_see3/" target="_blank" rel="external">Java锁的种类以及辨析（三）：阻塞锁</a><br><a href="http://ifeve.com/java_lock_see4/" target="_blank" rel="external">Java锁的种类以及辨析（四）：可重入锁</a>  </p>
<h3 id="Volatile变量"><a href="#Volatile变量" class="headerlink" title="Volatile变量"></a>Volatile变量</h3><p><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="external">Java 理论与实践: 正确使用 Volatile 变量</a><br><a href="http://www.infoq.com/cn/articles/ftf-java-volatile" target="_blank" rel="external">聊聊并发（一）——深入分析Volatile的实现原理</a>  </p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><a href="http://zl198751.iteye.com/blog/1848575" target="_blank" rel="external">JAVA CAS原理深度分析</a>  </p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p><a href="http://www.ibm.com/developerworks/cn/java/j-jtp11234/" target="_blank" rel="external">Java 理论与实践: 流行的原子</a><br><a href="http://blog.csdn.net/vernonzheng/article/details/8206349" target="_blank" rel="external">Java多线程（二）之Atomic：原子变量与原子类</a> </p>
<h3 id="临界区-critical-section"><a href="#临界区-critical-section" class="headerlink" title="临界区(critical section)"></a>临界区(critical section)</h3><p><a href="http://ifeve.com/race-conditions-and-critical-sections/" target="_blank" rel="external">竞态条件与临界区</a>  </p>
<h3 id="线程本地存储ThreadLocal"><a href="#线程本地存储ThreadLocal" class="headerlink" title="线程本地存储ThreadLocal"></a>线程本地存储ThreadLocal</h3><p><a href="http://blog.csdn.net/ghsau/article/details/15732053" target="_blank" rel="external">Java线程(篇外篇)：线程本地变量ThreadLocal</a><br><a href="http://my.oschina.net/lichhao/blog/111362" target="_blank" rel="external">彻底理解ThreadLocal</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html" target="_blank" rel="external">Class ThreadLocal<t></t></a><br><a href="http://tutorials.jenkov.com/java-concurrency/threadlocal.html" target="_blank" rel="external">Java ThreadLocal</a><br><a href="http://stackoverflow.com/questions/817856/when-and-how-should-i-use-a-threadlocal-variable" target="_blank" rel="external">When and how should I use a ThreadLocal variable?</a>  </p>
<h2 id="终结任务"><a href="#终结任务" class="headerlink" title="终结任务"></a>终结任务</h2><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><a href="http://my.oschina.net/mingdongcheng/blog/139263" target="_blank" rel="external">一张图让你看懂JAVA线程间的状态转换</a><br><a href="http://www.journaldev.com/1044/life-cycle-of-thread-understanding-thread-states-in-java" target="_blank" rel="external">Life Cycle of Thread – Understanding Thread States in Java</a><br><a href="http://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html" target="_blank" rel="external">Java 6 Thread States and Life Cycle</a>  </p>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><p><a href="http://www.infoq.com/cn/articles/java-interrupt-mechanism" target="_blank" rel="external">详细分析Java中断机制</a><br><a href="http://stackoverflow.com/questions/3590000/what-does-java-lang-thread-interrupt-do" target="_blank" rel="external">What does java.lang.Thread.interrupt() do?</a>  </p>
<h3 id="如何停止线程"><a href="#如何停止线程" class="headerlink" title="如何停止线程"></a>如何停止线程</h3><p>stop()方法已经被废弃了。</p>
<p><a href="http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/" target="_blank" rel="external">如何停止一个正在运行的java线程</a><br><a href="http://stackoverflow.com/questions/3194545/how-to-stop-a-java-thread-gracefully" target="_blank" rel="external">How to stop a java thread gracefully?</a>  </p>
<h2 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h2><h3 id="wait-、notify-、notifyAll"><a href="#wait-、notify-、notifyAll" class="headerlink" title="wait()、notify()、notifyAll()"></a>wait()、notify()、notifyAll()</h3><blockquote>
<p>阻塞是进程在等待某种资源,但是不能马上得到，必须等待别的进程释放资源才能继续，属于被动无法得到时间片，内核就切换其它进程运行<br>休眠一般为主动式的放弃一段CPU时间。<br>挂起是运行时间片到了,内核要调度其它进程运行,被动式的失去CPU。（挂起可以被别的进程给抢占导致挂起，也可以自己主动挂起自己。）</p>
</blockquote>
<p>wait()会在等待时将当前任务挂起，等到notify()/notifyAll()发生时，任务才被唤醒。</p>
<p>调用sleep()、yield()时不会释放锁；调用wait()时线程被挂起，对象上的锁也会被释放。</p>
<p>wait()、notify()、notifyAll()属于类Object，不属于Thread。</p>
<p>只能在同步控制方法或者同步控制块（synchronized）中调用wait()、notify()、notifyAll()。而sleep()、yield()可以在非同步控制方法里使用。</p>
<p>notifyAll()比notify()更安全一些。使用notify()时，众多等待同一个锁的任务中只有一个会被唤醒。</p>
<p><a href="http://www.journaldev.com/1037/java-thread-wait-notify-and-notifyall-example" target="_blank" rel="external">Java Thread wait, notify and notifyAll Example</a>  </p>
<h3 id="Lock和Condition"><a href="#Lock和Condition" class="headerlink" title="Lock和Condition"></a>Lock和Condition</h3><p><a href="http://blog.csdn.net/ghsau/article/details/7481142" target="_blank" rel="external">Java线程(九)：Condition-线程通信更高效的方式</a>  </p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><a href="http://www.cnblogs.com/vettel/p/3438257.html" target="_blank" rel="external">哲学家就餐问题</a><br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-deadlock/" target="_blank" rel="external">一个 Linux 上分析死锁的简单方法、死锁的4个必要条件</a><br><a href="http://magustest.com/blog/computer/deadlock-condition-and-how-to-prevent/" target="_blank" rel="external">什么是死锁，死锁的四个必要条件以及处理死锁的策略</a><br><a href="http://ifeve.com/deadlock-prevention/" target="_blank" rel="external">如何避免死锁</a>  </p>
<h2 id="类库中的其他构件"><a href="#类库中的其他构件" class="headerlink" title="类库中的其他构件"></a>类库中的其他构件</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>CountDownLatch，闭锁。</p>
<p>首先给该对象一个初始计数值，每个在该该对象上调用await()的任务会阻塞。当计数值到0时，所有因为await()而阻塞的任务都继续执行。</p>
<p><a href="http://zapldy.iteye.com/blog/746458" target="_blank" rel="external">Java CountDownLatch应用</a><br><a href="http://tutorials.jenkov.com/java-util-concurrent/countdownlatch.html" target="_blank" rel="external">CountDownLatch</a><br><a href="http://www.cnblogs.com/skywang12345/p/3533887.html" target="_blank" rel="external">Java多线程系列–“JUC锁”09之 CountDownLatch原理和示例</a>  </p>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier，关卡，栅栏。</p>
<blockquote>
<p>CountDownLatch和CyclicBarrier的区别<br>(01) CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。<br>(02) CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。</p>
</blockquote>
<p><a href="http://www.cnblogs.com/skywang12345/p/3533995.html" target="_blank" rel="external">Java多线程系列–“JUC锁”10之 CyclicBarrier原理和示例</a><br><a href="http://tutorials.jenkov.com/java-util-concurrent/cyclicbarrier.html" target="_blank" rel="external">CyclicBarrier</a>  </p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html" target="_blank" rel="external">Interface BlockingQueue<e></e></a><br><a href="http://www.infoq.com/cn/articles/java-blocking-queue" target="_blank" rel="external">聊聊并发（七）——Java中的阻塞队列</a>  </p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p><a href="http://www.concretepage.com/java/example_delayqueue_java" target="_blank" rel="external">Examples of DelayQueue in Java</a><br><a href="http://www.cnblogs.com/jobs/archive/2007/04/27/730255.html" target="_blank" rel="external">精巧好用的DelayQueue</a>  </p>
<h3 id="Timer和TimerTask"><a href="#Timer和TimerTask" class="headerlink" title="Timer和TimerTask"></a>Timer和TimerTask</h3><p>这两个在<code>java.util</code>这个包下面。</p>
<blockquote>
<p>Timer和TimerTask可以做为实现线程的第三种方式，前两种方式分别是继承自Thread类和实现Runnable接口。</p>
</blockquote>
<p><a href="http://blog.csdn.net/ghsau/article/details/7436458" target="_blank" rel="external">Java线程(五)：Timer和TimerTask</a>  </p>
<h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p><a href="http://www.importnew.com/7276.html" target="_blank" rel="external">Java ScheduledThreadPoolExecutor延迟或周期性执行任务</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html" target="_blank" rel="external">Class ScheduledThreadPoolExecutor</a>  </p>
<h3 id="信号量Semaphore"><a href="#信号量Semaphore" class="headerlink" title="信号量Semaphore"></a>信号量Semaphore</h3><p><a href="http://www.cnblogs.com/whgw/archive/2011/09/29/2195555.html" target="_blank" rel="external">Java 信号量 Semaphore 介绍</a><br><a href="http://www.javacodegeeks.com/2011/09/java-concurrency-tutorial-semaphores.html" target="_blank" rel="external">Java Concurrency Tutorial – Semaphores</a>  </p>
<h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>用于两个线程之间交换数据。</p>
<p><a href="http://blog.csdn.net/andycpp/article/details/8854593" target="_blank" rel="external">Java线程之Exchanger</a>  </p>
<h2 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h2><blockquote>
<p>使用Lock通常比sychronized高效，sychronized的开销看起来变化范围很大，Lock相对一致。synchronized产生的代码，与Lock所需要的“加锁-try/finally-解锁”相比，可读性更高。</p>
</blockquote>
<h3 id="CopyOnWriteArrayList、CopyOnWriteArraySet"><a href="#CopyOnWriteArrayList、CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArrayList、CopyOnWriteArraySet"></a>CopyOnWriteArrayList、CopyOnWriteArraySet</h3><p>在该类的对象中，写入将导致创建整个底层数组的副本，而原数组保留在原地，使得复制的数组在被修改时，读取操作可以安全的执行。当对副本的修改完成时，会发生一个原子性的操作：用副本替换源数组，使得新的读取操作可以看到这个新的修改。</p>
<p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/CopyOnWriteArrayList.html" target="_blank" rel="external">Class CopyOnWriteArrayList<e></e></a><br><a href="http://www.javamex.com/tutorials/synchronization_concurrency_8_copy_on_write.shtml" target="_blank" rel="external">Java copy-on-write collections</a><br><a href="http://www.cnblogs.com/skywang12345/p/3498497.html" target="_blank" rel="external">Java多线程系列–“JUC集合”03之 CopyOnWriteArraySet</a>  </p>
<h3 id="ConcurrentHashMap、ConcurrentLinkedQueue"><a href="#ConcurrentHashMap、ConcurrentLinkedQueue" class="headerlink" title="ConcurrentHashMap、ConcurrentLinkedQueue"></a>ConcurrentHashMap、ConcurrentLinkedQueue</h3><p><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap" target="_blank" rel="external">聊聊并发（四）——深入分析ConcurrentHashMap</a><br><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue" target="_blank" rel="external">聊聊并发（六）——ConcurrentLinkedQueue的实现原理分析</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentHashMap.html" target="_blank" rel="external">Class ConcurrentHashMap<k,v></k,v></a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html" target="_blank" rel="external">Class ConcurrentLinkedQueue<e></e></a>  </p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p><a href="http://my.oschina.net/u/1445731/blog/420263" target="_blank" rel="external">悲观锁与乐观锁</a><br><a href="http://zh.wikipedia.org/zh/%E4%B9%90%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="external">乐观并发控制</a><br><a href="http://en.wikipedia.org/wiki/Concurrency_control" target="_blank" rel="external">Concurrency control</a><br><a href="http://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_blank" rel="external">Optimistic concurrency control</a></p>
<h3 id="读写锁ReadWriteLock"><a href="#读写锁ReadWriteLock" class="headerlink" title="读写锁ReadWriteLock"></a>读写锁ReadWriteLock</h3><p>适合读多写少的场景。</p>
<p><a href="http://ifeve.com/read-write-locks/" target="_blank" rel="external">Java中的读/写锁</a><br><a href="http://examples.javacodegeeks.com/core-java/util/concurrent/locks-concurrent/readwritelock/java-readwritelock-example/" target="_blank" rel="external">Java ReadWriteLock Example</a><br><a href="http://tutorials.jenkov.com/java-util-concurrent/readwritelock.html" target="_blank" rel="external">ReadWriteLock</a>  </p>
<h2 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h2><p><a href="http://blog.csdn.net/ghsau/article/details/7433673" target="_blank" rel="external">Java线程(三)：线程协作-生产者/消费者问题</a>  </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="http://www.importnew.com/14506.html" target="_blank" rel="external">Java并发的四种风味：Thread、Executor、ForkJoin和Actor</a><br><a href="http://www.journaldev.com/1079/java-thread-tutorial" target="_blank" rel="external">Java Thread and Multithreading Tutorial</a><br><a href="http://segmentfault.com/a/1190000000389806" target="_blank" rel="external">JAVA 多线程和并发基础面试问答</a><br><a href="http://www.journaldev.com/1162/java-multi-threading-concurrency-interview-questions-with-answers" target="_blank" rel="external">Java Multi-Threading and Concurrency Interview Questions with Answers</a><br><a href="http://en.wikipedia.org/wiki/Monitor_%28synchronization%29" target="_blank" rel="external">Monitor (synchronization)</a><br><a href="http://ifeve.com/talk-concurrency/" target="_blank" rel="external">聊聊并发</a>  </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-05-27&lt;/p&gt;
&lt;p&gt;看了《Java编程思想 第4版》&lt;code&gt;并发&lt;/code&gt;这一章，觉得有必要整理一下其中的概念。&lt;/p&gt;
&lt;h2 id=&quot;并发&quot;&gt;&lt;a href=&quot;#并发&quot; class=&quot;headerlink&quot; title=&quot;并发&quot;&gt;&lt;/a&gt;并发&lt;/h2&gt;&lt;p&gt;为什么要并发？ 比如因为IO操作遇到了阻塞，CPU可以转去执行其他线程，这时并发的优点就显示出来了：更高效的利用CPU，提高程序的响应速度。&lt;/p&gt;
&lt;p&gt;Java的线程机制是抢占式的，会为每个线程分配时间片。&lt;/p&gt;
&lt;h3 id=&quot;线程中断与上下文切换&quot;&gt;&lt;a href=&quot;#线程中断与上下文切换&quot; class=&quot;headerlink&quot; title=&quot;线程中断与上下文切换&quot;&gt;&lt;/a&gt;线程中断与上下文切换&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/ktgu/p/3529144.html&quot;&gt;并发编程 - 多线程的代价及上下文切换&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ifeve.com/context-switching-and-multi-processor/&quot;&gt;上下文切换与多处理器&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Java本身还有另外一个“线程中断”&quot;&gt;&lt;a href=&quot;#Java本身还有另外一个“线程中断”&quot; class=&quot;headerlink&quot; title=&quot;Java本身还有另外一个“线程中断”&quot;&gt;&lt;/a&gt;Java本身还有另外一个“线程中断”&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/java-interrupt-mechanism&quot;&gt;详细分析Java中断机制&lt;/a&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.letiantian.me/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>基于SVD的协同过滤</title>
    <link href="http://www.letiantian.me/2015-05-26-a-guide-to-svd-for-collaborative-filtering/"/>
    <id>http://www.letiantian.me/2015-05-26-a-guide-to-svd-for-collaborative-filtering/</id>
    <published>2015-05-26T02:11:06.000Z</published>
    <updated>2015-05-26T08:50:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-05-26</p>
<p>本文是下面这篇论文的阅读笔记：</p>
<blockquote>
<p>Ma C C. A Guide to Singular Value Decomposition for Collaborative Filtering[J]. 2008.</p>
</blockquote>
<p>注意，这里的SVD，和经典的分解为3个矩阵的方法是不一样的。</p>
<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>直接使用传统的SVD进行协同过滤的的效果可能会很差，所以考虑一些SVD的变体来进行协同过滤。</p>
<p>用户可以对电影评分，分数范围是1到5。一般，一个用户不会给所有的电影都评分，有些用户评分的电影很多，有些用户只给很少的电影打评分。</p>
<p>一般评分矩阵中的0代表着对应的用户没有给对应的物品（电影）评分，0并不能看作分值。</p>
<p>设[latex]V[/latex]是大小为<code>n×m</code>的评分矩阵，n个用户，m个电影。[latex]I[/latex]也是大小为<code>n×m</code>的矩阵，其元素的值只有0和1，若[latex]I_{ij}[/latex]为1，则用户i给物品j打过分，这也意味着[latex]V_{ij}[/latex]不为0；若[latex]I_{ij}[/latex]为0,则用户i没给物品j打过分，这也意味着[latex]V_{ij}[/latex]为0。故矩阵[latex]I[/latex]是矩阵[latex]V[/latex]的指示器（indicator）。矩阵[latex]V[/latex]也可以以稀疏矩阵的形式保存，只保存打过分的数据。</p>
<p>矩阵[latex]V[/latex]作为协同过滤算法的训练数据，而协同过滤算法的目标是预测某个用户对某个物品的评分（该用户之前没有对该物品评分）。</p>
<p>算法的评测标准：一般是比较真实评分和预测的评分之间的误差，例如<a href="http://en.wikipedia.org/wiki/Mean_squared_error" target="_blank" rel="external">Mean squared error</a>、<a href="https://www.kaggle.com/wiki/RootMeanSquaredError" target="_blank" rel="external">Root Mean Squared Error</a>。</p>
<h2 id="算法1：Batch-learning-of-Singular-Value-Decomposition"><a href="#算法1：Batch-learning-of-Singular-Value-Decomposition" class="headerlink" title="算法1：Batch learning of Singular Value Decomposition"></a>算法1：Batch learning of Singular Value Decomposition</h2><p>设n个用户，m个物品，<code>n×m</code>大小的矩阵[latex]V[/latex]是评分矩阵，大小为<code>n×m</code>的矩阵[latex]I[/latex]作为[latex]V[/latex]指示器。SVD算法的目标是找到两个矩阵：<code>f×n</code>大小的[latex]U[/latex]作为用户的特征矩阵，<code>f×m</code>大小的[latex]M[/latex]作为物品的特征矩阵。预测函数[latex]p[/latex]根据[latex]U[/latex]和[latex]M[/latex]预测评分。</p>
<p>[latex]V_{ij}[/latex]的预测值为：</p>
<p>[latex]<br>p(U_{i}, M_{j})<br>[/latex]</p>
<p>其中，[latex]U_{i}[/latex]为用户i的特征向量（feature vector，不是eigenvector，f个元素），[latex]M_{j}[/latex]为物品j的特征向量（f个元素），这两个特征向量从矩阵[latex]U[/latex]和[latex]M[/latex]中直接拿就行了。</p>
<p>然后，我们要最小化下面的式子：</p>
<p><img src="/content/images/2015/05/2015-05-26-svd-01.png" alt=""></p>
<p>其中，[latex]k_{u}[/latex]和[latex]k_{m}[/latex]是防止过拟合的正则化系数，是两个已知的擦书，需要我们自己事先指定。</p>
<p>函数[latex]p[/latex]的一般实现如下：</p>
<p>[latex]<br>p(U_{i}, M_{j}) = U_{i}^{T}M_{j}<br>[/latex]<br>就是两个向量的内积（数量积）。</p>
<p>不过，V中的评分是在<code>[a,b]</code>这个范围里，其中<code>a</code>是最小的评分，<code>b</code>是最大的评分。所以预测函数优化为：</p>
<p><img src="/content/images/2015/05/2015-05-26-svd-02.png" alt=""></p>
<p>好了，现在对于<code>公式(2)</code>，[latex]I,V,n,m,p,k_{u},k_{m}[/latex]都是已知的，通过最小化<code>公式(2)</code>就可以得到[latex]U和M[/latex]。</p>
<p>可以用梯度下降解决这个问题，下面两个式子是负向的梯度：</p>
<p><img src="/content/images/2015/05/2015-05-26-svd-03.png" alt=""></p>
<p>而梯度很明显是：</p>
<p>[latex]<br>\nabla{U_{i}} = \frac{\partial{E}}{\partial{U_{i}}} \\<br>\nabla{M_{j}} = \frac{\partial{E}}{\partial{M_{j}}}<br>[/latex]</p>
<p>由此，得到下面的算法：</p>
<ul>
<li><p>给矩阵U、M赋初始值（例如使用随机值），建议使用下面的方法赋值：<br><img src="/content/images/2015/05/2015-05-26-svd-04.png" alt=""><br>其中，[latex]\bar{V}[/latex]是指V中评分的平均值，a是i所有评分的最小值，f是用户和物品在新特征空间下的维度，<code>n(r)</code>是基于区间[-r, r]生成均匀分布的随机数，r取一个较小的值就行了。</p>
</li>
<li><p>设置学习速率[latex]\mu[/latex]，重复下面两个步骤直到评估方法RMSE的值开始上升：<br>(a). 计算梯度[latex]\nabla{U}和\nabla{M}[/latex]<br>(b). 更新U和M：[latex]U\leftarrow U- \mu \nabla{U}，~~M\leftarrow M- \mu \nabla{M}[/latex]  </p>
</li>
</ul>
<p>迭代停止的判断条件可以有很多，例如RMSE基本不变，或者U、M基本不变时停止迭代。</p>
<p>批量学习（Batch learning）是SVD的标准方法。</p>
<h2 id="算法2：Incomplete-incremental-learning-of-Singular-Value-Decomposition"><a href="#算法2：Incomplete-incremental-learning-of-Singular-Value-Decomposition" class="headerlink" title="算法2：Incomplete incremental learning of Singular Value Decomposition"></a>算法2：Incomplete incremental learning of Singular Value Decomposition</h2><p>对用户i，目标函数是：<br><img src="/content/images/2015/05/2015-05-26-svd-05.png" alt=""><br>负方向梯度为：<br><img src="/content/images/2015/05/2015-05-26-svd-06.png" alt=""><br>对于用户i来说，如果[latex]I_{ij}=0[/latex]，即用户i未对物品j评分，则[latex]M_{j}[/latex]的梯度为0，不会造成M的更新。</p>
<p>算法如下：</p>
<p><img src="/content/images/2015/05/2015-05-26-svd-07.png" alt=""></p>
<h2 id="算法3：Complete-incremental-learning-of-Singular-Value-Decomposition"><a href="#算法3：Complete-incremental-learning-of-Singular-Value-Decomposition" class="headerlink" title="算法3：Complete incremental learning of Singular Value Decomposition"></a>算法3：Complete incremental learning of Singular Value Decomposition</h2><p>这个方法中的目标函数，以及对应的负方向梯度如下：<br><img src="/content/images/2015/05/2015-05-26-svd-08.png" alt=""></p>
<p>算法如下：<br><img src="/content/images/2015/05/2015-05-26-svd-09.jpg" alt=""></p>
<h2 id="算法4：Batch-learning-of-SVD-with-Momentum"><a href="#算法4：Batch-learning-of-SVD-with-Momentum" class="headerlink" title="算法4：Batch learning of SVD with Momentum"></a>算法4：Batch learning of SVD with Momentum</h2><p>这是对算法1的修改：<br><img src="/content/images/2015/05/2015-05-26-svd-10.png" alt=""></p>
<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><blockquote>
<p>Ma C C. A Guide to Singular Value Decomposition for Collaborative Filtering[J]. 2008.</p>
</blockquote>
<p>本文的内容都来自这篇论文，论文中<strong>Further Improvements</strong>章节还提到了在目标函数中添加针对用户和物品的偏置向量，在得到U和M的同时，得到偏置向量，这种方法的评估效果会更好些。</p>
<hr>
<blockquote>
<p>Paterek A. Improving regularized singular value decomposition for collaborative filtering[C]//Proceedings of KDD cup and workshop. 2007, 2007: 5-8.</p>
</blockquote>
<p>里面提到了若干基于SVD的算法，还提到了一些有趣的协同过滤算法，例如基于聚类的协同过滤算法。</p>
<hr>
<blockquote>
<p>Funk, Simon. “Netflix update: Try this at home.” (2006).</p>
</blockquote>
<p>放在博客里的一篇有名的文章。</p>
<hr>
<blockquote>
<p>Koren, Yehuda. “Factorization meets the neighborhood: a multifaceted collaborative filtering model.” Proceedings of the 14th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2008.</p>
</blockquote>
<p>SVD++就在这里。 关于SVD++：<br><a href="http://www.recsyswiki.com/wiki/SVD%2B%2B" target="_blank" rel="external">SVD++ - recsyswiki</a>、<br><a href="http://superjom.duapp.com/machine-learning/svd1.html" target="_blank" rel="external">推荐系统常用模型(2) – SVD/SVD++</a>、<br><a href="http://www.quora.com/Whats-the-difference-between-SVD-and-SVD++" target="_blank" rel="external">What’s the difference between SVD and SVD++?</a>。</p>
<hr>
<blockquote>
<p>Koren, Yehuda. “The bellkor solution to the netflix grand prize.” Netflix prize documentation 81 (2009).</p>
</blockquote>
<p>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-05-26&lt;/p&gt;
&lt;p&gt;本文是下面这篇论文的阅读笔记：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ma C C. A Guide to Singular Value Decomposition for Collaborative Filtering[J]. 200
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.letiantian.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>基于贝叶斯的文本分类系统的数据库设计</title>
    <link href="http://www.letiantian.me/2015-05-25-bayes-text-classify-system-db-design/"/>
    <id>http://www.letiantian.me/2015-05-25-bayes-text-classify-system-db-design/</id>
    <published>2015-05-25T14:59:40.000Z</published>
    <updated>2015-05-25T15:23:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-05-25</p>
<p>本博客中贝叶斯相关的文章：</p>
<p><a href="/2014-05-20-naive-bayes/">使用朴素贝叶斯分类器划分邮件</a><br><a href="/2014-10-12-three-models-of-naive-nayes/">朴素贝叶斯的三个常用模型：高斯、多项式、伯努利</a><br><a href="/2015-03-31-bayes-classifier-for-text/">基于贝叶斯的文本分类实战</a>  </p>
<p>本文以使用<strong>多项式贝叶斯模型</strong>为例。该模型在文本分类这一领域的正确率一般都比较高，而且有一个很大的有点，就是支持增量训练。</p>
<p>在该模型下：</p>
<pre><code class="text">先验概率P(c)= 类c下单词总数/整个训练样本的单词总数

类条件概率P(tk|c)=(类c下单词tk在该类下各个文档中出现过的次数之和+1)/(类c下单词总数+|V|)
</code></pre>
<p><code>|V|</code>是整个数据集中单词去重后的数量。</p>
<p>下面的数据来自<a href="http://blog.163.com/jiayouweijiewj@126/blog/static/1712321772010102802635243/" target="_blank" rel="external">基于naive bayes的文本分类算法</a>。<em>这篇文章中有一个小的计算失误（在计算新样本的类别时）。</em></p>
<table><thead><tr><th>文档ID</th><th>文档内容</th><th>文档类别</th></tr></thead><tbody><tr><td>1</td><td>Chinese Beijing Chinese</td><td>yes</td></tr><tr><td>2</td><td>Chinese Chinese Shanghai</td><td>yes</td></tr><tr><td>3</td><td>Chinese Macao</td><td>yes</td></tr><tr><td>4</td><td>Tokyo Japan Chinese</td><td>no</td></tr></tbody></table>


<p>由上面可以得到：</p>
<table><caption>单词计数表</caption><thead><tr><th>单词\文档类别</th><th>yes</th><th>no</th></tr></thead><tbody><tr><td>Chinese</td><td>5</td><td>1</td></tr><tr><td>Beijing</td><td>1</td><td>0</td></tr><tr><td>Shanghai</td><td>1</td><td>0</td></tr><tr><td>Macao</td><td>1</td><td>0</td></tr><tr><td>Japan</td><td>0</td><td>1</td></tr><tr><td>Tokyo</td><td>0</td><td>1</td></tr></tbody></table>


<table><caption>汇总表</caption><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>单词总数</td><td>11</td></tr><tr><td>单词去重总数</td><td>6</td></tr><tr><td>属于yes的文档下的单词总数</td><td>8</td></tr><tr><td>属于no的文档下的单词总数</td><td>3</td></tr><tr><td>属于yes的文档数</td><td>3</td></tr><tr><td>属于no的文档数</td><td>1</td></tr></tbody></table>

<p>根据上面的公式，有</p>
<pre><code class="text">P(yes) = 8/11
p(no)  = 3/11
P(Chinese | yes)=(5+1)/(8+6)=6/14=3/7  
P(Japan | yes)=P(Tokyo | yes)= (0+1)/(8+6)=1/14  
P(Chinese|no)=(1+1)/(3+6)=2/9  
P(Japan|no)=P(Tokyo| no) =(1+1)/(3+6)=2/9
</code></pre>
<p>所以，对于新样本<code>Chinese Chinese Chinese Tokyo Japan</code>，有：</p>
<pre><code class="text">P(yes | d)
=P(Chinese|yes)×P(Japan|yes)×P(Tokyo|yes)*P(c)
=(3/7)^3×1/14×1/14×8/11
=216/739508
≈0.00029208  

P(no | d)
= P(Chinese|no)×P(Japan|no)×P(Tokyo|no)*P(c)
=(2/9)3×2/9×2/9×3/11
=96/649539
≈0.00014780
</code></pre>
<p>故新样本属于yes这个分类。</p>
<p>根据上面的思路，可知数据库中需要两个表，一个单词计数表，一个汇总表，这两个表和上面的两个表格相同。</p>
<p>伯努利模型类似。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-05-25&lt;/p&gt;
&lt;p&gt;本博客中贝叶斯相关的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2014-05-20-naive-bayes/&quot;&gt;使用朴素贝叶斯分类器划分邮件&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/2014-10-12-three-models-of-naiv
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.letiantian.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>矩阵分解在推荐系统中的应用：NMF和经典SVD实战</title>
    <link href="http://www.letiantian.me/2015-05-25-nmf-svd-recommend/"/>
    <id>http://www.letiantian.me/2015-05-25-nmf-svd-recommend/</id>
    <published>2015-05-25T11:25:06.000Z</published>
    <updated>2015-05-26T01:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-05-25</p>
<p>本文以NMF和经典SVD为例，讲一讲矩阵分解在推荐系统中的应用。</p>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><table><thead><br><tr><th>item\user</th><th>Ben</th><th>Tom</th><th>John</th><th>Fred</th></tr></thead><br><tbody><br><tr><td>item 1</td><td>5</td><td>5</td><td>0</td><td>5</td></tr><br><tr><td>item 2</td><td>5</td><td>0</td><td>3</td><td>4</td></tr><br><tr><td>item 3</td><td>3</td><td>4</td><td>0</td><td>3</td></tr><br><tr><td>item 4</td><td>0</td><td>0</td><td>5</td><td>3</td></tr><br><tr><td>item 5</td><td>5</td><td>4</td><td>4</td><td>5</td></tr><br><tr><td>item 6</td><td>5</td><td>4</td><td>5</td><td>5</td></tr><br></tbody></table>

<table><br><thead><tr><th>user\item</th><th>item 1</th><th>item 2</th><th>item 3</th><th>item 4</th><th>item 5</th><th>item 6</th></tr></thead><br><tbody><br><tr><td>Ben</td><td>5</td><td>5</td><td>3</td><td>0</td><td>5</td><td>5</td></tr><br><tr><td>Tom</td><td>5</td><td>0</td><td>4</td><td>0</td><td>4</td><td>4</td></tr><br><tr><td>John</td><td>0</td><td>3</td><td>0</td><td>5</td><td>4</td><td>5</td></tr><br><tr><td>Fred</td><td>5</td><td>4</td><td>3</td><td>3</td><td>5</td><td>5</td></tr><br></tbody></table>

<h2 id="NMF"><a href="#NMF" class="headerlink" title="NMF"></a>NMF</h2><p>关于NMF，在<a href="/2014-12-22-latent-factor-model-and-nmf/">隐语义模型和NMF（非负矩阵分解）</a>已经有过介绍。</p>
<h3 id="用户和物品的主题分布"><a href="#用户和物品的主题分布" class="headerlink" title="用户和物品的主题分布"></a>用户和物品的主题分布</h3><pre><code># !/usr/bin/python2.7
# coding: UTF-8
import numpy as np
from sklearn.decomposition import NMF
import matplotlib.pyplot as plt

RATE_MATRIX = np.array(
    [[5, 5, 3, 0, 5, 5],
     [5, 0, 4, 0, 4, 4],
     [0, 3, 0, 5, 4, 5],
     [5, 4, 3, 3, 5, 5]]
)

nmf = NMF(n_components=2)  # 设有2个隐主题
user_distribution = nmf.fit_transform(RATE_MATRIX)
item_distribution = nmf.components_

print &#39;用户的主题分布：&#39;
print user_distribution
print &#39;物品的主题分布：&#39;
print item_distribution
</code></pre><p>运行后输出：</p>
<pre><code class="text">用户的主题分布：
[[ 2.20884275  0.84137492]
 [ 2.08253282 -0.        ]
 [-0.          3.18154406]
 [ 1.84992603  1.60839505]]
物品的主题分布：
[[ 2.4129931   1.02524235  1.62258152  0.          1.80111078  1.69591943]
 [ 0.0435741   1.13506094  0.          1.54526337  1.21253494  1.48756118]]
</code></pre>
<p>可视化物品的主题分布：</p>
<pre><code># !/usr/bin/python2.7
# coding: UTF-8
import numpy as np
from sklearn.decomposition import NMF
import matplotlib.pyplot as plt

RATE_MATRIX = np.array(
    [[5, 5, 3, 0, 5, 5],
     [5, 0, 4, 0, 4, 4],
     [0, 3, 0, 5, 4, 5],
     [5, 4, 3, 3, 5, 5]]
)

nmf = NMF(n_components=2)
user_distribution = nmf.fit_transform(RATE_MATRIX)
item_distribution = nmf.components_

item_distribution = item_distribution.T
plt.plot(item_distribution[:, 0], item_distribution[:, 1], &quot;b*&quot;)
plt.xlim((-1, 3))
plt.ylim((-1, 3))

plt.title(u&#39;the distribution of items (NMF)&#39;)
count = 1
for item in item_distribution:
    plt.text(item[0], item[1], &#39;item &#39;+str(count), bbox=dict(facecolor=&#39;red&#39;, alpha=0.2),)
    count += 1

plt.show()
</code></pre><p>结果：<br><img src="/content/images/2015/05/2015-05-25-nmf-svd-item-01.jpg" alt=""></p>
<p>从距离的角度来看，item 5和item 6比较类似；从余弦相似度角度看，item 2、5、6 比较相似，item 1、3比较相似。</p>
<p>可视化用户的主题分布：</p>
<pre><code># !/usr/bin/python2.7
# coding: UTF-8
import numpy as np
from sklearn.decomposition import NMF
import matplotlib.pyplot as plt

RATE_MATRIX = np.array(
    [[5, 5, 3, 0, 5, 5],
     [5, 0, 4, 0, 4, 4],
     [0, 3, 0, 5, 4, 5],
     [5, 4, 3, 3, 5, 5]]
)

nmf = NMF(n_components=2)
user_distribution = nmf.fit_transform(RATE_MATRIX)
item_distribution = nmf.components_

users = [&#39;Ben&#39;, &#39;Tom&#39;, &#39;John&#39;, &#39;Fred&#39;]
zip_data = zip(users, user_distribution)

plt.title(u&#39;the distribution of users (NMF)&#39;)
plt.xlim((-1, 3))
plt.ylim((-1, 4))
for item in zip_data:
    user_name = item[0]
    data = item[1]
    plt.plot(data[0], data[1], &quot;b*&quot;)
    plt.text(data[0], data[1], user_name, bbox=dict(facecolor=&#39;red&#39;, alpha=0.2),)

plt.show()
</code></pre><p>结果：</p>
<p><img src="/content/images/2015/05/2015-05-25-nmf-svd-user-01.jpg" alt=""></p>
<p>从距离的角度来看，Fred、Ben、Tom的口味差不多；从余弦相似度角度看，Fred、Ben、Tom的口味还是差不多。</p>
<h3 id="如何推荐"><a href="#如何推荐" class="headerlink" title="如何推荐"></a>如何推荐</h3><p>现在对于用户A，如何向其推荐物品呢？</p>
<p><strong>方法1：</strong> 找出与用户A最相似的用户B，将B评分过的、评分较高、A没评分过的的若干物品推荐给A。</p>
<p><strong>方法2：</strong> 找出用户A评分较高的若干物品，找出与这些物品相似的、且A没评分的若干物品推荐给A。</p>
<p><strong>方法3：</strong> 找出用户A最感兴趣的k个主题，找出最符合这k个主题的、且A没评分的若干物品推荐给A。</p>
<p><strong>方法4：</strong> 由NMF得到的两个矩阵，重建评分矩阵。例如：</p>
<pre><code># !/usr/bin/python2.7
# coding: UTF-8
import numpy as np
from sklearn.decomposition import NMF
import matplotlib.pyplot as plt

RATE_MATRIX = np.array(
    [[5, 5, 3, 0, 5, 5],
     [5, 0, 4, 0, 4, 4],
     [0, 3, 0, 5, 4, 5],
     [5, 4, 3, 3, 5, 5]]
)

RATE_MATRIX[1, 2] = 0  # 对评分矩阵略做修改
print &#39;新评分矩阵：&#39;
print RATE_MATRIX

nmf = NMF(n_components=2)
user_distribution = nmf.fit_transform(RATE_MATRIX)
item_distribution = nmf.components_

reconstruct_matrix = np.dot(user_distribution, item_distribution)
filter_matrix = RATE_MATRIX &lt; 1e-6  # 小于0
print &#39;重建矩阵，并过滤掉已经评分的物品：&#39;
print reconstruct_matrix*filter_matrix
</code></pre><p>运行结果：</p>
<pre><code class="text">新评分矩阵：
[[5 5 3 0 5 5]
 [5 0 0 0 4 4]
 [0 3 0 5 4 5]
 [5 4 3 3 5 5]]
重建矩阵，并过滤掉已经评分的物品：
[[ 0.          0.          0.          0.80443133  0.          0.        ]
 [ 0.          2.19148602  1.73560797  0.          0.          0.        ]
 [ 0.02543568  0.          0.48692891  0.          0.          0.        ]
 [ 0.          0.          0.          0.          0.          0.        ]]
</code></pre>
<p>对于Tom（评分矩阵的第2行），其未评分过的物品是item 2、item 3、item 4。item 2的推荐值是<code>2.19148602</code>，item 3的推荐值是<code>1.73560797</code>，item 4的推荐值是<code>0</code>，若要推荐一个物品，推荐item 2。</p>
<h3 id="如何处理有评分记录的新用户"><a href="#如何处理有评分记录的新用户" class="headerlink" title="如何处理有评分记录的新用户"></a>如何处理有评分记录的新用户</h3><p>NMF是将非负矩阵V分解为两个非负矩阵W和H：</p>
<pre><code>V = W×H
</code></pre><p>在本文上面的实现中，V对应评分矩阵，W是用户的主题分布，H是物品的主题分布。</p>
<p>对于有评分记录的新用户，如何得到其主题分布？</p>
<p><strong>方法1：</strong> 有评分记录的新用户的评分数据放入评分矩阵中，使用NMF处理新的评分矩阵。</p>
<p><strong>方法2：</strong> 物品的主题分布矩阵H保持不变，将V更换为新用户的评分组成的行向量，求W即可。</p>
<p>下面尝试一下方法2。</p>
<p>设新用户Bob的评分记录为：</p>
<pre><code>[5,5,0,0,0,5]
</code></pre><pre><code># !/usr/bin/python2.7
# coding: UTF-8
import numpy as np
from sklearn.decomposition import NMF
import matplotlib.pyplot as plt

RATE_MATRIX = np.array(
    [[5, 5, 3, 0, 5, 5],
     [5, 0, 4, 0, 4, 4],
     [0, 3, 0, 5, 4, 5],
     [5, 4, 3, 3, 5, 5]]
)

nmf = NMF(n_components=2)
user_distribution = nmf.fit_transform(RATE_MATRIX)
item_distribution = nmf.components_

bob = [5, 5, 0, 0, 0, 5]
print &#39;Bob的主题分布：&#39;
print nmf.transform(bob)
</code></pre><p>运行结果是：</p>
<pre><code class="text">Bob的主题分布：
[[ 1.37800534  0.69236738]]
</code></pre>
<p><img src="/content/images/2015/05/2015-05-25-nmf-svd-user-02.jpg" alt=""></p>
<h2 id="经典SVD"><a href="#经典SVD" class="headerlink" title="经典SVD"></a>经典SVD</h2><p>关于SVD的一篇好文章：<a href="http://www.cnblogs.com/leftnoteasy/archive/2011/01/19/svd-and-applications.html" target="_blank" rel="external">强大的矩阵奇异值分解(SVD)及其应用</a>。</p>
<p>相关分析与上面类似，这里就直接上代码了。</p>
<pre><code># !/usr/bin/python2.7
# coding: UTF-8
import numpy as np
from scipy.sparse.linalg import svds
from scipy import sparse
import matplotlib.pyplot as plt

def vector_to_diagonal(vector):
    &quot;&quot;&quot;
    将向量放在对角矩阵的对角线上
    :param vector:
    :return:
    &quot;&quot;&quot;
    if (isinstance(vector, np.ndarray) and vector.ndim == 1) or \
            isinstance(vector, list):
        length = len(vector)
        diag_matrix = np.zeros((length, length))
        np.fill_diagonal(diag_matrix, vector)
        return diag_matrix
    return None

RATE_MATRIX = np.array(
    [[5, 5, 3, 0, 5, 5],
     [5, 0, 4, 0, 4, 4],
     [0, 3, 0, 5, 4, 5],
     [5, 4, 3, 3, 5, 5]]
)

RATE_MATRIX = RATE_MATRIX.astype(&#39;float&#39;)
U, S, VT = svds(sparse.csr_matrix(RATE_MATRIX),  k=2, maxiter=200) # 2个隐主题
S = vector_to_diagonal(S)

print &#39;用户的主题分布：&#39;
print U
print &#39;奇异值：&#39;
print S
print &#39;物品的主题分布：&#39;
print VT
print &#39;重建评分矩阵，并过滤掉已经评分的物品：&#39;
print np.dot(np.dot(U, S), VT) * (RATE_MATRIX &lt; 1e-6)
</code></pre><p>运行结果：</p>
<pre><code class="text">用户的主题分布：
[[-0.22279713  0.57098887]
 [-0.51723555  0.4274751 ]
 [ 0.82462029  0.38459931]
 [ 0.05319973  0.58593526]]
奇异值：
[[  6.39167145   0.        ]
 [  0.          17.71392084]]
物品的主题分布：
[[-0.53728743  0.24605053 -0.40329582  0.67004393  0.05969518  0.18870999]
 [ 0.44721867  0.35861531  0.29246336  0.20779151  0.50993331  0.53164501]]
重建评分矩阵，并过滤掉已经评分的物品：
[[ 0.          0.          0.          1.14752376  0.          0.        ]
 [ 0.          1.90208543  0.         -0.64171368  0.          0.        ]
 [ 0.21491237  0.         -0.13316888  0.          0.          0.        ]
 [ 0.          0.          0.          0.          0.          0.        ]]
</code></pre>
<p>可视化一下：<br><img src="/content/images/2015/05/2015-05-25-nmf-svd-user-item-svd.jpg" alt=""></p>
<h2 id="经典SVD-协同过滤"><a href="#经典SVD-协同过滤" class="headerlink" title="经典SVD + 协同过滤"></a>经典SVD + 协同过滤</h2><p><code>0</code>代表没有评分，但是上面的方法（<code>如何推荐</code>这一节的<code>方法4</code>）又确实把0看作了评分，所以最终得到的只是一个推荐值（而且总体都偏小），而无法当作预测的评分。在<a href="http://stats.stackexchange.com/questions/31096/how-do-i-use-the-svd-in-collaborative-filtering" target="_blank" rel="external">How do I use the SVD in collaborative filtering?</a>有这方面的讨论。</p>
<h3 id="SVD简要介绍"><a href="#SVD简要介绍" class="headerlink" title="SVD简要介绍"></a>SVD简要介绍</h3><p>SVD的目标是将<code>m*n</code>大小的矩阵A分解为三个矩阵的乘积：</p>
<p>[latex]<br>A = U <em> S </em> V^{T}<br>[/latex]</p>
<p>U和V都是正交矩阵，大小分别是<code>m*m</code>、<code>n*n</code>。S是一个对角矩阵，大小是<code>m*n</code>，对角线存放着奇异值，从左上到右下依次减小，设奇异值的数量是<code>r</code>。</p>
<p>取<code>k</code>，<code>k&lt;&lt;r</code>。</p>
<p>取得[latex]U[/latex]的前k列得到[latex]U_{k}[/latex]，[latex]S[/latex]的前k个奇异值对应的方形矩阵得到[latex]S_{k}[/latex]，[latex]V^{T}[/latex]的前k行得到[latex]V^{T}_{k}[/latex]，于是有</p>
<p>[latex]<br>A_{k} = U_{k} <em> S_{k} </em> V^{T}_{k}<br>[/latex]</p>
<p>[latex]A_{k}[/latex]可以认为是[latex]A[/latex]的近似。</p>
<p>下面的算法将协同过滤和SVD结合了起来。</p>
<h3 id="Item-based-Filtering-Enhanced-by-SVD"><a href="#Item-based-Filtering-Enhanced-by-SVD" class="headerlink" title="Item-based Filtering Enhanced by SVD"></a>Item-based Filtering Enhanced by SVD</h3><p>这个算法来自下面这篇论文：</p>
<blockquote>
<p>Vozalis M G, Margaritis K G. Applying SVD on Generalized Item-based Filtering[J]. IJCSA, 2006, 3(3): 27-51.</p>
</blockquote>
<p><strong>1、</strong> 设评分矩阵为<code>R</code>，大小为<code>m*n</code>，m个用户，n个物品。<code>R</code>中元素[latex]r_{ij}[/latex]代表着用户[latex]u_{i}[/latex]对物品[latex]i_{j}[/latex]的评分。</p>
<p><strong>2、</strong> 预处理<code>R</code>，消除掉其中未评分数据（即值为0）的评分。</p>
<ul>
<li>计算<code>R</code>中每一行的平均值（平均值的计算中不包括值为0的评分），令[latex]R_{filled-in}=R[/latex]，然后将[latex]R_{filled-in}[/latex]中的0设置为该行的平均值。</li>
<li>计算<code>R</code>中每一列的平均值（平均值的计算中不包括值为0的评分）[latex]r_{i}[/latex]，[latex]R_{filled-in}[/latex]中的所有元素减去对应的[latex]r_{i}[/latex]，得到正规化的矩阵[latex]R_{norm}[/latex]。(norm，即normalized)。</li>
</ul>
<p><strong>3、</strong> 对[latex]R_{norm}[/latex]进行奇异值分解，得到：<br>[latex]<br>R_{norm} = U <em> S </em> V^{T}<br>[/latex]</p>
<p><strong>4、</strong> 设正整数k，取得[latex]U[/latex]的前k列得到[latex]U_{k}[/latex]，[latex]S[/latex]的前k个奇异值对应的方形矩阵得到[latex]S_{k}[/latex]，[latex]V^{T}[/latex]的前k行得到[latex]V^{T}_{k}[/latex]，于是有</p>
<p>[latex]<br>R_{red} = U_{k} <em> S_{k} </em> V^{T}_{k}<br>[/latex]</p>
<p>red，即dimensionality reduction中的reduction。可以认为k是指最重要的k个主题。定义[latex]R_{red}[/latex]中元素[latex]rr_{ij}[/latex]用户i对物品j在矩阵[latex]R_{red}[/latex]中的值。</p>
<p><strong>5、</strong> [latex] U_{k} <em> S_{k}^{\frac{1}{2}}[/latex]，是用户相关的降维后的数据，其中的每行代表着对应用户在新特征空间下位置。[latex] S_{k}^{\frac{1}{2}}</em>V^{T}_{k}[/latex]，是物品相关的降维后的数据，其中的每列代表着对应物品在新特征空间下的位置。</p>
<p>[latex] S_{k}^{\frac{1}{2}}*V^{T}_{k}[/latex]中的元素[latex]mr_{ij}[/latex]代表<code>物品j</code>在新空间下<code>维度i</code>中的值，也可以认为是<code>物品j</code>属于<code>主题i</code>的程度。（共有k个主题）。</p>
<p><strong>6、</strong> 获取物品之间相似度。</p>
<ul>
<li><p>根据[latex] S_{k}^{\frac{1}{2}}*V^{T}_{k}[/latex]计算物品之间的相似度，例如使用余弦相似度计算物品j和f的相似度：<br><img src="/content/images/2015/05/2015-05-25-nmf-svd-formula-01.png" alt=""></p>
</li>
<li><p>相似度计算出来后就可以得到每个物品最相似的若干物品了。</p>
</li>
</ul>
<p><strong>7、</strong> 使用下面的公式预测用户a对物品j的评分：<br><img src="/content/images/2015/05/2015-05-25-nmf-svd-formula-02.png" alt=""><br>这个公式里有些变量的使用和上面的冲突了（例如k）。<br>[latex]l[/latex]是指取物品j最相似的[latex]l[/latex]个物品。<br>[latex]mr_{ij}[/latex]代表<code>物品j</code>在新空间下<code>维度i</code>中的值，也可以认为是<code>物品j</code>属于<code>主题i</code>的程度。<br>[latex]sim_{jk}[/latex]是物品j和物品k的相似度。<br>[latex]R_{red}[/latex]中元素[latex]rr_{ak}[/latex]是用户a对物品k在矩阵[latex]R_{red}[/latex]中对应的评分。[latex]\bar{r_{a}}[/latex]是指用户a在评分矩阵[latex]R[/latex]中评分的平均值（平均值的计算中不包括值为0的评分）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.igvita.com/2007/01/15/svd-recommendation-system-in-ruby/" target="_blank" rel="external">SVD Recommendation System in Ruby</a>  这篇文章使用的数据来自该链接，里面处理新用户的方法表示没看懂。</p>
<p><a href="http://stats.stackexchange.com/questions/31096/how-do-i-use-the-svd-in-collaborative-filtering" target="_blank" rel="external">How do I use the SVD in collaborative filtering?</a></p>
<p>Vozalis M G, Margaritis K G. Applying SVD on Generalized Item-based Filtering[J]. IJCSA, 2006, 3(3): 27-51.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-05-25&lt;/p&gt;
&lt;p&gt;本文以NMF和经典SVD为例，讲一讲矩阵分解在推荐系统中的应用。&lt;/p&gt;
&lt;h2 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h2&gt;&lt;table&gt;&lt;thead&gt;&lt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.letiantian.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>专题：浅入浅出Flask框架</title>
    <link href="http://www.letiantian.me/topic-learn-flask/"/>
    <id>http://www.letiantian.me/topic-learn-flask/</id>
    <published>2015-05-17T02:12:36.000Z</published>
    <updated>2015-05-17T02:30:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/content/images/2015/05/2015-05-17-flask-logo.jpg" alt=""></p>
<blockquote>
<p>Flask is a microframework for Python based on Werkzeug, Jinja 2 and good intentions. And before you ask: It’s BSD licensed!</p>
</blockquote>
<p><a href="http://flask.pocoo.org/" target="_blank" rel="external">Flask官方网址</a></p>
<p><a href="/2014-06-01-ubuntu-install-flask/">浅入浅出Flask框架：在ubuntu下安装Flask</a></p>
<p><a href="/2014-06-01-flask-hello-world/">浅入浅出Flask框架：从HelloWorld开始Flask</a></p>
<p><a href="/2014-06-23-flask-get-url-params/">浅入浅出Flask框架：获取URL参数</a></p>
<p><a href="/2014-06-24-flask-process-post-data/">浅入浅出Flask框架：处理客户端通过POST方法传送的数据</a></p>
<p><a href="/2014-06-28-flask-restful-url/">浅入浅出Flask框架：RESTful URL</a> </p>
<p><a href="/2014-06-28-flask-url-for/">浅入浅出Flask框架：url_for</a></p>
<p><a href="/2014-06-28-flask-redirect/">浅入浅出Flask框架：使用redirect</a></p>
<p><a href="/2014-06-28-flask-jinja2-template-engine/">浅入浅出Flask框架：使用Jinja2模板引擎</a>  </p>
<p><a href="/2014-06-28-flask-handle-errors/">浅入浅出Flask框架：自定义404等错误</a>  </p>
<p><a href="/2014-06-28-flask-session/">浅入浅出Flask框架：用户会话</a>  </p>
<p><a href="/2014-06-28-flask-cookie/">浅入浅出Flask框架：Cookie</a></p>
<p><a href="/2014-06-29-flask-flash/">浅入浅出Flask框架：flashing system</a></p>
<p><a href="/2014-06-30-flask-datum-collected/">Flask框架资料整理</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/content/images/2015/05/2015-05-17-flask-logo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Flask is a microframework for Python based on We
    
    </summary>
    
    
      <category term="专题" scheme="http://www.letiantian.me/tags/%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2015阿里移动推荐算法比赛第一赛季总结</title>
    <link href="http://www.letiantian.me/2015-05-17-alibaba-mobile-recommend-competition-summary/"/>
    <id>http://www.letiantian.me/2015-05-17-alibaba-mobile-recommend-competition-summary/</id>
    <published>2015-05-17T01:59:41.000Z</published>
    <updated>2015-05-26T01:19:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-05-17</p>
<p>第一赛季是在四月底结束，分数还凑合，过了9.00%。本文只是一篇总结性的文章。</p>
<p>发现的问题：<br>1、还是学的不怎么样<br>2、了解的不够深入，实战经验少<br>3、PRML和NG的视频都没看，不算好好学过机器学习<br>4、论文看得太少<br>5、没人指点<br>6、机器设备太差<br>7、比赛参加的有点晚，中间还出去溜达了几天<br>8、单人作战很酸爽～</p>
<h2 id="比赛题目"><a href="#比赛题目" class="headerlink" title="比赛题目"></a>比赛题目</h2><p>官方提供了两个文本文件，第一个是<code>tianchi_mobile_recommend_train_user.csv</code>：</p>
<pre><code class="text">user_id,item_id,behavior_type,user_geohash,item_category,time
99512554,37320317,3,94gn6nd,9232,2014-11-26 20
9909811,266982489,1,,3475,2014-12-02 23
......
</code></pre>
<p>每一行代表了用户<code>user_id</code>对属于分类<code>cat_id</code>的物品<code>item_id</code>在<code>time</code>这个时间于地点<code>user_geohash</code>发生了交互，交互类型是<code>behavior_type</code>。<code>behavior_type</code>包括浏览、收藏、加购物车、购买，对应取值分别是1、2、3、4。<code>tianchi_mobile_recommend_train_user.csv</code>中的数据约有1200万行。</p>
<p>一共有31天的交互数据，最后要预测地32天有哪些user会购买哪些item。 举办方对你提交的数据计算F1，并进行排名。</p>
<p>然而，还有一个商品子集的文件<code>tianchi_mobile_recommend_train_item.csv</code>：</p>
<pre><code>item_id,item_geohash,item_category
327414838,,11991
169831798,,7876
320523991,,3370
......
</code></pre><p>这个文件约有44万条数据，是<code>tianchi_mobile_recommend_train_user.csv</code>中出现的item的一个子集。官方的第32天的会发生购买的<code>user, item</code>中的item都是这个文件中的item，所以我们预测的<code>user, item</code>需要根据这个文件来过滤掉一些结果。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>这个预测，可以考虑预测<strong>发生过交互行为</strong>的<code>user, item</code>会不会在第32天购买，也可以预测<strong>没有发生过交互行为</strong>的<code>user, item</code>会不会在第32天购买。笔者这一次只考虑了<strong>发生过交互行为</strong>的<code>user, item</code>。我们要有一份自己的训练集和测试集来评估自己的模型（算法），当觉得自己的模型比较好了，就可以拿着模型去预测了。</p>
<h2 id="清洗数据"><a href="#清洗数据" class="headerlink" title="清洗数据"></a>清洗数据</h2><p>比如去除总的交互次数很低（低于2或者低于3或者…）的<code>user, item</code>，去除最后10天没有发生交互的<code>user, item</code>。还可以继续删除，比如双12的所有数据。不过删多了可不一定好。</p>
<h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><blockquote>
<p>一个简单算法在精心选择的特征上的效果比一个漂亮的算法在较差的特征上的效果还要好。</p>
</blockquote>
<p>如何构造特征很重要，特征构造得好，同一算法下准确率也可以提升很多。个人认为构造特征是这次比赛中最重要的任务。</p>
<p>以<a href="http://zh.wikipedia.org/wiki/%E5%AE%89%E5%BE%B7%E6%A3%AE%E9%B8%A2%E5%B0%BE%E8%8A%B1%E5%8D%89%E6%95%B0%E6%8D%AE%E9%9B%86" target="_blank" rel="external">Iris数据集</a>为例，其默认提供了4个特征：花萼和花瓣的长度和宽度。对此我们可以构造更多的特征，例如<code>花萼宽度/花萼长度</code>、<code>花萼宽度/花瓣长度</code>、<code>花萼宽度×花萼长度</code>等等，只要觉得合理，就可以构造。</p>
<p>另外，特征的优劣会影响到一些机器学习算法的效果，或者特征太多机器会跑不动。筛选特征可能会成为一个很重要的步骤。假设现在有100个有标号的样本，每个样本10个特征，可以通过下面几种方法：</p>
<p><strong>方法1：</strong> 拿出两个特征对应的两个100维的向量，使用pearson相关系数、归一化互信息量等方法计算两个特征的相关性，如果相关性很高，可以考虑删除其中一个特征。</p>
<p><strong>方法2：</strong> 利用决策树的内置的特征筛选方法筛选好的特征</p>
<p><strong>方法3：</strong>特征递归消除。可以参考<a href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html" target="_blank" rel="external">http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html</a>。</p>
<p>scikit-learn库提供了多个特征选择的方法，<a href="http://scikit-learn.org/stable/modules/feature_selection.html" target="_blank" rel="external">点这里</a>。 </p>
<p>也可以考虑降维。<a href="http://scikit-learn.org/stable/modules/decomposition.html" target="_blank" rel="external">点这里</a>。</p>
<p><strong>那么，一个<code>user, item</code>可以构造什么特征呢？</strong></p>
<p>以前30天的所有数据为例（第31天有没有购买当作target）： 最后一天user有没有购买item、最后的4天user有没有购买item、最后的4天user有没有点击item、最后的4天user对item的点击量、最后的4到8天user对item的点击量，最后的4天user的点击量，最后的4天item的的点击量，最后的4天item的的购买量除最后的4天item的的点击量……  <strong>去年比赛的PPT中都讲到了这些</strong>。 另外,geohash也可以拿来生成特征，例如判断用户的最新位置和item最近的位置有多近；<code>cat_id</code>也可以考虑一下。再开个脑洞，将<code>user, item</code>的构造的某些特征进行聚类，样本所属的簇、样本离某个簇心的距离等也可以当作该样本的新特征。</p>
<h2 id="训练集和测试集的构造"><a href="#训练集和测试集的构造" class="headerlink" title="训练集和测试集的构造"></a>训练集和测试集的构造</h2><p>基于上面的内容，现在可以构造训练集和测试集了。</p>
<ul>
<li>新数据集1： 将1-27天的数据拿出来做特征，第28天作为target。 -&gt; 用于训练  </li>
<li>新数据集2： 将2-28天的数据拿出来做特征，第29天作为target。 -&gt; 用于训练  </li>
<li>新数据集3： 将3-29天的数据拿出来做特征，第30天作为target。 -&gt; 用于训练</li>
<li>新数据集4： 将4-30天的数据拿出来做特征，第31天作为target。 -&gt; 用于测试</li>
<li>新数据集5： 将5-31天的数据拿出来做特征。 -&gt; 用于最终的预测。</li>
</ul>
<p><strong>正负样本比例问题：</strong> 对于上面生成的一个数据集，正例（target是购买）的数量只是几千，而负例上百万。只能说太不平衡了，不适合做训练集。可以这样做：将多个数据集的正例放在一起以增加正例数量；对负例进行随机采样。可以考虑生成多个训练集来观察模型的稳定性。</p>
<p><strong>如何评估模型：</strong> 用<code>新数据集4</code>做测试，其实只需要把<code>新数据集4</code>其中的正例拿出来，计算F1即可。如果这个F1做的比较好了，可以认为提交结果的F1也会很好。</p>
<h2 id="分类还是回归？"><a href="#分类还是回归？" class="headerlink" title="分类还是回归？"></a>分类还是回归？</h2><p>很明显，这是一个二分类问题。不过如果只看做二分类，会出一些问题。举办方那边有约500条数据（从第32天的实际购买<code>user, item</code>抽取出来的）来计算参赛者提交数据的F1，如果你只预测了100个<code>user, item</code> 或者预测了2000条<code>user, item</code>，这些数据并不适合提交上去，提交的比较好的数据量是400~1200之间。</p>
<p>利用回归来解决是个不错的思路。基于回归的预测结果可以简单看成user会购买item的概率，概率越高，购买的可能性越大。通过设置一个<code>阈值</code>就可以得到任意数量的提交结果了。</p>
<h2 id="机器学习库、机器学习方法"><a href="#机器学习库、机器学习方法" class="headerlink" title="机器学习库、机器学习方法"></a>机器学习库、机器学习方法</h2><p>网上能找到很多机器学习库，例如scikit-learn、Spark MLlib、Apache Mahout、R等。</p>
<p>上两个网址：<br><a href="http://www.infoq.com/cn/news/2014/12/11-machine-learning-project" target="_blank" rel="external">InfoQ：机器学习的11个开源项目</a><br><a href="http://www.zhihu.com/question/20472776" target="_blank" rel="external">知乎：请问学习机器学习有哪些好工具推荐呢？</a>  </p>
<p>scikit-learn支持很多机器学习方法，列举一二：</p>
<p><a href="http://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html" target="_blank" rel="external">Logistic Regression</a>：分类器，<code>predict_proba()</code>函数可以当作回归来使用。</p>
<p><a href="http://scikit-learn.org/stable/modules/tree.html#classification" target="_blank" rel="external">决策树 - 分类</a> </p>
<p><a href="http://scikit-learn.org/stable/modules/tree.html#regression" target="_blank" rel="external">决策树 - 回归</a>  </p>
<p><a href="http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html" target="_blank" rel="external">随机森林 - 分类</a>  </p>
<p><a href="http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html" target="_blank" rel="external">随机森林 - 回归</a>  </p>
<p><a href="http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html" target="_blank" rel="external">GBDT - 分类</a></p>
<p><a href="http://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingRegressor.html" target="_blank" rel="external">GBDT - 回归</a>  </p>
<p>Spark 的机器学习库<a href="http://spark.apache.org/mllib/" target="_blank" rel="external">MLlib</a>提供的方法也不少，可以进入<a href="http://spark.apache.org/docs/latest/mllib-guide.html" target="_blank" rel="external">Machine Learning Library (MLlib) Guide</a>了解一下。</p>
<p>只用1个算法去预测的队伍应该挺多，也可以考虑多个经典机器学习算法融合到一起（<a href="http://en.wikipedia.org/wiki/Ensemble_learning" target="_blank" rel="external">Ensemble learning</a>）。</p>
<p><strong>参数调优</strong><br>每个模型都有很多参数，参数的选择也会影响到最后的效果。思路：</p>
<p>1、手动调参数；<br>2、枚举一些参数值，一个个测试；<br>3、遗传算法、粒子群算法等。  </p>
<p><strong>方差和偏差问题</strong></p>
<p>训练后的模型测试的效果很差，叫做高偏差，这往往意味着模型太简单。解决方法是：增加更多特征、使用别的模型、使用更复杂的模型等。</p>
<p>同一模型，用随机采样的多个数据集训练并测试的多个结果相差很大，叫做高方差，这往往意味着模型太复杂，导致了过拟合。解决方法是：使用更多数据、降低模型复杂度等。</p>
<h2 id="单机还是集群？"><a href="#单机还是集群？" class="headerlink" title="单机还是集群？"></a>单机还是集群？</h2><p>这次比赛数据量偏大，要不加内存，要不用集群。</p>
<h2 id="提交多少数据？"><a href="#提交多少数据？" class="headerlink" title="提交多少数据？"></a>提交多少数据？</h2><p>同一模型、同一训练集得到的预测结果，通过<code>阈值</code>可以得到不同数量的结果，提交1000条结果和提交600条结果的F1分数可能差距很大，提交600条结果和提交560条结果的F1分数也可能差距很大。如果模型做得足够好的话，提交400～1000条数据都能得到很好的F1分数；如果模型方面到瓶颈了，就需要好好考虑提交多少条数据比较好了。</p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p>使用MapReduce对数据做预处理。<br>存储基本特征、中间结果等考虑使用数据库（MySQL或者MongoDB）。</p>
<h2 id="如何查找作弊现象"><a href="#如何查找作弊现象" class="headerlink" title="如何查找作弊现象"></a>如何查找作弊现象</h2><p>想了想，可以是下面的一些方法：<br>1、两个队伍提交的数据完全相同（先排序，再求编辑距离）<br>2、两个队伍提交时使用的IP相同，但是不同的队伍可能用同一个代理<br>3、一个浏览器提交了多个队伍的数据（在浏览器中加入cookie）<br>4、实名认证<br>5、提交代码，代码查重  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>收获很多，自己在机器学习这方面还有很大进步空间。</p>
<p>学习并使用了Spark的MLlib。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-05-17&lt;/p&gt;
&lt;p&gt;第一赛季是在四月底结束，分数还凑合，过了9.00%。本文只是一篇总结性的文章。&lt;/p&gt;
&lt;p&gt;发现的问题：&lt;br&gt;1、还是学的不怎么样&lt;br&gt;2、了解的不够深入，实战经验少&lt;br&gt;3、PRML和NG的视频都没看，不算好好学过机器学习&lt;br
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.letiantian.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>专题：浅入浅出MyBatis</title>
    <link href="http://www.letiantian.me/topic-learn-mybatis-from-scratch/"/>
    <id>http://www.letiantian.me/topic-learn-mybatis-from-scratch/</id>
    <published>2015-05-17T01:16:59.000Z</published>
    <updated>2015-05-17T01:26:50.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集。MyBatis 使用简单的 XML 或注解来配置和映射基本体，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
</blockquote>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-01">浅入浅出MyBatis(01)：查询id为1的用户的信息</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-02">浅入浅出MyBatis(02)：查询密码为123的所有用户</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-03">浅入浅出MyBatis(03)：如果Bean中成员变量和表中字段命名不一致</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-04">浅入浅出MyBatis(04)：只获取表中的部分字段</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-05">浅入浅出MyBatis(05)：插入数据</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-06">浅入浅出MyBatis(06)：更新数据</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-07">浅入浅出MyBatis(07)：删除数据</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-08">浅入浅出MyBatis(08)：获取一个用户的所有blog</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-09">浅入浅出MyBatis(09)：获取一篇文章及其作者的信息</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-10">浅入浅出MyBatis(10)：分页查询</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-11">浅入浅出MyBatis(11)：动态SQL</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-12">浅入浅出MyBatis(12)：使用事务</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-13">浅入浅出MyBatis(13)：关于连接池</a></p>
<p><a href="/2015-01-14-learn-mybatis-from-scratch-14">浅入浅出MyBatis(14)：使用注解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis 避免了几乎所有的 JDBC 代码和手工设置参数以及抽取结果集。MyBatis 使用简单的 XML 或注解来配置和映射基本体，将接口和 Java 的 POJ
    
    </summary>
    
    
      <category term="专题" scheme="http://www.letiantian.me/tags/%E4%B8%93%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>在Iris数据集上对比PCA、LDA、NMF</title>
    <link href="http://www.letiantian.me/2015-04-03-pca-lda-nmf-iris/"/>
    <id>http://www.letiantian.me/2015-04-03-pca-lda-nmf-iris/</id>
    <published>2015-04-03T13:49:13.000Z</published>
    <updated>2015-04-03T13:56:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-04-03</p>
<p>PCA、LDA、NMF都可以用来降维。</p>
<p>之前在<a href="/2014-12-23-pca-mnist/">使用PCA处理MNIST数据集</a>介绍过PCA，在<a href="/2014-12-22-latent-factor-model-and-nmf/">隐语义模型和NMF（非负矩阵分解）</a>介绍过NMF。</p>
<p>这里的LDA，是指线性判别分析（Linear Discriminant Analysis），是一种有监督的学习方法。这方面的资料可以参考：  </p>
<blockquote>
<p>PRML（Pattern Recognition and Machine Learning）第四章 </p>
<p><a href="http://www.cnblogs.com/LeftNotEasy/archive/2011/01/08/lda-and-pca-machine-learning.html" target="_blank" rel="external">机器学习中的数学(4)-线性判别分析（LDA）, 主成分分析(PCA)</a>  </p>
<p><a href="http://www.cnblogs.com/jerrylead/archive/2011/04/21/2024384.html" target="_blank" rel="external">线性判别分析（Linear Discriminant Analysis）（一）</a>  </p>
</blockquote>
<p>本文内容是如何使用scikit-learn中的这3个降维工具处理Iris数据集，并用图的形式比较了降维效果。</p>
<h2 id="导入数据集"><a href="#导入数据集" class="headerlink" title="导入数据集"></a>导入数据集</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.datasets import load_iris
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; iris = load_iris()
&gt;&gt;&gt; iris.data
array([[ 5.1,  3.5,  1.4,  0.2],  
       [ 4.9,  3. ,  1.4,  0.2],
       ....
       [ 5.9,  3. ,  5.1,  1.8]])
&gt;&gt;&gt; iris.target
array([0, 0, 0, 0, 0, 0, ... , 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  
       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])
&gt;&gt;&gt; iris.data.shape  
(150, 4)                   # 150个样本，每个样本4个特征
&gt;&gt;&gt; iris.target.shape      # 每个样本的类别
(150,)
</code></pre><h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.decomposition import PCA
&gt;&gt;&gt; pca = PCA(n_components=2)
&gt;&gt;&gt; pca_result = pca.fit_transform(iris.data)
</code></pre><h2 id="LDA"><a href="#LDA" class="headerlink" title="LDA"></a>LDA</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.lda import LDA
&gt;&gt;&gt; lda = LDA()
&gt;&gt;&gt; lda = LDA(n_components=2)
&gt;&gt;&gt; lda_result = lda.fit_transform(iris.data, iris.target)
</code></pre><h2 id="NMF"><a href="#NMF" class="headerlink" title="NMF"></a>NMF</h2><hr>
<pre><code>&gt;&gt;&gt; from sklearn.decomposition import NMF
&gt;&gt;&gt; nmf = NMF(n_components=2)
&gt;&gt;&gt; nmf_result = nmf.fit_transform(iris.data)
</code></pre><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><hr>
<pre><code>&gt;&gt;&gt; import matplotlib.pyplot as plt
# for PCA
&gt;&gt;&gt; plt.subplot(1,3,1)
&gt;&gt;&gt; plt.scatter(pca_result[iris.target==0, 0], pca_result[iris.target==0, 1], color=&#39;r&#39;)
&gt;&gt;&gt; plt.scatter(pca_result[iris.target==1, 0], pca_result[iris.target==1, 1], color=&#39;g&#39;) 
&gt;&gt;&gt; plt.scatter(pca_result[iris.target==2, 0], pca_result[iris.target==2, 1], color=&#39;b&#39;) 
&gt;&gt;&gt; plt.title(&#39;PCA on iris&#39;)

# for LDA
&gt;&gt;&gt; plt.subplot(1,3,2)
&gt;&gt;&gt; plt.scatter(lda_result[iris.target==0, 0], lda_result[iris.target==0, 1], color=&#39;r&#39;)
&gt;&gt;&gt; plt.scatter(lda_result[iris.target==1, 0], lda_result[iris.target==1, 1], color=&#39;g&#39;) 
&gt;&gt;&gt; plt.scatter(lda_result[iris.target==2, 0], lda_result[iris.target==2, 1], color=&#39;b&#39;) 
&gt;&gt;&gt; plt.title(&#39;LDA on iris&#39;)

# for NMF
&gt;&gt;&gt; plt.subplot(1,3,3)
&gt;&gt;&gt; plt.scatter(nmf_result[iris.target==0, 0], nmf_result[iris.target==0, 1], color=&#39;r&#39;)
&gt;&gt;&gt; plt.scatter(nmf_result[iris.target==1, 0], nmf_result[iris.target==1, 1], color=&#39;g&#39;) 
&gt;&gt;&gt; plt.scatter(nmf_result[iris.target==2, 0], nmf_result[iris.target==2, 1], color=&#39;b&#39;) 
&gt;&gt;&gt; plt.title(&#39;NMF on iris&#39;)

&gt;&gt;&gt; plt.show()
</code></pre><h2 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h2><hr>
<p><img src="/content/images/2015/04/2015-04-03-pca-lda-nmf.png" alt=""></p>
<p>每副图中的灰色直线是我添加上去的，这些直线可以看出新数据的不同特点。</p>
<p>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-04-03&lt;/p&gt;
&lt;p&gt;PCA、LDA、NMF都可以用来降维。&lt;/p&gt;
&lt;p&gt;之前在&lt;a href=&quot;/2014-12-23-pca-mnist/&quot;&gt;使用PCA处理MNIST数据集&lt;/a&gt;介绍过PCA，在&lt;a href=&quot;/2014-12-22-latent-f
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.letiantian.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>基于KNN的文本分类实战</title>
    <link href="http://www.letiantian.me/2015-04-03-knn-text-classification/"/>
    <id>http://www.letiantian.me/2015-04-03-knn-text-classification/</id>
    <published>2015-04-03T02:39:53.000Z</published>
    <updated>2015-04-03T05:21:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-04-03</p>
<p>本文讲述如何使用scikit-learn的KNN工具对文本进行分类。</p>
<h2 id="关于KNN"><a href="#关于KNN" class="headerlink" title="关于KNN"></a>关于KNN</h2><hr>
<p>K-近邻算法，简称KNN（k-Nearest Neighbor），是一个相当简单的分类/预测算法。其主要思想就是，选取与待分类/预测数据的最相似的K个训练数据，通过对这K个数据的结果或者分类标号取平均、取众数等方法得到待分类/预测数据的结果或者分类标号。</p>
<p>关于KNN，笔者在<a href="/2014-06-10-knn/">浅入浅出：K近邻算法</a>有较为详细的介绍。</p>
<h2 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h2><hr>
<p>数据集是有8个分类的文本数据集，使用了结巴分词对每个文本分词，每个单词当作特征，再利用二元词串构造更多特征，然后去掉停用词，去掉出现次数太多和太少的特征，得到了19630个特征。取1998个样本用于训练，509个用于测试。基于词袋模型的思路将每个文本转换为向量，训练集和测试集分别转换为矩阵，并用python numpy模块将其保存为npy格式。</p>
<p>在 <a href="https://github.com/letiantian/dataset" target="_blank" rel="external">https://github.com/letiantian/dataset</a> 下载text-classification.7z，解压后导入数据：</p>
<pre><code>$ ls
test_data.npy  test_labels.npy  training_data.npy  training_labels.npy  
$ ipython
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; training_data = np.load(&quot;training_data.npy&quot;)
&gt;&gt;&gt; training_data.shape
(1998, 19630)
&gt;&gt;&gt; training_labels = np.load(&quot;training_labels.npy&quot;)
&gt;&gt;&gt; training_labels
array([6, 6, 6, ..., 2, 2, 2])  
&gt;&gt;&gt; training_labels.shape
(1998,)
&gt;&gt;&gt; test_data = np.load(&quot;test_data.npy&quot;)
&gt;&gt;&gt; test_data.shape
(509, 19630)
&gt;&gt;&gt; test_labels = np.load(&quot;test_labels.npy&quot;)
&gt;&gt;&gt; test_labels.shape
(509,)
</code></pre><h2 id="如何找一样本的最近k个邻居"><a href="#如何找一样本的最近k个邻居" class="headerlink" title="如何找一样本的最近k个邻居"></a>如何找一样本的最近k个邻居</h2><hr>
<p><strong>方法1：</strong></p>
<pre><code>&gt;&gt;&gt; from sklearn.neighbors import NearestNeighbors
&gt;&gt;&gt; nbrs = NearestNeighbors(n_neighbors=6, algorithm=&#39;ball_tree&#39;)
&gt;&gt;&gt; nbrs.fit(training_data)  # 构造BallTree，可以快速找出6个最近邻居，原理待学习
NearestNeighbors(algorithm=&#39;ball_tree&#39;, leaf_size=30, metric=&#39;minkowski&#39;,
         metric_params=None, n_neighbors=6, p=2, radius=1.0)
&gt;&gt;&gt; distances, indices = nbrs.kneighbors(test_data[0])  # 找training_data中离样本test_data[0]的最近的6个样本
&gt;&gt;&gt; indices  # 6个最近样本，每个值是指在training_data中的第几个样本
array([[500, 294,  62, 802, 732, 703]])
&gt;&gt;&gt; distances  # 对应的距离
array([[ 13.37908816,  13.60147051,  13.60147051,  13.60147051,
         13.60147051,  13.6381817 ]])
</code></pre><p>也可以依次找出多个测试样本的最近的6个训练样本：</p>
<pre><code>&gt;&gt;&gt; distances, indices = nbrs.kneighbors(test_data[0:2])
&gt;&gt;&gt; indices
array([[ 500,  294,   62,  802,  732,  703],
       [  62,  294,  636, 1945,  802, 1091]])
&gt;&gt;&gt; distances
array([[ 13.37908816,  13.60147051,  13.60147051,  13.60147051,
         13.60147051,  13.6381817 ],
       [  7.93725393,   7.93725393,   8.1240384 ,   8.36660027,
          8.54400375,   8.54400375]])
</code></pre><p><strong>方法2：</strong></p>
<pre><code>&gt;&gt;&gt; from sklearn.neighbors import BallTree
&gt;&gt;&gt; bt = BallTree(training_data, metric=&#39;euclidean&#39;)
&gt;&gt;&gt; distances, indices = bt.query(test_data[0], k=6)                  
&gt;&gt;&gt; indices
array([[500,  62, 802, 294, 732, 703]])
&gt;&gt;&gt; distances
array([[ 13.37908816,  13.60147051,  13.60147051,  13.60147051,
         13.60147051,  13.6381817 ]])
</code></pre><h2 id="基于KNN的文本分类"><a href="#基于KNN的文本分类" class="headerlink" title="基于KNN的文本分类"></a>基于KNN的文本分类</h2><hr>
<p>令k=6：</p>
<pre><code>&gt;&gt;&gt; from sklearn.neighbors import KNeighborsClassifier
&gt;&gt;&gt; knn = KNeighborsClassifier(n_neighbors=6, metric=&#39;euclidean&#39;)
&gt;&gt;&gt; knn.fit(training_data, training_labels) # 训练
KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;euclidean&#39;,
           metric_params=None, n_neighbors=6, p=2, weights=&#39;uniform&#39;)
&gt;&gt;&gt; predict_labels = knn.predict(test_data) # 预测
&gt;&gt;&gt; sum(predict_labels == test_labels)
230
&gt;&gt;&gt; 230./509  # 正确率
0.4518664047151277
</code></pre><p>令k=20：</p>
<pre><code>&gt;&gt;&gt; from sklearn.neighbors import KNeighborsClassifier
&gt;&gt;&gt; knn = KNeighborsClassifier(n_neighbors=20, metric=&#39;euclidean&#39;)
&gt;&gt;&gt; knn.fit(training_data, training_labels) # 训练
KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;euclidean&#39;,
           metric_params=None, n_neighbors=20, p=2, weights=&#39;uniform&#39;)
&gt;&gt;&gt; predict_labels = knn.predict(test_data) # 预测
&gt;&gt;&gt; sum(predict_labels == test_labels)
276  # 效果比k=6时提升了一些
&gt;&gt;&gt; 276./509   # 正确率
0.5422396856581533
</code></pre><p>这个正确率并不高。在<a href="/2015-03-31-bayes-classifier-for-text/">基于贝叶斯的文本分类实战</a>中笔者使用了多项式贝叶斯对同样的数据集进行分类，正确率达到近90%。</p>
<h2 id="做个优化"><a href="#做个优化" class="headerlink" title="做个优化"></a>做个优化</h2><hr>
<p>我们将每个样本归一化，看看效果。</p>
<p>先写一个归一化工具（mytools.py）：</p>
<pre><code># !/usr/bin/env python
# -*- encoding:utf-8 -*-

import numpy as np

def uniformization(X):
    if X.ndim != 2:
        return None
    X2 = X.copy()
    X2 = X2.astype(float)
    rows = X2.shape[0]
    for i in xrange(0, rows):
        sum_of_squares = sum(X2[i, :]**2)
        if sum_of_squares == 0: continue
        sqrt_sum_of_squares = sum_of_squares**0.5
        X2[i, :] = X2[i, :] / sqrt_sum_of_squares
    return X2 

if __name__ == &#39;__main__&#39;:
    arr = np.array([[1,2,3],[4,5,6],[0,0,0]])
    print uniformization(arr)
</code></pre><p>运行结果如下：</p>
<pre><code>[[ 0.26726124  0.53452248  0.80178373]
 [ 0.45584231  0.56980288  0.68376346]
 [ 0.          0.          0.
</code></pre><p>处理原始数据集，生成新的数据：</p>
<pre><code>&gt;&gt;&gt; from mytools import uniformization
&gt;&gt;&gt; new_training_data = uniformization(training_data)
&gt;&gt;&gt; new_test_data = uniformization(test_data)
</code></pre><p>令k=6：</p>
<pre><code>&gt;&gt;&gt; knn = KNeighborsClassifier(n_neighbors=6, metric=&#39;euclidean&#39;)
&gt;&gt;&gt; knn.fit(new_training_data, training_labels) # 使用新数据训练
KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;euclidean&#39;,
           metric_params=None, n_neighbors=6, p=2, weights=&#39;uniform&#39;)
&gt;&gt;&gt; predict_labels = knn.predict(new_test_data) # 预测
&gt;&gt;&gt; sum(predict_labels == test_labels)
294  # 由230提升到294
&gt;&gt;&gt; 294./509  # 正确率有提升
0.5776031434184676
</code></pre><p>令k=20：</p>
<pre><code>&gt;&gt;&gt; from sklearn.neighbors import KNeighborsClassifier
&gt;&gt;&gt; knn = KNeighborsClassifier(n_neighbors=20, metric=&#39;euclidean&#39;)
&gt;&gt;&gt; knn.fit(new_training_data, training_labels)  # 使用新数据训练
KNeighborsClassifier(algorithm=&#39;auto&#39;, leaf_size=30, metric=&#39;euclidean&#39;,
           metric_params=None, n_neighbors=20, p=2, weights=&#39;uniform&#39;)
&gt;&gt;&gt; predict_labels = knn.predict(new_test_data)  # 预测
&gt;&gt;&gt; sum(predict_labels == test_labels)
314  # 由276提升到314
&gt;&gt;&gt; 314./509  # 正确率有提升
0.6168958742632613
</code></pre><p>可以看到，归一化后，预测分类的正确率提升很多。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="http://scikit-learn.org/stable/modules/neighbors.html" target="_blank" rel="external">1.6. Nearest Neighbors</a><br><a href="http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html#sklearn.neighbors.KNeighborsClassifier" target="_blank" rel="external">sklearn.neighbors.KNeighborsClassifier</a></p>
<p>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-04-03&lt;/p&gt;
&lt;p&gt;本文讲述如何使用scikit-learn的KNN工具对文本进行分类。&lt;/p&gt;
&lt;h2 id=&quot;关于KNN&quot;&gt;&lt;a href=&quot;#关于KNN&quot; class=&quot;headerlink&quot; title=&quot;关于KNN&quot;&gt;&lt;/a&gt;关于KNN&lt;/h2&gt;&lt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.letiantian.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>使用特征递归消除筛选特征</title>
    <link href="http://www.letiantian.me/2015-04-01-recursive-feature-elimination/"/>
    <id>http://www.letiantian.me/2015-04-01-recursive-feature-elimination/</id>
    <published>2015-04-01T02:52:52.000Z</published>
    <updated>2015-04-03T07:03:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>2015-04-01</p>
<p>特征递归消除（recursive feature elimination，RFE）是特征选择的一种方法。</p>
<p><a href="http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html" target="_blank" rel="external">http://scikit-learn.org/stable/modules/generated/sklearn.feature_selection.RFE.html</a>给出了RFE的基本思想：</p>
<blockquote>
<p> the goal of recursive feature elimination (RFE) is to select features by recursively considering smaller and smaller sets of features. First, the estimator is trained on the initial set of features and weights are assigned to each one of them. Then, features whose absolute weights are the smallest are pruned from the current set features. That procedure is recursively repeated on the pruned set until the desired number of features to select is eventually reached.</p>
</blockquote>
<p>而在<a href="http://book.douban.com/subject/25899625/" target="_blank" rel="external">《机器学习系统设计》</a>的第11章也提到了RFE，并给了一个流程图：</p>
<p><img src="/content/images/2015/04/2015-04-01-rfe.jpg" alt=""></p>
<p>可以看出RFE是一个迭代的过程（不是递归）。</p>
<p>下面讲一下如何使用scikit-learn中的RFE工具，本文最后部分介绍RFE的实现。</p>
<h2 id="导入数据集"><a href="#导入数据集" class="headerlink" title="导入数据集"></a>导入数据集</h2><hr>
<p>数据集是有8个分类的文本数据集，使用了结巴分词对每个文本分词，每个单词当作特征，再利用二元词串构造更多特征，然后去掉停用词，去掉出现次数太多和太少的特征，得到了19630个特征。取1998个样本用于训练，509个用于测试。基于词袋模型的思路将每个文本转换为向量，训练集和测试集分别转换为矩阵，并用python numpy模块将其保存为npy格式。</p>
<p>在<a href="https://github.com/letiantian/dataset-for-classifying" target="_blank" rel="external">https://github.com/letiantian/dataset-for-classifying</a>下载documents.7z，解压后导入数据：</p>
<pre><code>$ ls
test_data.npy  test_labels.npy  training_data.npy  training_labels.npy  
$ ipython
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; training_data = np.load(&quot;training_data.npy&quot;)
&gt;&gt;&gt; training_data.shape
(1998, 19630)
&gt;&gt;&gt; training_labels = np.load(&quot;training_labels.npy&quot;)
&gt;&gt;&gt; training_labels
array([6, 6, 6, ..., 2, 2, 2])  
&gt;&gt;&gt; training_labels.shape
(1998,)
&gt;&gt;&gt; test_data = np.load(&quot;test_data.npy&quot;)
&gt;&gt;&gt; test_data.shape
(509, 19630)
&gt;&gt;&gt; test_labels = np.load(&quot;test_labels.npy&quot;)
&gt;&gt;&gt; test_labels.shape
(509,)
</code></pre><h2 id="使用RFE"><a href="#使用RFE" class="headerlink" title="使用RFE"></a>使用RFE</h2><hr>
<p>RFE是一个框架，我们需要使用能得到特征重要性的方法嵌入其中。本文使用逻辑斯谛回归（在李航的《统计学习方法》中有介绍）。</p>
<pre><code>&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression
&gt;&gt;&gt; from sklearn.feature_selection import RFE
&gt;&gt;&gt; estimator = LogisticRegression()  # 逻辑斯谛回归
&gt;&gt;&gt; selector = RFE(estimator, 3000, step=200)
&gt;&gt;&gt; selector = selector.fit(training_data, training_labels)
&gt;&gt;&gt; selector.support_   # True的特征就是最终得到的特征
array([False, False,  True, ..., False, False, False], dtype=bool)
&gt;&gt;&gt; selector.ranking_  # 值越小，越重要
array([26, 64,  1, ..., 26, 56, 26])
&gt;&gt;&gt; new_train_data = training_data[:, selector.support_]
&gt;&gt;&gt; new_test_data = test_data[:, selector.support_]
&gt;&gt;&gt; new_train_data.shape
(1998, 3000)
&gt;&gt;&gt; new_test_data.shape
(509, 3000)
</code></pre><p>其中，<code>selector = RFE(estimator, 3000, step=200)</code>意思是每次迭代删除200个特征，最终保留3000个特征。</p>
<p><code>selector</code>也可以使用内部训练好的逻辑斯谛回归模型预测样本类别：</p>
<pre><code>&gt;&gt;&gt; lr_predict_labels = selector.predict(test_data)
&gt;&gt;&gt; sum(lr_predict_labels == test_labels)   # 预测对了448个样本
448
</code></pre><p>而对原始特征集合使用逻辑斯谛回归：</p>
<pre><code>&gt;&gt;&gt; lr = LogisticRegression()
&gt;&gt;&gt; lr.fit(training_data, training_labels)
LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,  
          intercept_scaling=1, max_iter=100, multi_class=&#39;ovr&#39;,
          penalty=&#39;l2&#39;, random_state=None, solver=&#39;liblinear&#39;, tol=0.0001,
          verbose=0)
&gt;&gt;&gt; lr_predict_labels = lr.predict(test_data)
&gt;&gt;&gt; sum(lr_predict_labels == test_labels)   # 预测对了446个样本
446
</code></pre><h2 id="使用多项式贝叶斯处理新数据"><a href="#使用多项式贝叶斯处理新数据" class="headerlink" title="使用多项式贝叶斯处理新数据"></a>使用多项式贝叶斯处理新数据</h2><hr>
<p>对原始特征集合：</p>
<pre><code>&gt;&gt;&gt; from sklearn.naive_bayes import MultinomialNB
&gt;&gt;&gt; bayes = MultinomialNB() 
&gt;&gt;&gt; bayes.fit(training_data, training_labels)
MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes.predict(test_data)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels)  # 预测对了454个样本
454
</code></pre><p>对新的特征集合：</p>
<pre><code>&gt;&gt;&gt; bayes = MultinomialNB() 
&gt;&gt;&gt; bayes.fit(new_train_data, training_labels)
MultinomialNB(alpha=1.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes.predict(new_test_data)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels)   # 预测对了456个样本
456
</code></pre><h2 id="使用伯努利贝叶斯处理新数据"><a href="#使用伯努利贝叶斯处理新数据" class="headerlink" title="使用伯努利贝叶斯处理新数据"></a>使用伯努利贝叶斯处理新数据</h2><hr>
<p>对原始特征集合：</p>
<pre><code>&gt;&gt;&gt; from sklearn.naive_bayes import BernoulliNB
&gt;&gt;&gt; bayes = BernoulliNB() 
&gt;&gt;&gt; bayes.fit(training_data, training_labels)
BernoulliNB(alpha=1.0, binarize=0.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes.predict(test_data)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels) 
387
</code></pre><p>对新的特征集合：</p>
<pre><code>&gt;&gt;&gt; bayes = BernoulliNB()
&gt;&gt;&gt; bayes.fit(new_train_data, training_labels)
BernoulliNB(alpha=1.0, binarize=0.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes.predict(new_test_data)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels)  # 效果提升了很多
433
</code></pre><h2 id="使用随机森林处理新数据"><a href="#使用随机森林处理新数据" class="headerlink" title="使用随机森林处理新数据"></a>使用随机森林处理新数据</h2><hr>
<p>对原始特征集合：</p>
<pre><code>&gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier
&gt;&gt;&gt; rf = RandomForestClassifier(n_estimators=100)
&gt;&gt;&gt; rf.fit(training_data, training_labels)
RandomForestClassifier(bootstrap=True, criterion=&#39;gini&#39;, max_depth=None,
            max_features=&#39;auto&#39;, max_leaf_nodes=None, min_samples_leaf=1,
            min_samples_split=2, min_weight_fraction_leaf=0.0,
            n_estimators=100, n_jobs=1, oob_score=False, random_state=None,
            verbose=0, warm_start=False)
&gt;&gt;&gt; rf_predict_labels = rf.predict(test_data)
&gt;&gt;&gt; sum(rf_predict_labels == test_labels)
422
</code></pre><p>对新的特征集合：</p>
<pre><code>&gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier
&gt;&gt;&gt; rf = RandomForestClassifier(n_estimators=100)
&gt;&gt;&gt; rf.fit(new_train_data, training_labels)
RandomForestClassifier(bootstrap=True, criterion=&#39;gini&#39;, max_depth=None,
            max_features=&#39;auto&#39;, max_leaf_nodes=None, min_samples_leaf=1,
            min_samples_split=2, min_weight_fraction_leaf=0.0,
            n_estimators=100, n_jobs=1, oob_score=False, random_state=None,
            verbose=0, warm_start=False)
&gt;&gt;&gt; rf_predict_labels = rf.predict(new_test_data)
&gt;&gt;&gt; sum(rf_predict_labels == test_labels)   # 变化不大
421
</code></pre><h2 id="如何实现RFE"><a href="#如何实现RFE" class="headerlink" title="如何实现RFE"></a>如何实现RFE</h2><hr>
<p>从上面可以看到，RFE消除特征后，很多分类器的效果并没有下降，甚至有所提升。那么RFE是如何实现的？</p>
<p>在scikit-learn源码中，打开文件sklearn/feature_selection/rfe.py，可以看到RFE的实现，下面摘取部分并给出注释：</p>
<pre><code>class RFE(BaseEstimator, MetaEstimatorMixin, SelectorMixin):

    def __init__(self, estimator, n_features_to_select=None, step=1,
                 estimator_params={}, verbose=0):
        self.estimator = estimator
        self.n_features_to_select = n_features_to_select
        self.step = step
        self.estimator_params = estimator_params
        self.verbose = verbose

    def fit(self, X, y):
        &quot;&quot;&quot;Fit the RFE model and then the underlying estimator on the selected
           features.

        Parameters
        ----------
        X : {array-like, sparse matrix}, shape = [n_samples, n_features]
            The training input samples.

        y : array-like, shape = [n_samples]
            The target values.
        &quot;&quot;&quot;
        X, y = check_X_y(X, y, &quot;csc&quot;)
        # Initialization
        n_features = X.shape[1]
        if self.n_features_to_select is None:
            n_features_to_select = n_features / 2
        else:
            n_features_to_select = self.n_features_to_select

        if 0.0 &lt; self.step &lt; 1.0:
            step = int(self.step * n_features)
        else:
            step = int(self.step)
        if step &lt;= 0:
            raise ValueError(&quot;Step must be &gt;0&quot;)

        support_ = np.ones(n_features, dtype=np.bool)   # true代表就用这个特征吧
        ranking_ = np.ones(n_features, dtype=np.int)    # 值越小越好
        # Elimination
        while np.sum(support_) &gt; n_features_to_select:
            # Remaining features
            &#39;&#39;&#39; the function of np.arange
            np.arange(3) -&gt; array([0, 1, 2]), 
            np.arange(3)[np.array([True,False,True])]-&gt; array([0, 2])
            &#39;&#39;&#39;
            features = np.arange(n_features)[support_]  # 每个值代表是第几个特征；若features中第3个值为9,代表新的第3个特征是原始的第9个特征

            # Rank the remaining features
            estimator = clone(self.estimator)
            estimator.set_params(**self.estimator_params)
            if self.verbose &gt; 0:
                print(&quot;Fitting estimator with %d features.&quot; % np.sum(support_))

            estimator.fit(X[:, features], y)  # 使用现在的特征集合来训练

            &#39;&#39;&#39; the function of np.argsort
            &gt;&gt;&gt; x = np.array([3, 1, 2])
            &gt;&gt;&gt; np.argsort(x)
            array([1, 2, 0])
            &#39;&#39;&#39;
            if estimator.coef_.ndim &gt; 1:
                ranks = np.argsort(safe_sqr(estimator.coef_).sum(axis=0))  # 将特征按找重要性从小到大来排序
            else:
                ranks = np.argsort(safe_sqr(estimator.coef_))

            # for sparse case ranks is matrix
            &#39;&#39;&#39;the function of np.ravel
            &gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])
            &gt;&gt;&gt; print np.ravel(x)
            [1 2 3 4 5 6]

            &#39;&#39;&#39;
            ranks = np.ravel(ranks)

            # Eliminate the worse features
            &#39;&#39;&#39;
            &gt;&gt;&gt; np.array([89,20,100])[np.array([2,0,1])]
            &gt;&gt;&gt; array([100,  89,  20])
            &gt;&gt;&gt; np.logical_not(3)
            False
            &gt;&gt;&gt; np.logical_not([True, False, 0, 1])
            array([False,  True,  True, False], dtype=bool)
            &#39;&#39;&#39;
            threshold = min(step, np.sum(support_) - n_features_to_select) # 该删除多少特征
            support_[features[ranks][:threshold]] = False 
            ranking_[np.logical_not(support_)] += 1

        # Set final attributes
        self.estimator_ = clone(self.estimator)
        self.estimator_.set_params(**self.estimator_params)
        self.estimator_.fit(X[:, support_], y)
        self.n_features_ = support_.sum()
        self.support_ = support_
        self.ranking_ = ranking_

        return self
</code></pre><p>实例变量estimator是一个评估器，比如逻辑斯谛回归分类器，评估器需要具有<code>coef_</code>属性。在训练一个评估器后，<code>coef_</code>相当于每个特征的权重。RFE在每一次迭代中得到新的<code>coef_</code>，并删掉权重低的特征，直到剩下的特征达到指定的数量。</p>
<p><del>这里有一个小问题：根据上面的实现的代码看，评估器需要具有<code>coef_</code>属性来指明每个特征的重要性。决策树也应该可以拿来用，但是决策树只有<code>feature_importances_</code>属性（参考<a href="http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier" target="_blank" rel="external">sklearn.tree.DecisionTreeClassifier</a>），而没有<code>coef_</code>属性。也就是，实际上决策树不能放在上面实现的RFE中。笔者认为原因是：决策树中越重要的特征离树的根越近，越不重要的特征离根越远。在删除决策树认为的不重要的部分特征后，新建的决策树中的特征按照重要性排序，依然和之前的决策树相同。也就是说，使用决策树，直接通过<code>feature_importances_</code>一次性地选取重要特征就行了，多次选取和一次选取的结果是一样的。</del></p>
<p>这里有一个小问题：根据上面的实现的代码看，评估器需要具有<code>coef_</code>属性来指明每个特征的重要性。决策树也应该可以拿来用，但是决策树只有<code>feature_importances_</code>属性（参考<a href="http://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html#sklearn.tree.DecisionTreeClassifier" target="_blank" rel="external">sklearn.tree.DecisionTreeClassifier</a>），而没有<code>coef_</code>属性。也就是，实际上决策树不能放在上面实现的RFE中。既然这样，就自己实现个吧（<code>mytools.py</code>）：</p>
<pre><code># !/usr/bin/env python
# -*- encoding:utf-8 -*-

import numpy as np
from sklearn.feature_selection import RFE
from sklearn.utils import check_X_y, safe_sqr
from sklearn.base import clone

class RFE4Tree(RFE):

    def __init__(self, estimator, n_features_to_select=None, step=1,
                 estimator_params={}, verbose=0):
        self.estimator = estimator
        self.n_features_to_select = n_features_to_select
        self.step = step
        self.estimator_params = estimator_params
        self.verbose = verbose

    def fit(self, X, y):

        X, y = check_X_y(X, y, &quot;csc&quot;)
        # Initialization
        n_features = X.shape[1]
        if self.n_features_to_select is None:
            n_features_to_select = n_features / 2
        else:
            n_features_to_select = self.n_features_to_select

        if 0.0 &lt; self.step &lt; 1.0:
            step = int(self.step * n_features)
        else:
            step = int(self.step)
        if step &lt;= 0:
            raise ValueError(&quot;Step must be &gt;0&quot;)

        support_ = np.ones(n_features, dtype=np.bool)   # true代表就用这个特征吧
        ranking_ = np.ones(n_features, dtype=np.int)    # 值越小越好
        # Elimination
        while np.sum(support_) &gt; n_features_to_select:
            print &#39;&gt;once&#39;
            # Remaining features
            features = np.arange(n_features)[support_]  # 每个值代表是第几个特征；若features中第3个值为9,代表新的第3个特征是原始的第9个特征

            # Rank the remaining features
            estimator = clone(self.estimator)
            estimator.set_params(**self.estimator_params)
            if self.verbose &gt; 0:
                print(&quot;Fitting estimator with %d features.&quot; % np.sum(support_))

            estimator.fit(X[:, features], y)  # 使用现在的特征集合来训练

            ranks = np.argsort(estimator.feature_importances_)  # 利用决策树的feature_importances_属性

            # for sparse case ranks is matrix
            ranks = np.ravel(ranks)

            # Eliminate the worse features
            threshold = min(step, np.sum(support_) - n_features_to_select) # 该删除多少特征
            support_[features[ranks][:threshold]] = False 
            ranking_[np.logical_not(support_)] += 1

        # Set final attributes
        self.estimator_ = clone(self.estimator)
        self.estimator_.set_params(**self.estimator_params)
        self.estimator_.fit(X[:, support_], y)
        self.n_features_ = support_.sum()
        self.support_ = support_
        self.ranking_ = ranking_

        return self
</code></pre><h2 id="迭代1次与迭代多次选取同样数量特征的效果对比"><a href="#迭代1次与迭代多次选取同样数量特征的效果对比" class="headerlink" title="迭代1次与迭代多次选取同样数量特征的效果对比"></a>迭代1次与迭代多次选取同样数量特征的效果对比</h2><hr>
<p>使用scikit-learn的RFE：</p>
<pre><code>&gt;&gt;&gt; from sklearn.feature_selection import RFE
&gt;&gt;&gt; from sklearn.linear_model import LogisticRegression
&gt;&gt;&gt; estimator = LogisticRegression()  # 逻辑斯谛回归
&gt;&gt;&gt; selector1 = RFE(estimator, 3000, step=200)  # 需要迭代多次
&gt;&gt;&gt; selector1 = selector1.fit(training_data, training_labels)
&gt;&gt;&gt; training_data.shape
(1998, 19630)
&gt;&gt;&gt; selector2 = RFE(estimator, 3000, step=19630-3000)  # 迭代一次就行了
&gt;&gt;&gt; selector2 = selector2.fit(training_data, training_labels)
&gt;&gt;&gt; sum(selector1.support_)
3000
&gt;&gt;&gt; sum(selector2.support_)
3000
&gt;&gt;&gt; sum(selector2.support_ == selector2.support_)
19630
&gt;&gt;&gt; sum(selector1.support_ == selector2.support_)  # 两种方法选取的特征是不一样的
19208

# 构建新数据
&gt;&gt;&gt; new_train_data2 = training_data[:, selector2.support_]
&gt;&gt;&gt; new_test_data2 = test_data[:, selector2.support_]

# 使用BernoulliNB
&gt;&gt;&gt; from sklearn.naive_bayes import BernoulliNB
&gt;&gt;&gt; bayes = BernoulliNB() 
&gt;&gt;&gt; bayes.fit(new_train_data2, training_labels)
BernoulliNB(alpha=1.0, binarize=0.0, class_prior=None, fit_prior=True)
&gt;&gt;&gt; bayes_predict_labels = bayes.predict(new_test_data2)
&gt;&gt;&gt; sum(bayes_predict_labels == test_labels)  # 效果差不多
431

# 使用selector2内置的LogisticRegression
&gt;&gt;&gt; lr_predict_labels = selector2.predict(test_data)
&gt;&gt;&gt; sum(lr_predict_labels == test_labels)     # 效果差不多
449
</code></pre><p>那决策树呢？</p>
<pre><code>&gt;&gt;&gt; from sklearn.tree import DecisionTreeClassifier
&gt;&gt;&gt; import mytools
&gt;&gt;&gt; estimator = DecisionTreeClassifier(criterion=&#39;entropy&#39;)
&gt;&gt;&gt; selector1 = mytools.RFE4Tree(estimator, 3000, step=200)  # 迭代多次
&gt;&gt;&gt; selector2 = mytools.RFE4Tree(estimator, 3000, step=19630-3000)  # 迭代1次
&gt;&gt;&gt; selector1.fit(training_data, training_labels)
&gt;&gt;&gt; selector2.fit(training_data, training_labels)
&gt;&gt;&gt; sum(selector1.support_)
3000
&gt;&gt;&gt; sum(selector2.support_)
3000
&gt;&gt;&gt; sum(selector1.support_ == selector2.support_)  # 两种方法最终选择的特征并不相同
13954
&gt;&gt;&gt; tree_predict_labels = selector1.predict(test_data)  # 利用selector1选择的特征来分类
&gt;&gt;&gt; sum(tree_predict_labels == test_labels)  # selector1分类正确的数量
347
&gt;&gt;&gt; tree_predict_labels = selector2.predict(test_data) # 利用selector2选择的特征来分类
&gt;&gt;&gt; sum(tree_predict_labels == test_labels)  # selector2分类正确的数量
340
&gt;&gt;&gt; estimator.fit(training_data, training_labels)  # 用所有的特征来训练
&gt;&gt;&gt; tree_predict_labels = estimator.predict(test_data) # 预测
&gt;&gt;&gt; sum(tree_predict_labels == test_labels)        
341
</code></pre><p>（完）</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2015-04-01&lt;/p&gt;
&lt;p&gt;特征递归消除（recursive feature elimination，RFE）是特征选择的一种方法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://scikit-learn.org/stable/modules/generated/s
    
    </summary>
    
    
      <category term="机器学习" scheme="http://www.letiantian.me/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
